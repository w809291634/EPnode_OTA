/*********************************************************************************************
* 文件：iic.c
* 作者：wanghao
* 说明：iic驱动程序
* 修改：
* 注释：
*********************************************************************************************/

/*********************************************************************************************
* 头文件
*********************************************************************************************/
#include "iic_oled.h"

/*********************************************************************************************
* 名称：iic_init()
* 功能：I2C初始化函数
* 参数：无
* 返回：无
* 修改：
* 注释：
*********************************************************************************************/
void iic_init(void)
{
#if RTOS_SUPPORT == 1
  GPIO_InitTypeDef  GPIO_InitStructure={0};
  RCC_APB2PeriphClockCmd(I2C_CLK, ENABLE);
   
  GPIO_InitStructure.GPIO_Pin = PIN_SCL|PIN_SDA;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(I2C_GPIO, &GPIO_InitStructure);

  SCL(1);
  SDA(1);
#else
  P0SEL &= ~0X03;                                              	//设置P0_0/P0_1为普通IO模式
  P0DIR |= 0X03;                                                //设置P0_0/P0_1为输出模式
  SDA = 1;                                                      //拉高数据线
  SCL = 1;                                                      //拉高时钟线
#endif 
}

/*********************************************************************************************
* 名称：iic_start()
* 功能：I2C起始信号
* 参数：无
* 返回：无
* 修改：
* 注释：
*********************************************************************************************/
void iic_start(void)
{
  SDA_OUT;                                                     // 数据线输出模式
#if RTOS_SUPPORT == 1
  SDA(1);                                                      // 拉高数据线
  SCL(1);                                                      // 拉高时钟线
  delay_us(1);                                                 // 启动条件设置时间 最小0.6us
  SDA(0);                                                      // 数据线拉低
  delay_us(1);                                                 // 启动条件保持时间 最小0.6us
  SCL(0); 
#else
  SDA = 1;                                                      // 拉高数据线
  SCL = 1;                                                      // 拉高时钟线
  delay_us(1);                                                  // 启动条件设置时间 最小0.6us
  SDA = 0;                                                      // 数据线拉低
  delay_us(1);                                                  // 启动条件保持时间 最小0.6us
  SCL = 0;                                                      // 拉低时钟线
#endif
}

/*********************************************************************************************
* 名称：iic_stop()
* 功能：I2C停止信号
* 参数：无
* 返回：无
* 修改：
* 注释：
*********************************************************************************************/
void iic_stop(void)
{
  SDA_OUT; 
#if RTOS_SUPPORT == 1
  SDA(0);                                                       // 拉低数据线
  SCL(1);                                                       // 拉高时钟线
  delay_us(1);                                                  // 停止条件设置时间 最小0.6us
  SDA(1);                                                       // 产生上升沿
  delay_us(1);                                                  // 空闲时间 最小1.3us 实测1时为2us
#else
  SDA =0;                                                       // 拉低数据线
  SCL =1;                                                       // 拉高时钟线
  delay_us(1);                                                  // 停止条件设置时间 最小0.6us
  SDA=1;                                                        // 产生上升沿
  delay_us(2);                                                  // 空闲时间 最小1.3us
#endif
}

/*********************************************************************************************
* 名称：iic_write_byte()
* 功能：I2C写一个字节数据，返回ACK或者NACK，从高到低，依次发送
* 参数：data -- 要写的数据
* 返回：0：主站没有收到应答
*       1：主站收到应答
* 修改：
* 注释：
*********************************************************************************************/
unsigned char iic_write_byte(unsigned char data)
{
  SDA_OUT;                                                      // 数据线输出模式
#if RTOS_SUPPORT == 1
  SCL(0);                                                      // 拉低时钟线
  for(char i = 0;i < 8;i++){ 
    if(data & 0x80) {SDA(1)}                                    // 数据线操作 
    else {SDA(0)}
    delay_us(1);                                                // Data Setup Time，至少100ns，稳定SDA
    SCL(1);	                                                    // 拉高SCL时钟线,给出上升沿,从机检测到后进行数据采样
    delay_us(1);                                                // Data Hold Time,至少300ns
    data <<= 1;                                                 // 数组左移一位
    SCL(0);                                                     // 拉低SCL时钟线 
  } 
  SDA_IN;
  SDA(1);                                                       // 拉高数据线
//  delay_us(1);                                                // SDAOUT最小为0ns
  SCL(1);                                                       // 拉高时钟线,接收应答信号
  if(R_SDA == 1) return 0;			                                // SDA为高，收到NACK
  else { 				                                                
    SCL(0);                                                     // 拉低时钟线
    return 1;                                                  // SDA为低，收到ACK
  }
#else
  SCL = 0;                                                      // 拉低时钟线
  for(char i = 0;i < 8;i++){ 
    if(data & 0x80) SDA = 1;                                    // 数据线操作 
    else SDA = 0;
    delay_us(1);                                                // Data Setup Time，至少100ns，稳定SDA
    SCL = 1;	                                                  // 拉高SCL时钟线,给出上升沿,从机检测到后进行数据采样
    delay_us(1);                                                // Data Hold Time,至少300ns
    data <<= 1;                                                 // 数组左移一位
    SCL = 0;                                                    // 拉低SCL时钟线 
  } 
  /*为了减少开栈时间，应答部分写在这里*/
  SDA_IN;
  SDA = 1;                                                      // 拉高数据线
  SCL = 1;                                                      // 拉高时钟线,接收应答信号
//  delay_us(1);                                                // SDAOUT最小为0ns
  if(SDA == 1) return 0;			                                  // SDA为高，收到NACK
  else { 				                                                
    SCL = 0;                                                    // 拉低时钟线
    return 1;                                                  // SDA为低，收到ACK
  }
#endif
}
