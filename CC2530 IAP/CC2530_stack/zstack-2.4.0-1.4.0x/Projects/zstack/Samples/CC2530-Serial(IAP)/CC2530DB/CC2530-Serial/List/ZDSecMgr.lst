###############################################################################
#
# IAR C/C++ Compiler V9.10.1.2146 for 8051                07/Jul/2023  16:40:47
# Copyright 2004-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=8448
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440 "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Components\stack\zdo\ZDSecMgr.c"
#        -D HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
#        XLAB -D CC2530_Serial -D MAKE_CRC_SHDW -D CC2530_USE_IAP -lC
#        "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\CC2530-Serial\List\"
#        -lA "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\CC2530-Serial\List\"
#        --diag_suppress Pe001,Pa010 -o "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\CC2530-Serial\Obj\"
#        -e --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 8 -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\Source\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\common\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\osal\mcu\ccsoc\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On
#    List file          =  
#        I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\CC2530-Serial\List\ZDSecMgr.lst
#    Object file        =  
#        I:\1_git_code\EPnode_OTA\CC2530
#        IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Projects\zstack\Samples\CC2530-Serial(IAP)\CC2530DB\CC2530-Serial\Obj\ZDSecMgr.r51
#
###############################################################################

I:\1_git_code\EPnode_OTA\CC2530 IAP\CC2530_stack\zstack-2.4.0-1.4.0x\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-08-20 16:29:19 -0700 (Fri, 20 Aug 2010) $
      4            Revision:       $Revision: 23466 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    123          
    124          /******************************************************************************
    125           * TYPEDEFS
    126           */
    127          typedef struct
    128          {
    129            uint8 extAddr[Z_EXTADDR_LEN];
    130            uint8 key[SEC_KEY_LEN];
    131          } ZDSecMgrPreConfigData_t;
    132          
    133          typedef struct
    134          {
    135            uint16 ami;
    136            uint8  key[SEC_KEY_LEN];
    137          } ZDSecMgrMasterKeyData_t;
    138          
    139          typedef struct
    140          {
    141            uint16            ami;
    142            uint16            keyNvId;   // index to the Link Key table in NV
    143            ZDSecMgr_Authentication_Option authenticateOption;
    144          } ZDSecMgrEntry_t;
    145          
    146          typedef struct
    147          {
    148            ZDSecMgrEntry_t* entry;
    149            uint16           parentAddr;
    150            uint8            secure;
    151            uint8            state;
    152            uint8            cntr;
    153          } ZDSecMgrCtrl_t;
    154          
    155          typedef struct
    156          {
    157            uint16          nwkAddr;
    158            uint8*          extAddr;
    159            uint16          parentAddr;
    160            uint8           secure;
    161            uint8           devStatus;
    162            ZDSecMgrCtrl_t* ctrl;
    163          } ZDSecMgrDevice_t;
    164          
    165          /******************************************************************************
    166           * LOCAL VARIABLES
    167           */
    168          #if 0 // Taken out because the following functionality is only used for test
    169                // purpose. A more efficient (above) way is used. It can be put
    170                // back in if customers request for a white/black list feature.
    171          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    172          {
    173            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    174            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    175            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    176          };
    177          #endif
    178          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    180            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    181          
    182          // Key data is put in CONST area for security reasons

   \                                 In  segment CODE_C, align 1
    183          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171
    184            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    185             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    186          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    189          
    190          //devtag.pro.security - remove this
    191          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    192          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    193          {
    194            //---------------------------------------------------------------------------
    195            // DEVICE A
    196            //---------------------------------------------------------------------------
    197            {
    198              // extAddr
    199              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    200          
    201              // key
    202              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    203               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    204            },
    205            //---------------------------------------------------------------------------
    206            // DEVICE B
    207            //---------------------------------------------------------------------------
    208            {
    209              // extAddr
    210              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    211          
    212              // key
    213              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    214               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    215            },
    216            //---------------------------------------------------------------------------
    217            // DEVICE C
    218            //---------------------------------------------------------------------------
    219            {
    220              // extAddr
    221              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    222          
    223              // key
    224              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    225               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    226            },
    227          };
    228          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    229          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    230          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    231          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    232          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    233          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    234          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    236          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    237          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    238          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    239          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    241          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    242          
    243          /******************************************************************************
    244           * PRIVATE FUNCTIONS
    245           *
    246           *   ZDSecMgrMasterKeyInit
    247           *   ZDSecMgrAddrStore
    248           *   ZDSecMgrExtAddrStore
    249           *   ZDSecMgrExtAddrLookup
    250           *   ZDSecMgrMasterKeyLookup
    251           *   ZDSecMgrMasterKeyStore
    252           *   ZDSecMgrEntryInit
    253           *   ZDSecMgrEntryLookup
    254           *   ZDSecMgrEntryLookupAMI
    255           *   ZDSecMgrEntryLookupExt
    256           *   ZDSecMgrEntryLookupExtGetIndex
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           *   APSME_TCLinkKeyInit
    290           *   APSME_IsDefaultTCLK
    291           */
    292          //-----------------------------------------------------------------------------
    293          // master key data
    294          //-----------------------------------------------------------------------------
    295          void ZDSecMgrMasterKeyInit( void );
    296          
    297          //-----------------------------------------------------------------------------
    298          // address management
    299          //-----------------------------------------------------------------------------
    300          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    301          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    302          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    303          
    304          //-----------------------------------------------------------------------------
    305          // MASTER key data
    306          //-----------------------------------------------------------------------------
    307          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    308          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    309          
    310          //-----------------------------------------------------------------------------
    311          // entry data
    312          //-----------------------------------------------------------------------------
    313          void ZDSecMgrEntryInit(uint8 state);
    314          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    315          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    316          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    318          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    319          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    320          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    321          void ZDSecMgrApsLinkKeyInit(void);
    322          #if defined NV_RESTORE
    323          static void ZDSecMgrWriteNV(void);
    324          static void ZDSecMgrRestoreFromNV(void);
    325          #endif
    326          
    327          //-----------------------------------------------------------------------------
    328          // control data
    329          //-----------------------------------------------------------------------------
    330          void ZDSecMgrCtrlInit( void );
    331          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    332          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    333          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    334                                ZDSecMgrEntry_t*  entry,
    335                                ZDSecMgrCtrl_t*   ctrl );
    336          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    337          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    338          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    339                                       ZDSecMgrEntry_t*  entry );
    340          
    341          //-----------------------------------------------------------------------------
    342          // key support
    343          //-----------------------------------------------------------------------------
    344          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    345          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    346                                       uint8*  initExtAddr,
    347                                       uint16  partNwkAddr,
    348                                       uint8*  partExtAddr,
    349                                       uint8** key,
    350                                       uint8*  keyType );
    351          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    352          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    353          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    354          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    355          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    356          
    357          //-----------------------------------------------------------------------------
    358          // device entry
    359          //-----------------------------------------------------------------------------
    360          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    361          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    362          
    363          //-----------------------------------------------------------------------------
    364          // device control
    365          //-----------------------------------------------------------------------------
    366          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    367          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    368          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    369          
    370          //-----------------------------------------------------------------------------
    371          // device management
    372          //-----------------------------------------------------------------------------
    373          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    374          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    375          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    376          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    377          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    379          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    382          
    383          //-----------------------------------------------------------------------------
    384          // association management
    385          //-----------------------------------------------------------------------------
    386          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    387          
    388          //-----------------------------------------------------------------------------
    389          // authentication management
    390          //-----------------------------------------------------------------------------
    391          void ZDSecMgrAuthInitiate( uint8* responder );
    392          void ZDSecMgrAuthNwkKey( void );
    393          
    394          //-----------------------------------------------------------------------------
    395          // APSME function
    396          //-----------------------------------------------------------------------------
    397          void APSME_TCLinkKeyInit( uint8 setDefault );
    398          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    399          
    400          /******************************************************************************
    401           * @fn          ZDSecMgrMasterKeyInit                     ]
    402           *
    403           * @brief       Initialize master key data in NV
    404           *
    405           * @param       none
    406           *
    407           * @return      none
    408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    409          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    410          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    411            uint16 index;
    412            ZDSecMgrMasterKeyData_t   masterKeyData;
    413          
    414            masterKeyData.ami = INVALID_NODE_ADDR;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   74FE         MOV     A,#-0x2
   \   000012   F0           MOVX    @DPTR,A
   \   000013   A3           INC     DPTR
   \   000014   74FF         MOV     A,#-0x1
   \   000016   F0           MOVX    @DPTR,A
    415          
    416            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
   \   000017                ; Setup parameters for call to function osal_memset
   \   000017   7C10         MOV     R4,#0x10
   \   000019   7D00         MOV     R5,#0x0
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   AA82         MOV     R2,DPL
   \   000024   AB83         MOV     R3,DPH
   \   000026   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    417          
    418            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000029   7E00         MOV     R6,#0x0
   \   00002B   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00002D   C3           CLR     C
   \   00002E   EE           MOV     A,R6
   \   00002F   9403         SUBB    A,#0x3
   \   000031   EF           MOV     A,R7
   \   000032   9400         SUBB    A,#0x0
   \   000034   5058         JNC     ??ZDSecMgrMasterKeyInit_1
    419            {
    420              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index), 
    421                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
   \   000036                ; Setup parameters for call to function osal_nv_item_init
   \   000036   A8..         MOV     R0,?XSP + 0
   \   000038   A9..         MOV     R1,?XSP + 1
   \   00003A   88..         MOV     ?V0,R0
   \   00003C   89..         MOV     ?V1,R1
   \   00003E   78..         MOV     R0,#?V0
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   7C12         MOV     R4,#0x12
   \   000045   7D00         MOV     R5,#0x0
   \   000047   EE           MOV     A,R6
   \   000048   2401         ADD     A,#0x1
   \   00004A   FA           MOV     R2,A
   \   00004B   EF           MOV     A,R7
   \   00004C   3403         ADDC    A,#0x3
   \   00004E   FB           MOV     R3,A
   \   00004F   12....       LCALL   ??osal_nv_item_init?relay; Banked call to: osal_nv_item_init
   \   000052   7402         MOV     A,#0x2
   \   000054   12....       LCALL   ?DEALLOC_XSTACK8
   \   000057   E9           MOV     A,R1
   \   000058   702D         JNZ     ??ZDSecMgrMasterKeyInit_2
    422              {
    423                // the item already exists in NV just needs to be set to default values
    424                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    425                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   00005A                ; Setup parameters for call to function osal_nv_write
   \   00005A   A8..         MOV     R0,?XSP + 0
   \   00005C   A9..         MOV     R1,?XSP + 1
   \   00005E   88..         MOV     ?V0,R0
   \   000060   89..         MOV     ?V1,R1
   \   000062   78..         MOV     R0,#?V0
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   75..12       MOV     ?V0,#0x12
   \   00006A   75..00       MOV     ?V1,#0x0
   \   00006D   78..         MOV     R0,#?V0
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   7C00         MOV     R4,#0x0
   \   000074   7D00         MOV     R5,#0x0
   \   000076   EE           MOV     A,R6
   \   000077   2401         ADD     A,#0x1
   \   000079   FA           MOV     R2,A
   \   00007A   EF           MOV     A,R7
   \   00007B   3403         ADDC    A,#0x3
   \   00007D   FB           MOV     R3,A
   \   00007E   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
   \   000086   E9           MOV     A,R1
    426              }
    427            }
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   000087   0E           INC     R6
   \   000088   EE           MOV     A,R6
   \   000089   70A2         JNZ     ??ZDSecMgrMasterKeyInit_0
   \   00008B   0F           INC     R7
   \   00008C   809F         SJMP    ??ZDSecMgrMasterKeyInit_0
    428          }
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   00008E   7412         MOV     A,#0x12
   \   000090   12....       LCALL   ?DEALLOC_XSTACK8
   \   000093   7F02         MOV     R7,#0x2
   \   000095   02....       LJMP    ?BANKED_LEAVE_XDATA
    429          
    430          /******************************************************************************
    431           * @fn          ZDSecMgrAddrStore
    432           *
    433           * @brief       Store device addresses.
    434           *
    435           * @param       nwkAddr - [in] NWK address
    436           * @param       extAddr - [in] EXT address
    437           * @param       ami     - [out] Address Manager index
    438           *
    439           * @return      ZStatus_t
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    442          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V4,R4
   \   000010   8D..         MOV     ?V5,R5
   \   000012   741B         MOV     A,#0x1b
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
    443            ZStatus_t      status;
    444            AddrMgrEntry_t entry;
    445          
    446          
    447            // add entry
    448            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   7402         MOV     A,#0x2
   \   000024   F0           MOVX    @DPTR,A
    449            entry.nwkAddr = nwkAddr;
   \   000025   7401         MOV     A,#0x1
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E5..         MOV     A,?V2
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V3
   \   000030   F0           MOVX    @DPTR,A
    450            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000031                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000031   AC..         MOV     R4,?V4
   \   000033   AD..         MOV     R5,?V5
   \   000035   7403         MOV     A,#0x3
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   AA82         MOV     R2,DPL
   \   00003C   AB83         MOV     R3,DPH
   \   00003E   12....       LCALL   ??AddrMgrExtAddrSet?relay; Banked call to: AddrMgrExtAddrSet
    451          
    452            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000041                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000041   AA..         MOV     R2,?XSP + 0
   \   000043   AB..         MOV     R3,?XSP + 1
   \   000045   12....       LCALL   ??AddrMgrEntryUpdate?relay; Banked call to: AddrMgrEntryUpdate
   \   000048   E9           MOV     A,R1
   \   000049   6401         XRL     A,#0x1
   \   00004B   7018         JNZ     ??ZDSecMgrAddrStore_0
    453            {
    454              // return successful results
    455              *ami   = entry.index;
   \   00004D   740B         MOV     A,#0xb
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F8           MOV     R0,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F9           MOV     R1,A
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   E8           MOV     A,R0
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E9           MOV     A,R1
   \   00005F   F0           MOVX    @DPTR,A
    456              status = ZSuccess;
   \   000060   75..00       MOV     ?V0,#0x0
   \   000063   8016         SJMP    ??ZDSecMgrAddrStore_1
    457            }
    458            else
    459            {
    460              // return failed results
    461              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   000065   740B         MOV     A,#0xb
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   8E82         MOV     DPL,R6
   \   000071   8F83         MOV     DPH,R7
   \   000073   E8           MOV     A,R0
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   E9           MOV     A,R1
   \   000077   F0           MOVX    @DPTR,A
    462              status = ZNwkUnknownDevice;
   \   000078   75..C8       MOV     ?V0,#-0x38
    463            }
    464          
    465            return status;
   \                     ??ZDSecMgrAddrStore_1:
   \   00007B   A9..         MOV     R1,?V0
   \   00007D   740D         MOV     A,#0xd
   \   00007F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000082   7F06         MOV     R7,#0x6
   \   000084   02....       LJMP    ?BANKED_LEAVE_XDATA
    466          }
    467          
    468          /******************************************************************************
    469           * @fn          ZDSecMgrExtAddrStore
    470           *
    471           * @brief       Store EXT address.
    472           *
    473           * @param       extAddr - [in] EXT address
    474           * @param       ami     - [out] Address Manager index
    475           *
    476           * @return      ZStatus_t
    477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    478          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    479          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V4,R4
   \   000010   8D..         MOV     ?V5,R5
   \   000012   741B         MOV     A,#0x1b
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
    480            ZStatus_t      status;
    481            AddrMgrEntry_t entry;
    482          
    483          
    484            // add entry
    485            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   7402         MOV     A,#0x2
   \   000024   F0           MOVX    @DPTR,A
    486            entry.nwkAddr = nwkAddr;
   \   000025   7401         MOV     A,#0x1
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E5..         MOV     A,?V2
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V3
   \   000030   F0           MOVX    @DPTR,A
    487            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000031                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000031   AC..         MOV     R4,?V4
   \   000033   AD..         MOV     R5,?V5
   \   000035   7403         MOV     A,#0x3
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   AA82         MOV     R2,DPL
   \   00003C   AB83         MOV     R3,DPH
   \   00003E   12....       LCALL   ??AddrMgrExtAddrSet?relay; Banked call to: AddrMgrExtAddrSet
    488          
    489            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000041                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000041   AA..         MOV     R2,?XSP + 0
   \   000043   AB..         MOV     R3,?XSP + 1
   \   000045   12....       LCALL   ??AddrMgrEntryUpdate?relay; Banked call to: AddrMgrEntryUpdate
   \   000048   E9           MOV     A,R1
   \   000049   6401         XRL     A,#0x1
   \   00004B   7018         JNZ     ??ZDSecMgrExtAddrStore_0
    490            {
    491              // return successful results
    492              *ami   = entry.index;
   \   00004D   740B         MOV     A,#0xb
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F8           MOV     R0,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F9           MOV     R1,A
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   E8           MOV     A,R0
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E9           MOV     A,R1
   \   00005F   F0           MOVX    @DPTR,A
    493              status = ZSuccess;
   \   000060   75..00       MOV     ?V0,#0x0
   \   000063   8016         SJMP    ??ZDSecMgrExtAddrStore_1
    494            }
    495            else
    496            {
    497              // return failed results
    498              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   000065   740B         MOV     A,#0xb
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   8E82         MOV     DPL,R6
   \   000071   8F83         MOV     DPH,R7
   \   000073   E8           MOV     A,R0
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   E9           MOV     A,R1
   \   000077   F0           MOVX    @DPTR,A
    499              status = ZNwkUnknownDevice;
   \   000078   75..C8       MOV     ?V0,#-0x38
    500            }
    501          
    502            return status;
   \                     ??ZDSecMgrExtAddrStore_1:
   \   00007B   A9..         MOV     R1,?V0
   \   00007D   740D         MOV     A,#0xd
   \   00007F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000082   7F06         MOV     R7,#0x6
   \   000084   02....       LJMP    ?BANKED_LEAVE_XDATA
    503          }
    504          
    505          /******************************************************************************
    506           * @fn          ZDSecMgrExtAddrLookup
    507           *
    508           * @brief       Lookup index for specified EXT address.
    509           *
    510           * @param       extAddr - [in] EXT address
    511           * @param       ami     - [out] Address Manager index
    512           *
    513           * @return      ZStatus_t
    514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    515          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    516          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    517            ZStatus_t      status;
    518            AddrMgrEntry_t entry;
    519          
    520          
    521            // lookup entry
    522            entry.user = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
    523            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   00001B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001B   AC..         MOV     R4,?V0
   \   00001D   AD..         MOV     R5,?V1
   \   00001F   7403         MOV     A,#0x3
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   12....       LCALL   ??AddrMgrExtAddrSet?relay; Banked call to: AddrMgrExtAddrSet
    524          
    525            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   00002B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002B   AA..         MOV     R2,?XSP + 0
   \   00002D   AB..         MOV     R3,?XSP + 1
   \   00002F   12....       LCALL   ??AddrMgrEntryLookupExt?relay; Banked call to: AddrMgrEntryLookupExt
   \   000032   E9           MOV     A,R1
   \   000033   6401         XRL     A,#0x1
   \   000035   7018         JNZ     ??ZDSecMgrExtAddrLookup_0
    526            {
    527              // return successful results
    528              *ami   = entry.index;
   \   000037   740B         MOV     A,#0xb
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   E8           MOV     A,R0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E9           MOV     A,R1
   \   000049   F0           MOVX    @DPTR,A
    529              status = ZSuccess;
   \   00004A   75..00       MOV     ?V2,#0x0
   \   00004D   8016         SJMP    ??ZDSecMgrExtAddrLookup_1
    530            }
    531            else
    532            {
    533              // return failed results
    534              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00004F   740B         MOV     A,#0xb
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F9           MOV     R1,A
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   E8           MOV     A,R0
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   E9           MOV     A,R1
   \   000061   F0           MOVX    @DPTR,A
    535              status = ZNwkUnknownDevice;
   \   000062   75..C8       MOV     ?V2,#-0x38
    536            }
    537          
    538            return status;
   \                     ??ZDSecMgrExtAddrLookup_1:
   \   000065   A9..         MOV     R1,?V2
   \   000067   740D         MOV     A,#0xd
   \   000069   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006C   7F03         MOV     R7,#0x3
   \   00006E   02....       LJMP    ?BANKED_LEAVE_XDATA
    539          }
    540          
    541          /******************************************************************************
    542           * @fn          ZDSecMgrMasterKeyLookup
    543           *
    544           * @brief       Lookup MASTER key for specified address index.
    545           *
    546           * @param       ami - [in] Address Manager index
    547           * @param       pKeyNvId - [out] MASTER key NV ID
    548           *
    549           * @return      ZStatus_t
    550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
   \                     ZDSecMgrMasterKeyLookup:
    552          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
    553            uint16 index;
    554            ZDSecMgrMasterKeyData_t masterKeyData;
    555          
    556            
    557            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   7E00         MOV     R6,#0x0
   \   000014   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000016   C3           CLR     C
   \   000017   EE           MOV     A,R6
   \   000018   9403         SUBB    A,#0x3
   \   00001A   EF           MOV     A,R7
   \   00001B   9400         SUBB    A,#0x0
   \   00001D   5069         JNC     ??ZDSecMgrMasterKeyLookup_1
    558            {  
    559              // Read entry index of the Master key table from NV
    560              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    561                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   00001F                ; Setup parameters for call to function osal_nv_read
   \   00001F   A8..         MOV     R0,?XSP + 0
   \   000021   A9..         MOV     R1,?XSP + 1
   \   000023   88..         MOV     ?V4,R0
   \   000025   89..         MOV     ?V5,R1
   \   000027   78..         MOV     R0,#?V4
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   75..12       MOV     ?V4,#0x12
   \   00002F   75..00       MOV     ?V5,#0x0
   \   000032   78..         MOV     R0,#?V4
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000037   7C00         MOV     R4,#0x0
   \   000039   7D00         MOV     R5,#0x0
   \   00003B   EE           MOV     A,R6
   \   00003C   2401         ADD     A,#0x1
   \   00003E   FA           MOV     R2,A
   \   00003F   EF           MOV     A,R7
   \   000040   3403         ADDC    A,#0x3
   \   000042   FB           MOV     R3,A
   \   000043   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000046   7404         MOV     A,#0x4
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004B   E9           MOV     A,R1
    562              
    563              if ( masterKeyData.ami == ami )
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   65..         XRL     A,?V2
   \   000055   7004         JNZ     ??ZDSecMgrMasterKeyLookup_2
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   65..         XRL     A,?V3
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   00005B   7024         JNZ     ??ZDSecMgrMasterKeyLookup_3
    564              {
    565                // return successful results
    566                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
   \   00005D   EE           MOV     A,R6
   \   00005E   2401         ADD     A,#0x1
   \   000060   F8           MOV     R0,A
   \   000061   EF           MOV     A,R7
   \   000062   3403         ADDC    A,#0x3
   \   000064   F9           MOV     R1,A
   \   000065   85..82       MOV     DPL,?V0
   \   000068   85..83       MOV     DPH,?V1
   \   00006B   E8           MOV     A,R0
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   A3           INC     DPTR
   \   00006E   E9           MOV     A,R1
   \   00006F   F0           MOVX    @DPTR,A
    567                
    568                // clear copy of key in RAM
    569                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   000070                ; Setup parameters for call to function osal_memset
   \   000070   7C12         MOV     R4,#0x12
   \   000072   7D00         MOV     R5,#0x0
   \   000074   7900         MOV     R1,#0x0
   \   000076   AA..         MOV     R2,?XSP + 0
   \   000078   AB..         MOV     R3,?XSP + 1
   \   00007A   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    570                
    571                return ZSuccess;
   \   00007D   7900         MOV     R1,#0x0
   \   00007F   8023         SJMP    ??ZDSecMgrMasterKeyLookup_4
    572              }
    573            }
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   000081   0E           INC     R6
   \   000082   EE           MOV     A,R6
   \   000083   7091         JNZ     ??ZDSecMgrMasterKeyLookup_0
   \   000085   0F           INC     R7
   \   000086   808E         SJMP    ??ZDSecMgrMasterKeyLookup_0
    574            
    575            *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000088   85..82       MOV     DPL,?V0
   \   00008B   85..83       MOV     DPH,?V1
   \   00008E   7400         MOV     A,#0x0
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   7400         MOV     A,#0x0
   \   000094   F0           MOVX    @DPTR,A
    576          
    577            // clear copy of key in RAM
    578            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   000095                ; Setup parameters for call to function osal_memset
   \   000095   7C12         MOV     R4,#0x12
   \   000097   7D00         MOV     R5,#0x0
   \   000099   7900         MOV     R1,#0x0
   \   00009B   AA..         MOV     R2,?XSP + 0
   \   00009D   AB..         MOV     R3,?XSP + 1
   \   00009F   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    579          
    580            return ZNwkUnknownDevice;
   \   0000A2   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   0000A4   7412         MOV     A,#0x12
   \   0000A6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A9   7F06         MOV     R7,#0x6
   \   0000AB   02....       LJMP    ?BANKED_LEAVE_XDATA
    581          }
    582          
    583          /******************************************************************************
    584           * @fn          ZDSecMgrMasterKeyStore
    585           *
    586           * @brief       Store MASTER key for specified address index.
    587           *
    588           * @param       ami - [in] Address Manager index
    589           * @param       key - [in] valid key to store
    590           *
    591           * @return      ZStatus_t
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    594          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V6,R2
   \   00000C   8B..         MOV     ?V7,R3
   \   00000E   8C..         MOV     ?V4,R4
   \   000010   8D..         MOV     ?V5,R5
    595            uint16    index;
    596            ZDSecMgrMasterKeyData_t   masterKeyData;
    597            
    598          
    599            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   7E00         MOV     R6,#0x0
   \   000014   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000016   C3           CLR     C
   \   000017   EE           MOV     A,R6
   \   000018   9403         SUBB    A,#0x3
   \   00001A   EF           MOV     A,R7
   \   00001B   9400         SUBB    A,#0x0
   \   00001D   4003         JC      $+5
   \   00001F   02....       LJMP    ??ZDSecMgrMasterKeyStore_1 & 0xFFFF
    600            {
    601              // Read entry index of the Master key table from NV
    602              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    603                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   000022                ; Setup parameters for call to function osal_nv_read
   \   000022   A8..         MOV     R0,?XSP + 0
   \   000024   A9..         MOV     R1,?XSP + 1
   \   000026   88..         MOV     ?V0,R0
   \   000028   89..         MOV     ?V1,R1
   \   00002A   78..         MOV     R0,#?V0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   75..12       MOV     ?V0,#0x12
   \   000032   75..00       MOV     ?V1,#0x0
   \   000035   78..         MOV     R0,#?V0
   \   000037   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003A   7C00         MOV     R4,#0x0
   \   00003C   7D00         MOV     R5,#0x0
   \   00003E   EE           MOV     A,R6
   \   00003F   2401         ADD     A,#0x1
   \   000041   FA           MOV     R2,A
   \   000042   EF           MOV     A,R7
   \   000043   3403         ADDC    A,#0x3
   \   000045   FB           MOV     R3,A
   \   000046   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004E   E9           MOV     A,R1
    604          
    605              if ( masterKeyData.ami == INVALID_NODE_ADDR )
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   E0           MOVX    A,@DPTR
   \   000056   64FE         XRL     A,#0xfe
   \   000058   7004         JNZ     ??ZDSecMgrMasterKeyStore_2
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   00005E   6003         JZ      $+5
   \   000060   02....       LJMP    ??ZDSecMgrMasterKeyStore_3 & 0xFFFF
    606              {
    607                // store EXT address index
    608                masterKeyData.ami = ami;
   \   000063   85..82       MOV     DPL,?XSP + 0
   \   000066   85..83       MOV     DPH,?XSP + 1
   \   000069   E5..         MOV     A,?V6
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   E5..         MOV     A,?V7
   \   00006F   F0           MOVX    @DPTR,A
    609          
    610                if ( key != NULL )
   \   000070   E5..         MOV     A,?V4
   \   000072   45..         ORL     A,?V5
   \   000074   6025         JZ      ??ZDSecMgrMasterKeyStore_4
    611                {
    612                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
   \   000076                ; Setup parameters for call to function osal_memcpy
   \   000076   85....       MOV     ?V0,?V4
   \   000079   85....       MOV     ?V1,?V5
   \   00007C   75..00       MOV     ?V2,#0x0
   \   00007F   78..         MOV     R0,#?V0
   \   000081   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000084   7C10         MOV     R4,#0x10
   \   000086   7D00         MOV     R5,#0x0
   \   000088   7405         MOV     A,#0x5
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   AA82         MOV     R2,DPL
   \   00008F   AB83         MOV     R3,DPH
   \   000091   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000094   7403         MOV     A,#0x3
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   \   000099   8012         SJMP    ??ZDSecMgrMasterKeyStore_5
    613                }
    614                else
    615                {
    616                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   00009B                ; Setup parameters for call to function osal_memset
   \   00009B   7C10         MOV     R4,#0x10
   \   00009D   7D00         MOV     R5,#0x0
   \   00009F   7900         MOV     R1,#0x0
   \   0000A1   7402         MOV     A,#0x2
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   AA82         MOV     R2,DPL
   \   0000A8   AB83         MOV     R3,DPH
   \   0000AA   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    617                }
    618          
    619                // set new values in NV      
    620                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    621                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   0000AD                ; Setup parameters for call to function osal_nv_write
   \   0000AD   A8..         MOV     R0,?XSP + 0
   \   0000AF   A9..         MOV     R1,?XSP + 1
   \   0000B1   88..         MOV     ?V0,R0
   \   0000B3   89..         MOV     ?V1,R1
   \   0000B5   78..         MOV     R0,#?V0
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BA   75..12       MOV     ?V0,#0x12
   \   0000BD   75..00       MOV     ?V1,#0x0
   \   0000C0   78..         MOV     R0,#?V0
   \   0000C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C5   7C00         MOV     R4,#0x0
   \   0000C7   7D00         MOV     R5,#0x0
   \   0000C9   EE           MOV     A,R6
   \   0000CA   2401         ADD     A,#0x1
   \   0000CC   FA           MOV     R2,A
   \   0000CD   EF           MOV     A,R7
   \   0000CE   3403         ADDC    A,#0x3
   \   0000D0   FB           MOV     R3,A
   \   0000D1   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   0000D4   7404         MOV     A,#0x4
   \   0000D6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D9   E9           MOV     A,R1
    622                 
    623                // clear copy of key in RAM
    624                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000DA                ; Setup parameters for call to function osal_memset
   \   0000DA   7C12         MOV     R4,#0x12
   \   0000DC   7D00         MOV     R5,#0x0
   \   0000DE   7900         MOV     R1,#0x0
   \   0000E0   AA..         MOV     R2,?XSP + 0
   \   0000E2   AB..         MOV     R3,?XSP + 1
   \   0000E4   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    625          
    626                // return successful results
    627                return ZSuccess;
   \   0000E7   7900         MOV     R1,#0x0
   \   0000E9   8017         SJMP    ??ZDSecMgrMasterKeyStore_6
    628              }
    629            }
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   0000EB   0E           INC     R6
   \   0000EC   EE           MOV     A,R6
   \   0000ED   7001         JNZ     ??ZDSecMgrMasterKeyStore_7
   \   0000EF   0F           INC     R7
   \                     ??ZDSecMgrMasterKeyStore_7:
   \   0000F0   02....       LJMP    ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    630            
    631            // clear copy of key in RAM
    632            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   0000F3                ; Setup parameters for call to function osal_memset
   \   0000F3   7C12         MOV     R4,#0x12
   \   0000F5   7D00         MOV     R5,#0x0
   \   0000F7   7900         MOV     R1,#0x0
   \   0000F9   AA..         MOV     R2,?XSP + 0
   \   0000FB   AB..         MOV     R3,?XSP + 1
   \   0000FD   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    633            
    634            return ZNwkUnknownDevice;
   \   000100   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   000102   7412         MOV     A,#0x12
   \   000104   12....       LCALL   ?DEALLOC_XSTACK8
   \   000107   7F08         MOV     R7,#0x8
   \   000109   02....       LJMP    ?BANKED_LEAVE_XDATA
    635          }
    636          
    637          /******************************************************************************
    638           * @fn          ZDSecMgrEntryInit
    639           *
    640           * @brief       Initialize entry sub module
    641           *
    642           * @param       state - device initialization state
    643           *
    644           * @return      none
    645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    646          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    647          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
    648            if (ZDSecMgrEntries == NULL)
   \   000007   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E8           MOV     A,R0
   \   000010   49           ORL     A,R1
   \   000011   6003         JZ      $+5
   \   000013   02....       LJMP    ??ZDSecMgrEntryInit_0 & 0xFFFF
    649            {
    650              uint16 index;
    651          
    652              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   7A0F         MOV     R2,#0xf
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00001D   8A..         MOV     ?V2,R2
   \   00001F   8B..         MOV     ?V3,R3
   \   000021   A8..         MOV     R0,?V2
   \   000023   A9..         MOV     R1,?V3
   \   000025   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000028   E8           MOV     A,R0
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   E9           MOV     A,R1
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   E8           MOV     A,R0
   \   00002E   49           ORL     A,R1
   \   00002F   6070         JZ      ??ZDSecMgrEntryInit_0
    653              {
    654                return;
    655              }
    656          
    657              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000031   7E00         MOV     R6,#0x0
   \   000033   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryInit_1:
   \   000035   C3           CLR     C
   \   000036   EE           MOV     A,R6
   \   000037   9403         SUBB    A,#0x3
   \   000039   EF           MOV     A,R7
   \   00003A   9400         SUBB    A,#0x0
   \   00003C   5063         JNC     ??ZDSecMgrEntryInit_0
    658              {
    659                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \   00003E   EE           MOV     A,R6
   \   00003F   F8           MOV     R0,A
   \   000040   EF           MOV     A,R7
   \   000041   F9           MOV     R1,A
   \   000042   E8           MOV     A,R0
   \   000043   75F005       MOV     B,#0x5
   \   000046   A4           MUL     AB
   \   000047   C8           XCH     A,R0
   \   000048   AAF0         MOV     R2,B
   \   00004A   75F000       MOV     B,#0x0
   \   00004D   A4           MUL     AB
   \   00004E   2A           ADD     A,R2
   \   00004F   FA           MOV     R2,A
   \   000050   75F005       MOV     B,#0x5
   \   000053   E9           MOV     A,R1
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   F9           MOV     R1,A
   \   000057   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   28           ADD     A,R0
   \   00005C   FA           MOV     R2,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   39           ADDC    A,R1
   \   000060   8A82         MOV     DPL,R2
   \   000062   F583         MOV     DPH,A
   \   000064   74FE         MOV     A,#-0x2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   F0           MOVX    @DPTR,A
    660                
    661                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
   \   00006B   EE           MOV     A,R6
   \   00006C   F8           MOV     R0,A
   \   00006D   EF           MOV     A,R7
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   75F005       MOV     B,#0x5
   \   000073   A4           MUL     AB
   \   000074   C8           XCH     A,R0
   \   000075   AAF0         MOV     R2,B
   \   000077   75F000       MOV     B,#0x0
   \   00007A   A4           MUL     AB
   \   00007B   2A           ADD     A,R2
   \   00007C   FA           MOV     R2,A
   \   00007D   75F005       MOV     B,#0x5
   \   000080   E9           MOV     A,R1
   \   000081   A4           MUL     AB
   \   000082   2A           ADD     A,R2
   \   000083   F9           MOV     R1,A
   \   000084   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000087   E0           MOVX    A,@DPTR
   \   000088   28           ADD     A,R0
   \   000089   FA           MOV     R2,A
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   39           ADDC    A,R1
   \   00008D   8A82         MOV     DPL,R2
   \   00008F   F583         MOV     DPH,A
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   7400         MOV     A,#0x0
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   7400         MOV     A,#0x0
   \   000099   F0           MOVX    @DPTR,A
    662              }
   \   00009A   0E           INC     R6
   \   00009B   EE           MOV     A,R6
   \   00009C   7097         JNZ     ??ZDSecMgrEntryInit_1
   \   00009E   0F           INC     R7
   \   00009F   8094         SJMP    ??ZDSecMgrEntryInit_1
    663            }
    664          
    665          #if defined NV_RESTORE
    666            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    667            {
    668              ZDSecMgrRestoreFromNV();
    669            }
    670          #else
    671            (void)state;
    672          #endif
    673          }
   \                     ??ZDSecMgrEntryInit_0:
   \   0000A1   7F04         MOV     R7,#0x4
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
    674          
    675          /******************************************************************************
    676           * @fn          ZDSecMgrEntryLookup
    677           *
    678           * @brief       Lookup entry index using specified NWK address.
    679           *
    680           * @param       nwkAddr - [in] NWK address
    681           * @param       entry   - [out] valid entry
    682           *
    683           * @return      ZStatus_t
    684           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    685          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    686          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
    687            ZStatus_t      status;
    688            uint16         index;
    689            AddrMgrEntry_t addrMgrEntry;
    690          
    691          
    692            // initialize results
    693            *entry = NULL;
   \   000012   85..82       MOV     DPL,?V0
   \   000015   85..83       MOV     DPH,?V1
   \   000018   7400         MOV     A,#0x0
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7400         MOV     A,#0x0
   \   00001E   F0           MOVX    @DPTR,A
    694            status = ZNwkUnknownDevice;
   \   00001F   75..C8       MOV     ?V4,#-0x38
    695          
    696            // verify data is available
    697            if ( ZDSecMgrEntries != NULL )
   \   000022   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F8           MOV     R0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   E8           MOV     A,R0
   \   00002B   49           ORL     A,R1
   \   00002C   7003         JNZ     $+5
   \   00002E   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    698            {
    699              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   7402         MOV     A,#0x2
   \   000039   F0           MOVX    @DPTR,A
    700              addrMgrEntry.nwkAddr = nwkAddr;
   \   00003A   7401         MOV     A,#0x1
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E5..         MOV     A,?V2
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   E5..         MOV     A,?V3
   \   000045   F0           MOVX    @DPTR,A
    701          
    702              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \   000046                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000046   AA..         MOV     R2,?XSP + 0
   \   000048   AB..         MOV     R3,?XSP + 1
   \   00004A   12....       LCALL   ??AddrMgrEntryLookupNwk?relay; Banked call to: AddrMgrEntryLookupNwk
   \   00004D   E9           MOV     A,R1
   \   00004E   6401         XRL     A,#0x1
   \   000050   6003         JZ      $+5
   \   000052   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    703              {
    704                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000055   7E00         MOV     R6,#0x0
   \   000057   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryLookup_1:
   \   000059   C3           CLR     C
   \   00005A   EE           MOV     A,R6
   \   00005B   9403         SUBB    A,#0x3
   \   00005D   EF           MOV     A,R7
   \   00005E   9400         SUBB    A,#0x0
   \   000060   5075         JNC     ??ZDSecMgrEntryLookup_0
    705                {
    706                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \   000062   740B         MOV     A,#0xb
   \   000064   12....       LCALL   ?XSTACK_DISP0_8
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FA           MOV     R2,A
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   FB           MOV     R3,A
   \   00006C   EE           MOV     A,R6
   \   00006D   F8           MOV     R0,A
   \   00006E   EF           MOV     A,R7
   \   00006F   F9           MOV     R1,A
   \   000070   E8           MOV     A,R0
   \   000071   75F005       MOV     B,#0x5
   \   000074   A4           MUL     AB
   \   000075   C8           XCH     A,R0
   \   000076   ACF0         MOV     R4,B
   \   000078   75F000       MOV     B,#0x0
   \   00007B   A4           MUL     AB
   \   00007C   2C           ADD     A,R4
   \   00007D   FC           MOV     R4,A
   \   00007E   75F005       MOV     B,#0x5
   \   000081   E9           MOV     A,R1
   \   000082   A4           MUL     AB
   \   000083   2C           ADD     A,R4
   \   000084   F9           MOV     R1,A
   \   000085   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000088   E0           MOVX    A,@DPTR
   \   000089   28           ADD     A,R0
   \   00008A   FC           MOV     R4,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   39           ADDC    A,R1
   \   00008E   8C82         MOV     DPL,R4
   \   000090   F583         MOV     DPH,A
   \   000092   E0           MOVX    A,@DPTR
   \   000093   6A           XRL     A,R2
   \   000094   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookup_2:
   \   000099   7035         JNZ     ??ZDSecMgrEntryLookup_3
    707                  {
    708                    // return successful results
    709                    *entry = &ZDSecMgrEntries[index];
   \   00009B   EE           MOV     A,R6
   \   00009C   F8           MOV     R0,A
   \   00009D   EF           MOV     A,R7
   \   00009E   F9           MOV     R1,A
   \   00009F   E8           MOV     A,R0
   \   0000A0   75F005       MOV     B,#0x5
   \   0000A3   A4           MUL     AB
   \   0000A4   C8           XCH     A,R0
   \   0000A5   AAF0         MOV     R2,B
   \   0000A7   75F000       MOV     B,#0x0
   \   0000AA   A4           MUL     AB
   \   0000AB   2A           ADD     A,R2
   \   0000AC   FA           MOV     R2,A
   \   0000AD   75F005       MOV     B,#0x5
   \   0000B0   E9           MOV     A,R1
   \   0000B1   A4           MUL     AB
   \   0000B2   2A           ADD     A,R2
   \   0000B3   F9           MOV     R1,A
   \   0000B4   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   28           ADD     A,R0
   \   0000B9   F8           MOV     R0,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   39           ADDC    A,R1
   \   0000BD   F9           MOV     R1,A
   \   0000BE   85..82       MOV     DPL,?V0
   \   0000C1   85..83       MOV     DPH,?V1
   \   0000C4   E8           MOV     A,R0
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E9           MOV     A,R1
   \   0000C8   F0           MOVX    @DPTR,A
    710                    status = ZSuccess;
   \   0000C9   75..00       MOV     ?V4,#0x0
    711          
    712                    // break from loop
    713                    return status;
   \   0000CC   A9..         MOV     R1,?V4
   \   0000CE   8009         SJMP    ??ZDSecMgrEntryLookup_4
    714                  }
    715                }
   \                     ??ZDSecMgrEntryLookup_3:
   \   0000D0   0E           INC     R6
   \   0000D1   EE           MOV     A,R6
   \   0000D2   7085         JNZ     ??ZDSecMgrEntryLookup_1
   \   0000D4   0F           INC     R7
   \   0000D5   8082         SJMP    ??ZDSecMgrEntryLookup_1
    716              }
    717            }
    718          
    719            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   0000D7   A9..         MOV     R1,?V4
   \                     ??ZDSecMgrEntryLookup_4:
   \   0000D9   740D         MOV     A,#0xd
   \   0000DB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DE   7F05         MOV     R7,#0x5
   \   0000E0   02....       LJMP    ?BANKED_LEAVE_XDATA
    720          }
    721          
    722          /******************************************************************************
    723           * @fn          ZDSecMgrEntryLookupAMI
    724           *
    725           * @brief       Lookup entry using specified address index
    726           *
    727           * @param       ami   - [in] Address Manager index
    728           * @param       entry - [out] valid entry
    729           *
    730           * @return      ZStatus_t
    731           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    732          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    733          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
    734            ZStatus_t status;
    735            uint16    index;
    736          
    737          
    738            // initialize results
    739            *entry = NULL;
   \   00000D   85..82       MOV     DPL,?V0
   \   000010   85..83       MOV     DPH,?V1
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
    740            status = ZNwkUnknownDevice;
   \   00001A   79C8         MOV     R1,#-0x38
    741          
    742            // verify data is available
    743            if ( ZDSecMgrEntries != NULL )
   \   00001C   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FC           MOV     R4,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FD           MOV     R5,A
   \   000024   EC           MOV     A,R4
   \   000025   4D           ORL     A,R5
   \   000026   6075         JZ      ??ZDSecMgrEntryLookupAMI_0
    744            {
    745              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   00002C   C3           CLR     C
   \   00002D   EA           MOV     A,R2
   \   00002E   9403         SUBB    A,#0x3
   \   000030   EB           MOV     A,R3
   \   000031   9400         SUBB    A,#0x0
   \   000033   5068         JNC     ??ZDSecMgrEntryLookupAMI_0
    746              {
    747                if ( ZDSecMgrEntries[index].ami == ami )
   \   000035   EA           MOV     A,R2
   \   000036   FC           MOV     R4,A
   \   000037   EB           MOV     A,R3
   \   000038   FD           MOV     R5,A
   \   000039   EC           MOV     A,R4
   \   00003A   75F005       MOV     B,#0x5
   \   00003D   A4           MUL     AB
   \   00003E   CC           XCH     A,R4
   \   00003F   A8F0         MOV     R0,B
   \   000041   75F000       MOV     B,#0x0
   \   000044   A4           MUL     AB
   \   000045   28           ADD     A,R0
   \   000046   F8           MOV     R0,A
   \   000047   75F005       MOV     B,#0x5
   \   00004A   ED           MOV     A,R5
   \   00004B   A4           MUL     AB
   \   00004C   28           ADD     A,R0
   \   00004D   FD           MOV     R5,A
   \   00004E   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2C           ADD     A,R4
   \   000053   F8           MOV     R0,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   3D           ADDC    A,R5
   \   000057   8882         MOV     DPL,R0
   \   000059   F583         MOV     DPH,A
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   6E           XRL     A,R6
   \   00005D   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000062   7032         JNZ     ??ZDSecMgrEntryLookupAMI_3
    748                {
    749                  // return successful results
    750                  *entry = &ZDSecMgrEntries[index];
   \   000064   EA           MOV     A,R2
   \   000065   FC           MOV     R4,A
   \   000066   EB           MOV     A,R3
   \   000067   FD           MOV     R5,A
   \   000068   EC           MOV     A,R4
   \   000069   75F005       MOV     B,#0x5
   \   00006C   A4           MUL     AB
   \   00006D   CC           XCH     A,R4
   \   00006E   A8F0         MOV     R0,B
   \   000070   75F000       MOV     B,#0x0
   \   000073   A4           MUL     AB
   \   000074   28           ADD     A,R0
   \   000075   F8           MOV     R0,A
   \   000076   75F005       MOV     B,#0x5
   \   000079   ED           MOV     A,R5
   \   00007A   A4           MUL     AB
   \   00007B   28           ADD     A,R0
   \   00007C   FD           MOV     R5,A
   \   00007D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000080   E0           MOVX    A,@DPTR
   \   000081   2C           ADD     A,R4
   \   000082   FC           MOV     R4,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   3D           ADDC    A,R5
   \   000086   FD           MOV     R5,A
   \   000087   85..82       MOV     DPL,?V0
   \   00008A   85..83       MOV     DPH,?V1
   \   00008D   EC           MOV     A,R4
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   ED           MOV     A,R5
   \   000091   F0           MOVX    @DPTR,A
    751                  status = ZSuccess;
   \   000092   7900         MOV     R1,#0x0
    752          
    753                  // break from loop
    754                  return status;
   \   000094   8007         SJMP    ??ZDSecMgrEntryLookupAMI_0
    755                }
    756              }
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000096   0A           INC     R2
   \   000097   EA           MOV     A,R2
   \   000098   7092         JNZ     ??ZDSecMgrEntryLookupAMI_1
   \   00009A   0B           INC     R3
   \   00009B   808F         SJMP    ??ZDSecMgrEntryLookupAMI_1
    757            }
    758          
    759            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   00009D   7F02         MOV     R7,#0x2
   \   00009F   02....       LJMP    ?BANKED_LEAVE_XDATA
    760          }
    761          
    762          /******************************************************************************
    763           * @fn          ZDSecMgrEntryLookupExt
    764           *
    765           * @brief       Lookup entry index using specified EXT address.
    766           *
    767           * @param       extAddr - [in] EXT address
    768           * @param       entry   - [out] valid entry
    769           *
    770           * @return      ZStatus_t
    771           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    772          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    773          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    774            ZStatus_t status;
    775            uint16    ami;
    776          
    777          
    778            // initialize results
    779            *entry = NULL;
   \   000012   8E82         MOV     DPL,R6
   \   000014   8F83         MOV     DPH,R7
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
    780            status = ZNwkUnknownDevice;
   \   00001D   75..C8       MOV     ?V2,#-0x38
    781          
    782            // lookup address index
    783            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000020   AC..         MOV     R4,?XSP + 0
   \   000022   AD..         MOV     R5,?XSP + 1
   \   000024   AA..         MOV     R2,?V0
   \   000026   AB..         MOV     R3,?V1
   \   000028   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay; Banked call to: ZDSecMgrExtAddrLookup
   \   00002B   E9           MOV     A,R1
   \   00002C   7015         JNZ     ??ZDSecMgrEntryLookupExt_0
    784            {
    785              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   00002E                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002E   EE           MOV     A,R6
   \   00002F   FC           MOV     R4,A
   \   000030   EF           MOV     A,R7
   \   000031   FD           MOV     R5,A
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay; Banked call to: ZDSecMgrEntryLookupAMI
   \   000040   E9           MOV     A,R1
   \   000041   F5..         MOV     ?V2,A
    786            }
    787          
    788            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000043   A9..         MOV     R1,?V2
   \   000045   7402         MOV     A,#0x2
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   7F03         MOV     R7,#0x3
   \   00004C   02....       LJMP    ?BANKED_LEAVE_XDATA
    789          }
    790          
    791          /******************************************************************************
    792           * @fn          ZDSecMgrEntryLookupExtGetIndex
    793           *
    794           * @brief       Lookup entry index using specified EXT address.
    795           *
    796           * @param       extAddr - [in] EXT address
    797           * @param       entryIndex - [out] valid index to the entry table
    798           *
    799           * @return      ZStatus_t
    800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    801          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    802          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   8C..         MOV     ?V6,R4
   \   000010   8D..         MOV     ?V7,R5
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V4,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V5,A
    803            ZStatus_t status;
    804            uint16    ami;
    805            uint16    index;
    806          
    807            // initialize results
    808            status = ZNwkUnknownDevice;
   \   00001E   75..C8       MOV     ?V2,#-0x38
    809          
    810            // lookup address index
    811            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000021                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000021   AC..         MOV     R4,?XSP + 0
   \   000023   AD..         MOV     R5,?XSP + 1
   \   000025   AA..         MOV     R2,?V0
   \   000027   AB..         MOV     R3,?V1
   \   000029   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay; Banked call to: ZDSecMgrExtAddrLookup
   \   00002C   E9           MOV     A,R1
   \   00002D   6003         JZ      $+5
   \   00002F   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    812            {  
    813              // verify data is available
    814              if ( ZDSecMgrEntries != NULL )
   \   000032   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F8           MOV     R0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   E8           MOV     A,R0
   \   00003B   49           ORL     A,R1
   \   00003C   7003         JNZ     $+5
   \   00003E   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    815              {
    816                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000041   7E00         MOV     R6,#0x0
   \   000043   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000045   C3           CLR     C
   \   000046   EE           MOV     A,R6
   \   000047   9403         SUBB    A,#0x3
   \   000049   EF           MOV     A,R7
   \   00004A   9400         SUBB    A,#0x0
   \   00004C   4003         JC      $+5
   \   00004E   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    817                {
    818                  if ( ZDSecMgrEntries[index].ami == ami )
   \   000051   EE           MOV     A,R6
   \   000052   F8           MOV     R0,A
   \   000053   EF           MOV     A,R7
   \   000054   F9           MOV     R1,A
   \   000055   E8           MOV     A,R0
   \   000056   75F005       MOV     B,#0x5
   \   000059   A4           MUL     AB
   \   00005A   C8           XCH     A,R0
   \   00005B   AAF0         MOV     R2,B
   \   00005D   75F000       MOV     B,#0x0
   \   000060   A4           MUL     AB
   \   000061   2A           ADD     A,R2
   \   000062   FA           MOV     R2,A
   \   000063   75F005       MOV     B,#0x5
   \   000066   E9           MOV     A,R1
   \   000067   A4           MUL     AB
   \   000068   2A           ADD     A,R2
   \   000069   F9           MOV     R1,A
   \   00006A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   28           ADD     A,R0
   \   00006F   FA           MOV     R2,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   39           ADDC    A,R1
   \   000073   8A82         MOV     DPL,R2
   \   000075   F583         MOV     DPH,A
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F8           MOV     R0,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   F9           MOV     R1,A
   \   00007C   85..82       MOV     DPL,?XSP + 0
   \   00007F   85..83       MOV     DPH,?XSP + 1
   \   000082   E0           MOVX    A,@DPTR
   \   000083   68           XRL     A,R0
   \   000084   7003         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_2
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   69           XRL     A,R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   000089   7040         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_3
    819                  {
    820                    // return successful results
    821                    *entry = &ZDSecMgrEntries[index];
   \   00008B   EE           MOV     A,R6
   \   00008C   F8           MOV     R0,A
   \   00008D   EF           MOV     A,R7
   \   00008E   F9           MOV     R1,A
   \   00008F   E8           MOV     A,R0
   \   000090   75F005       MOV     B,#0x5
   \   000093   A4           MUL     AB
   \   000094   C8           XCH     A,R0
   \   000095   AAF0         MOV     R2,B
   \   000097   75F000       MOV     B,#0x0
   \   00009A   A4           MUL     AB
   \   00009B   2A           ADD     A,R2
   \   00009C   FA           MOV     R2,A
   \   00009D   75F005       MOV     B,#0x5
   \   0000A0   E9           MOV     A,R1
   \   0000A1   A4           MUL     AB
   \   0000A2   2A           ADD     A,R2
   \   0000A3   F9           MOV     R1,A
   \   0000A4   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   28           ADD     A,R0
   \   0000A9   F8           MOV     R0,A
   \   0000AA   A3           INC     DPTR
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   39           ADDC    A,R1
   \   0000AD   F9           MOV     R1,A
   \   0000AE   85..82       MOV     DPL,?V6
   \   0000B1   85..83       MOV     DPH,?V7
   \   0000B4   E8           MOV     A,R0
   \   0000B5   F0           MOVX    @DPTR,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E9           MOV     A,R1
   \   0000B8   F0           MOVX    @DPTR,A
    822                    *entryIndex = index;
   \   0000B9   85..82       MOV     DPL,?V4
   \   0000BC   85..83       MOV     DPH,?V5
   \   0000BF   EE           MOV     A,R6
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   EF           MOV     A,R7
   \   0000C3   F0           MOVX    @DPTR,A
    823                    status = ZSuccess;
   \   0000C4   75..00       MOV     ?V2,#0x0
    824                    
    825                    return status;
   \   0000C7   A9..         MOV     R1,?V2
   \   0000C9   800A         SJMP    ??ZDSecMgrEntryLookupExtGetIndex_4
    826                  }
    827                }
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   0000CB   0E           INC     R6
   \   0000CC   EE           MOV     A,R6
   \   0000CD   7001         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_5
   \   0000CF   0F           INC     R7
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   0000D0   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_1 & 0xFFFF
    828              }
    829            }
    830          
    831            return status;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   0000D3   A9..         MOV     R1,?V2
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DA   7F08         MOV     R7,#0x8
   \   0000DC   02....       LJMP    ?BANKED_LEAVE_XDATA
    832          }
    833          
    834          /******************************************************************************
    835           * @fn          ZDSecMgrEntryFree
    836           *
    837           * @brief       Free entry.
    838           *
    839           * @param       entry - [in] valid entry
    840           *
    841           * @return      ZStatus_t
    842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    843          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    844          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    845            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
   \   000009   75..00       MOV     ?V0,#0x0
   \   00000C   75..00       MOV     ?V1,#0x0
    846            
    847            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A18         MOV     R2,#0x18
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000016   8A..         MOV     ?V2,R2
   \   000018   8B..         MOV     ?V3,R3
   \   00001A   85....       MOV     ?V0,?V2
   \   00001D   85....       MOV     ?V1,?V3
    848          
    849            if (pApsLinkKey != NULL)
   \   000020   E5..         MOV     A,?V0
   \   000022   45..         ORL     A,?V1
   \   000024   6049         JZ      ??ZDSecMgrEntryFree_0
    850            {
    851              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000026                ; Setup parameters for call to function osal_memset
   \   000026   7C18         MOV     R4,#0x18
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   7900         MOV     R1,#0x0
   \   00002C   AA..         MOV     R2,?V0
   \   00002E   AB..         MOV     R3,?V1
   \   000030   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    852          
    853              // Clear the APS Link key in NV
    854              osal_nv_write( entry->keyNvId, 0,
    855                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   000033                ; Setup parameters for call to function osal_nv_write
   \   000033   78..         MOV     R0,#?V0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   75..18       MOV     ?V2,#0x18
   \   00003B   75..00       MOV     ?V3,#0x0
   \   00003E   78..         MOV     R0,#?V2
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   7C00         MOV     R4,#0x0
   \   000045   7D00         MOV     R5,#0x0
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   FA           MOV     R2,A
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   E9           MOV     A,R1
    856          
    857              // set entry to invalid Key
    858              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   7400         MOV     A,#0x0
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   7400         MOV     A,#0x0
   \   000067   F0           MOVX    @DPTR,A
    859              
    860              osal_mem_free(pApsLinkKey);
   \   000068                ; Setup parameters for call to function osal_mem_free
   \   000068   AA..         MOV     R2,?V0
   \   00006A   AB..         MOV     R3,?V1
   \   00006C   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
    861            }
    862          
    863            // marking the entry as INVALID_NODE_ADDR
    864            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   00006F   8E82         MOV     DPL,R6
   \   000071   8F83         MOV     DPH,R7
   \   000073   74FE         MOV     A,#-0x2
   \   000075   F0           MOVX    @DPTR,A
   \   000076   A3           INC     DPTR
   \   000077   74FF         MOV     A,#-0x1
   \   000079   F0           MOVX    @DPTR,A
    865          }
   \   00007A   7F04         MOV     R7,#0x4
   \   00007C   02....       LJMP    ?BANKED_LEAVE_XDATA
    866          
    867          /******************************************************************************
    868           * @fn          ZDSecMgrEntryNew
    869           *
    870           * @brief       Get a new entry.
    871           *
    872           * @param       entry - [out] valid entry
    873           *
    874           * @return      ZStatus_t
    875           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    876          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    877          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    878            ZStatus_t status;
    879            uint16    index;
    880          
    881          
    882            // initialize results
    883            *entry = NULL;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    884            status = ZNwkUnknownDevice;
   \   000014   79C8         MOV     R1,#-0x38
    885          
    886            // verify data is available
    887            if ( ZDSecMgrEntries != NULL )
   \   000016   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FC           MOV     R4,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FD           MOV     R5,A
   \   00001E   EC           MOV     A,R4
   \   00001F   4D           ORL     A,R5
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    888            {
    889              // find available entry
    890              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryNew_1:
   \   000029   C3           CLR     C
   \   00002A   EA           MOV     A,R2
   \   00002B   9403         SUBB    A,#0x3
   \   00002D   EB           MOV     A,R3
   \   00002E   9400         SUBB    A,#0x0
   \   000030   4003         JC      $+5
   \   000032   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    891              {
    892                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \   000035   EA           MOV     A,R2
   \   000036   FC           MOV     R4,A
   \   000037   EB           MOV     A,R3
   \   000038   FD           MOV     R5,A
   \   000039   EC           MOV     A,R4
   \   00003A   75F005       MOV     B,#0x5
   \   00003D   A4           MUL     AB
   \   00003E   CC           XCH     A,R4
   \   00003F   A8F0         MOV     R0,B
   \   000041   75F000       MOV     B,#0x0
   \   000044   A4           MUL     AB
   \   000045   28           ADD     A,R0
   \   000046   F8           MOV     R0,A
   \   000047   75F005       MOV     B,#0x5
   \   00004A   ED           MOV     A,R5
   \   00004B   A4           MUL     AB
   \   00004C   28           ADD     A,R0
   \   00004D   FD           MOV     R5,A
   \   00004E   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2C           ADD     A,R4
   \   000053   F8           MOV     R0,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   3D           ADDC    A,R5
   \   000057   8882         MOV     DPL,R0
   \   000059   F583         MOV     DPH,A
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   64FE         XRL     A,#0xfe
   \   00005E   7004         JNZ     ??ZDSecMgrEntryNew_2
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrEntryNew_2:
   \   000064   705F         JNZ     ??ZDSecMgrEntryNew_3
    893                {
    894                  // return successful result
    895                  *entry = &ZDSecMgrEntries[index];
   \   000066   EA           MOV     A,R2
   \   000067   FC           MOV     R4,A
   \   000068   EB           MOV     A,R3
   \   000069   FD           MOV     R5,A
   \   00006A   EC           MOV     A,R4
   \   00006B   75F005       MOV     B,#0x5
   \   00006E   A4           MUL     AB
   \   00006F   CC           XCH     A,R4
   \   000070   A8F0         MOV     R0,B
   \   000072   75F000       MOV     B,#0x0
   \   000075   A4           MUL     AB
   \   000076   28           ADD     A,R0
   \   000077   F8           MOV     R0,A
   \   000078   75F005       MOV     B,#0x5
   \   00007B   ED           MOV     A,R5
   \   00007C   A4           MUL     AB
   \   00007D   28           ADD     A,R0
   \   00007E   FD           MOV     R5,A
   \   00007F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2C           ADD     A,R4
   \   000084   FC           MOV     R4,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   3D           ADDC    A,R5
   \   000088   FD           MOV     R5,A
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   EC           MOV     A,R4
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   ED           MOV     A,R5
   \   000091   F0           MOVX    @DPTR,A
    896                  status = ZSuccess;
   \   000092   7900         MOV     R1,#0x0
    897          
    898                  // Set the authentication option to default
    899                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000094   EA           MOV     A,R2
   \   000095   FC           MOV     R4,A
   \   000096   EB           MOV     A,R3
   \   000097   FD           MOV     R5,A
   \   000098   EC           MOV     A,R4
   \   000099   75F005       MOV     B,#0x5
   \   00009C   A4           MUL     AB
   \   00009D   CC           XCH     A,R4
   \   00009E   A8F0         MOV     R0,B
   \   0000A0   75F000       MOV     B,#0x0
   \   0000A3   A4           MUL     AB
   \   0000A4   28           ADD     A,R0
   \   0000A5   F8           MOV     R0,A
   \   0000A6   75F005       MOV     B,#0x5
   \   0000A9   ED           MOV     A,R5
   \   0000AA   A4           MUL     AB
   \   0000AB   28           ADD     A,R0
   \   0000AC   FD           MOV     R5,A
   \   0000AD   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   2C           ADD     A,R4
   \   0000B2   F8           MOV     R0,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   3D           ADDC    A,R5
   \   0000B6   8882         MOV     DPL,R0
   \   0000B8   F583         MOV     DPH,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   7400         MOV     A,#0x0
   \   0000C0   F0           MOVX    @DPTR,A
    900          
    901                  // break from loop
    902                  index = ZDSECMGR_ENTRY_MAX;
   \   0000C1   7A03         MOV     R2,#0x3
   \   0000C3   7B00         MOV     R3,#0x0
    903                }
    904              }
   \                     ??ZDSecMgrEntryNew_3:
   \   0000C5   0A           INC     R2
   \   0000C6   EA           MOV     A,R2
   \   0000C7   7001         JNZ     ??ZDSecMgrEntryNew_4
   \   0000C9   0B           INC     R3
   \                     ??ZDSecMgrEntryNew_4:
   \   0000CA   02....       LJMP    ??ZDSecMgrEntryNew_1 & 0xFFFF
    905            }
    906          
    907            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   0000CD   7F01         MOV     R7,#0x1
   \   0000CF   02....       LJMP    ?BANKED_LEAVE_XDATA
    908          }
    909          
    910          /******************************************************************************
    911           * @fn          ZDSecMgrCtrlInit
    912           *
    913           * @brief       Initialize control sub module
    914           *
    915           * @param       none
    916           *
    917           * @return      none
    918           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    919          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    920          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    921            uint16 size;
    922            uint16 index;
    923          
    924            // allocate entry data
    925            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
   \   000005   7E15         MOV     R6,#0x15
   \   000007   7F00         MOV     R7,#0x0
    926          
    927            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000010   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000013   EA           MOV     A,R2
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EB           MOV     A,R3
   \   000017   F0           MOVX    @DPTR,A
    928          
    929            // initialize data
    930            if ( ZDSecMgrCtrlData != NULL )
   \   000018   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F8           MOV     R0,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F9           MOV     R1,A
   \   000020   E8           MOV     A,R0
   \   000021   49           ORL     A,R1
   \   000022   6049         JZ      ??ZDSecMgrCtrlInit_0
    931            {
    932              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000024   75..00       MOV     ?V0,#0x0
   \   000027   75..00       MOV     ?V1,#0x0
   \                     ??ZDSecMgrCtrlInit_1:
   \   00002A   C3           CLR     C
   \   00002B   E5..         MOV     A,?V0
   \   00002D   9403         SUBB    A,#0x3
   \   00002F   E5..         MOV     A,?V1
   \   000031   9400         SUBB    A,#0x0
   \   000033   5038         JNC     ??ZDSecMgrCtrlInit_0
    933              {
    934                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \   000035   A8..         MOV     R0,?V0
   \   000037   A9..         MOV     R1,?V1
   \   000039   E8           MOV     A,R0
   \   00003A   75F007       MOV     B,#0x7
   \   00003D   A4           MUL     AB
   \   00003E   C8           XCH     A,R0
   \   00003F   AAF0         MOV     R2,B
   \   000041   75F000       MOV     B,#0x0
   \   000044   A4           MUL     AB
   \   000045   2A           ADD     A,R2
   \   000046   FA           MOV     R2,A
   \   000047   75F007       MOV     B,#0x7
   \   00004A   E9           MOV     A,R1
   \   00004B   A4           MUL     AB
   \   00004C   2A           ADD     A,R2
   \   00004D   F9           MOV     R1,A
   \   00004E   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000051   E0           MOVX    A,@DPTR
   \   000052   28           ADD     A,R0
   \   000053   FA           MOV     R2,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   39           ADDC    A,R1
   \   000057   8A82         MOV     DPL,R2
   \   000059   F583         MOV     DPH,A
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   7400         MOV     A,#0x0
   \   000062   F0           MOVX    @DPTR,A
    935              }
   \   000063   05..         INC     ?V0
   \   000065   E5..         MOV     A,?V0
   \   000067   70C1         JNZ     ??ZDSecMgrCtrlInit_1
   \   000069   05..         INC     ?V1
   \   00006B   80BD         SJMP    ??ZDSecMgrCtrlInit_1
    936            }
    937          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   00006D   7F02         MOV     R7,#0x2
   \   00006F   02....       LJMP    ?BANKED_LEAVE_XDATA
    938          
    939          /******************************************************************************
    940           * @fn          ZDSecMgrCtrlRelease
    941           *
    942           * @brief       Release control data.
    943           *
    944           * @param       ctrl - [in] valid control data
    945           *
    946           * @return      none
    947           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    948          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    949          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    950            // should always be enough entry control data
    951            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
    952          }
   \   000010   D083         POP     DPH
   \   000012   D082         POP     DPL
   \   000014   02....       LJMP    ?BRET
    953          
    954          /******************************************************************************
    955           * @fn          ZDSecMgrCtrlLookup
    956           *
    957           * @brief       Lookup control data.
    958           *
    959           * @param       entry - [in] valid entry data
    960           * @param       ctrl  - [out] control data - NULL if not found
    961           *
    962           * @return      none
    963           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    964          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    965          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    966            uint16 index;
    967          
    968          
    969            // initialize search results
    970            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    971          
    972            // verify data is available
    973            if ( ZDSecMgrCtrlData != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FB           MOV     R3,A
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrCtrlLookup_0 & 0xFFFF
    974            {
    975              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000023   7800         MOV     R0,#0x0
   \   000025   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrCtrlLookup_1:
   \   000027   C3           CLR     C
   \   000028   E8           MOV     A,R0
   \   000029   9403         SUBB    A,#0x3
   \   00002B   E9           MOV     A,R1
   \   00002C   9400         SUBB    A,#0x0
   \   00002E   4003         JC      $+5
   \   000030   02....       LJMP    ??ZDSecMgrCtrlLookup_0 & 0xFFFF
    976              {
    977                // make sure control data is in use
    978                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \   000033   E8           MOV     A,R0
   \   000034   FA           MOV     R2,A
   \   000035   E9           MOV     A,R1
   \   000036   FB           MOV     R3,A
   \   000037   EA           MOV     A,R2
   \   000038   75F007       MOV     B,#0x7
   \   00003B   A4           MUL     AB
   \   00003C   CA           XCH     A,R2
   \   00003D   85F0..       MOV     ?V0,B
   \   000040   75F000       MOV     B,#0x0
   \   000043   A4           MUL     AB
   \   000044   25..         ADD     A,?V0
   \   000046   F5..         MOV     ?V0,A
   \   000048   75F007       MOV     B,#0x7
   \   00004B   EB           MOV     A,R3
   \   00004C   A4           MUL     AB
   \   00004D   25..         ADD     A,?V0
   \   00004F   FB           MOV     R3,A
   \   000050   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000053   E0           MOVX    A,@DPTR
   \   000054   2A           ADD     A,R2
   \   000055   F5..         MOV     ?V0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   3B           ADDC    A,R3
   \   00005A   85..82       MOV     DPL,?V0
   \   00005D   F583         MOV     DPH,A
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   606D         JZ      ??ZDSecMgrCtrlLookup_2
    979                {
    980                  // check for entry match
    981                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000067   E8           MOV     A,R0
   \   000068   FA           MOV     R2,A
   \   000069   E9           MOV     A,R1
   \   00006A   FB           MOV     R3,A
   \   00006B   EA           MOV     A,R2
   \   00006C   75F007       MOV     B,#0x7
   \   00006F   A4           MUL     AB
   \   000070   CA           XCH     A,R2
   \   000071   85F0..       MOV     ?V0,B
   \   000074   75F000       MOV     B,#0x0
   \   000077   A4           MUL     AB
   \   000078   25..         ADD     A,?V0
   \   00007A   F5..         MOV     ?V0,A
   \   00007C   75F007       MOV     B,#0x7
   \   00007F   EB           MOV     A,R3
   \   000080   A4           MUL     AB
   \   000081   25..         ADD     A,?V0
   \   000083   FB           MOV     R3,A
   \   000084   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000087   E0           MOVX    A,@DPTR
   \   000088   2A           ADD     A,R2
   \   000089   F5..         MOV     ?V0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   3B           ADDC    A,R3
   \   00008E   85..82       MOV     DPL,?V0
   \   000091   F583         MOV     DPH,A
   \   000093   E0           MOVX    A,@DPTR
   \   000094   FA           MOV     R2,A
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   FB           MOV     R3,A
   \   000098   EE           MOV     A,R6
   \   000099   6A           XRL     A,R2
   \   00009A   7002         JNZ     ??ZDSecMgrCtrlLookup_3
   \   00009C   EF           MOV     A,R7
   \   00009D   6B           XRL     A,R3
   \                     ??ZDSecMgrCtrlLookup_3:
   \   00009E   7034         JNZ     ??ZDSecMgrCtrlLookup_2
    982                  {
    983                    // return this control data
    984                    *ctrl = &ZDSecMgrCtrlData[index];
   \   0000A0   E8           MOV     A,R0
   \   0000A1   FA           MOV     R2,A
   \   0000A2   E9           MOV     A,R1
   \   0000A3   FB           MOV     R3,A
   \   0000A4   EA           MOV     A,R2
   \   0000A5   75F007       MOV     B,#0x7
   \   0000A8   A4           MUL     AB
   \   0000A9   CA           XCH     A,R2
   \   0000AA   85F0..       MOV     ?V0,B
   \   0000AD   75F000       MOV     B,#0x0
   \   0000B0   A4           MUL     AB
   \   0000B1   25..         ADD     A,?V0
   \   0000B3   F5..         MOV     ?V0,A
   \   0000B5   75F007       MOV     B,#0x7
   \   0000B8   EB           MOV     A,R3
   \   0000B9   A4           MUL     AB
   \   0000BA   25..         ADD     A,?V0
   \   0000BC   FB           MOV     R3,A
   \   0000BD   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   2A           ADD     A,R2
   \   0000C2   FA           MOV     R2,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   3B           ADDC    A,R3
   \   0000C6   FB           MOV     R3,A
   \   0000C7   8C82         MOV     DPL,R4
   \   0000C9   8D83         MOV     DPH,R5
   \   0000CB   EA           MOV     A,R2
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   EB           MOV     A,R3
   \   0000CF   F0           MOVX    @DPTR,A
    985          
    986                    // break from loop
    987                    index = ZDSECMGR_CTRL_MAX;
   \   0000D0   7803         MOV     R0,#0x3
   \   0000D2   7900         MOV     R1,#0x0
    988                  }
    989                }
    990              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   0000D4   08           INC     R0
   \   0000D5   E8           MOV     A,R0
   \   0000D6   7001         JNZ     ??ZDSecMgrCtrlLookup_4
   \   0000D8   09           INC     R1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   0000D9   02....       LJMP    ??ZDSecMgrCtrlLookup_1 & 0xFFFF
    991            }
    992          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   0000DC   7F01         MOV     R7,#0x1
   \   0000DE   02....       LJMP    ?BANKED_LEAVE_XDATA
    993          
    994          /******************************************************************************
    995           * @fn          ZDSecMgrCtrlSet
    996           *
    997           * @brief       Set control data.
    998           *
    999           * @param       device - [in] valid device data
   1000           * @param       entry  - [in] valid entry data
   1001           * @param       ctrl   - [in] valid control data
   1002           *
   1003           * @return      none
   1004           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1005          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1006                                ZDSecMgrEntry_t*  entry,
   1007                                ZDSecMgrCtrl_t*   ctrl )
   1008          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   1009            // set control date
   1010            ctrl->parentAddr = device->parentAddr;
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   1011            ctrl->secure     = device->secure;
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   C0E0         PUSH    A
   \   000034   8882         MOV     DPL,R0
   \   000036   8983         MOV     DPH,R1
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   D0E0         POP     A
   \   00003E   F0           MOVX    @DPTR,A
   1012            ctrl->entry      = entry;
   \   00003F   8882         MOV     DPL,R0
   \   000041   8983         MOV     DPH,R1
   \   000043   EC           MOV     A,R4
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   ED           MOV     A,R5
   \   000047   F0           MOVX    @DPTR,A
   1013            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   000048   8882         MOV     DPL,R0
   \   00004A   8983         MOV     DPH,R1
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   7401         MOV     A,#0x1
   \   000053   F0           MOVX    @DPTR,A
   1014            ctrl->cntr       = 0;
   \   000054   8882         MOV     DPL,R0
   \   000056   8983         MOV     DPH,R1
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   7400         MOV     A,#0x0
   \   000060   F0           MOVX    @DPTR,A
   1015          
   1016            // set device pointer
   1017            device->ctrl = ctrl;
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E8           MOV     A,R0
   \   00006E   F0           MOVX    @DPTR,A
   \   00006F   A3           INC     DPTR
   \   000070   E9           MOV     A,R1
   \   000071   F0           MOVX    @DPTR,A
   1018          }
   \   000072   7F01         MOV     R7,#0x1
   \   000074   02....       LJMP    ?BANKED_LEAVE_XDATA
   1019          
   1020          /******************************************************************************
   1021           * @fn          ZDSecMgrCtrlAdd
   1022           *
   1023           * @brief       Add control data.
   1024           *
   1025           * @param       device - [in] valid device data
   1026           * @param       entry  - [in] valid entry data
   1027           *
   1028           * @return      ZStatus_t
   1029           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1030          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1031          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   8C..         MOV     ?V6,R4
   \   00000B   8D..         MOV     ?V7,R5
   1032            ZStatus_t status;
   1033            uint16    index;
   1034          
   1035          
   1036            // initialize results
   1037            status = ZNwkUnknownDevice;
   \   00000D   75..C8       MOV     ?V2,#-0x38
   1038          
   1039            // verify data is available
   1040            if ( ZDSecMgrCtrlData != NULL )
   \   000010   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??ZDSecMgrCtrlAdd_0 & 0xFFFF
   1041            {
   1042              // look for an empty slot
   1043              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000023   C3           CLR     C
   \   000024   EE           MOV     A,R6
   \   000025   9403         SUBB    A,#0x3
   \   000027   EF           MOV     A,R7
   \   000028   9400         SUBB    A,#0x0
   \   00002A   5076         JNC     ??ZDSecMgrCtrlAdd_0
   1044              {
   1045                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \   00002C   EE           MOV     A,R6
   \   00002D   F8           MOV     R0,A
   \   00002E   EF           MOV     A,R7
   \   00002F   F9           MOV     R1,A
   \   000030   E8           MOV     A,R0
   \   000031   75F007       MOV     B,#0x7
   \   000034   A4           MUL     AB
   \   000035   C8           XCH     A,R0
   \   000036   AAF0         MOV     R2,B
   \   000038   75F000       MOV     B,#0x0
   \   00003B   A4           MUL     AB
   \   00003C   2A           ADD     A,R2
   \   00003D   FA           MOV     R2,A
   \   00003E   75F007       MOV     B,#0x7
   \   000041   E9           MOV     A,R1
   \   000042   A4           MUL     AB
   \   000043   2A           ADD     A,R2
   \   000044   F9           MOV     R1,A
   \   000045   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000048   E0           MOVX    A,@DPTR
   \   000049   28           ADD     A,R0
   \   00004A   FA           MOV     R2,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   39           ADDC    A,R1
   \   00004E   8A82         MOV     DPL,R2
   \   000050   F583         MOV     DPH,A
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   7041         JNZ     ??ZDSecMgrCtrlAdd_2
   1046                {
   1047                  // return successful results
   1048                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   00005A                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00005A   EE           MOV     A,R6
   \   00005B   F8           MOV     R0,A
   \   00005C   EF           MOV     A,R7
   \   00005D   F9           MOV     R1,A
   \   00005E   E8           MOV     A,R0
   \   00005F   75F007       MOV     B,#0x7
   \   000062   A4           MUL     AB
   \   000063   C8           XCH     A,R0
   \   000064   AAF0         MOV     R2,B
   \   000066   75F000       MOV     B,#0x0
   \   000069   A4           MUL     AB
   \   00006A   2A           ADD     A,R2
   \   00006B   FA           MOV     R2,A
   \   00006C   75F007       MOV     B,#0x7
   \   00006F   E9           MOV     A,R1
   \   000070   A4           MUL     AB
   \   000071   2A           ADD     A,R2
   \   000072   F9           MOV     R1,A
   \   000073   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000076   E0           MOVX    A,@DPTR
   \   000077   28           ADD     A,R0
   \   000078   F5..         MOV     ?V4,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   39           ADDC    A,R1
   \   00007D   F5..         MOV     ?V5,A
   \   00007F   78..         MOV     R0,#?V4
   \   000081   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000084   AC..         MOV     R4,?V6
   \   000086   AD..         MOV     R5,?V7
   \   000088   AA..         MOV     R2,?V0
   \   00008A   AB..         MOV     R3,?V1
   \   00008C   12....       LCALL   ??ZDSecMgrCtrlSet?relay; Banked call to: ZDSecMgrCtrlSet
   \   00008F   7402         MOV     A,#0x2
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
   1049          
   1050                  status = ZSuccess;
   \   000094   75..00       MOV     ?V2,#0x0
   1051          
   1052                  // break from loop
   1053                  index = ZDSECMGR_CTRL_MAX;
   \   000097   7E03         MOV     R6,#0x3
   \   000099   7F00         MOV     R7,#0x0
   1054                }
   1055              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   00009B   0E           INC     R6
   \   00009C   EE           MOV     A,R6
   \   00009D   7084         JNZ     ??ZDSecMgrCtrlAdd_1
   \   00009F   0F           INC     R7
   \   0000A0   8081         SJMP    ??ZDSecMgrCtrlAdd_1
   1056            }
   1057          
   1058            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   0000A2   A9..         MOV     R1,?V2
   \   0000A4   7F08         MOV     R7,#0x8
   \   0000A6   02....       LJMP    ?BANKED_LEAVE_XDATA
   1059          }
   1060          
   1061          /******************************************************************************
   1062           * @fn          ZDSecMgrCtrlTerm
   1063           *
   1064           * @brief       Terminate device control.
   1065           *
   1066           * @param       entry - [in] valid entry data
   1067           *
   1068           * @return      none
   1069           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1070          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1071          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1072            ZDSecMgrCtrl_t* ctrl;
   1073          
   1074            // remove device from control data
   1075            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   00000E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   FA           MOV     R2,A
   \   000014   EF           MOV     A,R7
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   ??ZDSecMgrCtrlLookup?relay; Banked call to: ZDSecMgrCtrlLookup
   1076          
   1077            if ( ctrl != NULL )
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F8           MOV     R0,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F9           MOV     R1,A
   \   000024   E8           MOV     A,R0
   \   000025   49           ORL     A,R1
   \   000026   600E         JZ      ??ZDSecMgrCtrlTerm_0
   1078            {
   1079              ZDSecMgrCtrlRelease ( ctrl );
   \   000028                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   FA           MOV     R2,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FB           MOV     R3,A
   \   000033   12....       LCALL   ??ZDSecMgrCtrlRelease?relay; Banked call to: ZDSecMgrCtrlRelease
   1080            }
   1081          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003B   7F01         MOV     R7,#0x1
   \   00003D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1082          
   1083          /******************************************************************************
   1084           * @fn          ZDSecMgrCtrlReset
   1085           *
   1086           * @brief       Reset control data.
   1087           *
   1088           * @param       device - [in] valid device data
   1089           * @param       entry  - [in] valid entry data
   1090           *
   1091           * @return      ZStatus_t
   1092           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1093          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1094          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1095            ZStatus_t       status;
   1096            ZDSecMgrCtrl_t* ctrl;
   1097          
   1098          
   1099            // initialize results
   1100            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V2,#-0x38
   1101          
   1102            // look for a match for the entry
   1103            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000015                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000015   AC..         MOV     R4,?XSP + 0
   \   000017   AD..         MOV     R5,?XSP + 1
   \   000019   EE           MOV     A,R6
   \   00001A   FA           MOV     R2,A
   \   00001B   EF           MOV     A,R7
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   ??ZDSecMgrCtrlLookup?relay; Banked call to: ZDSecMgrCtrlLookup
   1104          
   1105            if ( ctrl != NULL )
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F8           MOV     R0,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   E8           MOV     A,R0
   \   00002C   49           ORL     A,R1
   \   00002D   601E         JZ      ??ZDSecMgrCtrlReset_0
   1106            {
   1107              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   00002F                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000038   EE           MOV     A,R6
   \   000039   FC           MOV     R4,A
   \   00003A   EF           MOV     A,R7
   \   00003B   FD           MOV     R5,A
   \   00003C   AA..         MOV     R2,?V0
   \   00003E   AB..         MOV     R3,?V1
   \   000040   12....       LCALL   ??ZDSecMgrCtrlSet?relay; Banked call to: ZDSecMgrCtrlSet
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   1108          
   1109              status = ZSuccess;
   \   000048   75..00       MOV     ?V2,#0x0
   \   00004B   800E         SJMP    ??ZDSecMgrCtrlReset_1
   1110            }
   1111            else
   1112            {
   1113              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00004D                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00004D   EE           MOV     A,R6
   \   00004E   FC           MOV     R4,A
   \   00004F   EF           MOV     A,R7
   \   000050   FD           MOV     R5,A
   \   000051   AA..         MOV     R2,?V0
   \   000053   AB..         MOV     R3,?V1
   \   000055   12....       LCALL   ??ZDSecMgrCtrlAdd?relay; Banked call to: ZDSecMgrCtrlAdd
   \   000058   E9           MOV     A,R1
   \   000059   F5..         MOV     ?V2,A
   1114            }
   1115          
   1116            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   00005B   A9..         MOV     R1,?V2
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   7F03         MOV     R7,#0x3
   \   000064   02....       LJMP    ?BANKED_LEAVE_XDATA
   1117          }
   1118          
   1119          /******************************************************************************
   1120           * @fn          ZDSecMgrMasterKeyLoad
   1121           *
   1122           * @brief       Load the MASTER key for device with specified EXT
   1123           *              address.
   1124           *
   1125           * @param       extAddr - [in] EXT address of device
   1126           * @param       key     - [in] MASTER key shared with device
   1127           *
   1128           * @return      ZStatus_t
   1129           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1130          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1131          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V2,R4
   \   000010   8D..         MOV     ?V3,R5
   1132            ZStatus_t status;
   1133            uint16 ami;
   1134            uint16 keyNvId;
   1135          
   1136          
   1137            // set status based on policy
   1138            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   000012                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000012   AC..         MOV     R4,?XSP + 0
   \   000014   AD..         MOV     R5,?XSP + 1
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay; Banked call to: ZDSecMgrExtAddrLookup
   \   00001D   E9           MOV     A,R1
   \   00001E   F5..         MOV     ?V0,A
   1139          
   1140            if ( status == ZSuccess )
   \   000020   E5..         MOV     A,?V0
   \   000022   7054         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1141            {
   1142              // get the address NV ID
   1143              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   \   000024                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000024   7402         MOV     A,#0x2
   \   000026   12....       LCALL   ?XSTACK_DISP102_8
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FB           MOV     R3,A
   \   000034   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay; Banked call to: ZDSecMgrMasterKeyLookup
   \   000037   E9           MOV     A,R1
   \   000038   7029         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1144              {
   1145                // overwrite old key in NV
   1146                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1147                               SEC_KEY_LEN, key );
   \   00003A                ; Setup parameters for call to function osal_nv_write
   \   00003A   78..         MOV     R0,#?V2
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   75..10       MOV     ?V4,#0x10
   \   000042   75..00       MOV     ?V5,#0x0
   \   000045   78..         MOV     R0,#?V4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   7C02         MOV     R4,#0x2
   \   00004C   7D00         MOV     R5,#0x0
   \   00004E   7406         MOV     A,#0x6
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FA           MOV     R2,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   FB           MOV     R3,A
   \   000058   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   00005B   7404         MOV     A,#0x4
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   E9           MOV     A,R1
   \   000061   8015         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1148              }
   1149              else
   1150              {
   1151                // store new key -- NULL will zero key
   1152                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   000063                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000063   AC..         MOV     R4,?V2
   \   000065   AD..         MOV     R5,?V3
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FA           MOV     R2,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay; Banked call to: ZDSecMgrMasterKeyStore
   \   000075   E9           MOV     A,R1
   \   000076   F5..         MOV     ?V0,A
   1153              }
   1154            }
   1155          
   1156            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000078   A9..         MOV     R1,?V0
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   7F06         MOV     R7,#0x6
   \   000081   02....       LJMP    ?BANKED_LEAVE_XDATA
   1157          }
   1158          
   1159          /******************************************************************************
   1160           * @fn          ZDSecMgrAppKeyGet
   1161           *
   1162           * @brief       get an APP key - option APP(MASTER or LINK) key
   1163           *
   1164           * @param       initNwkAddr - [in] NWK address of initiator device
   1165           * @param       initExtAddr - [in] EXT address of initiator device
   1166           * @param       partNwkAddr - [in] NWK address of partner device
   1167           * @param       partExtAddr - [in] EXT address of partner device
   1168           * @param       key         - [out] APP(MASTER or LINK) key
   1169           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1170           *
   1171           * @return      ZStatus_t
   1172           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1173          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1174                                                           // to KEY_TYPE_APP_LINK since
   1175                                                           // only specific requirement
   1176                                                           // right now comes from SE profile
   1177          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1178          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1179                                       uint8*  initExtAddr,
   1180                                       uint16  partNwkAddr,
   1181                                       uint8*  partExtAddr,
   1182                                       uint8** key,
   1183                                       uint8*  keyType )
   1184          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   \   000009   8C..         MOV     ?V4,R4
   \   00000B   8D..         MOV     ?V5,R5
   \   00000D   7412         MOV     A,#0x12
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V1,A
   \   000019   7414         MOV     A,#0x14
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FE           MOV     R6,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FF           MOV     R7,A
   1185            // Intentionally unreferenced parameters
   1186            (void)initNwkAddr;
   1187            (void)initExtAddr;
   1188            (void)partNwkAddr;
   1189            (void)partExtAddr;
   1190            
   1191            //---------------------------------------------------------------------------
   1192            // note:
   1193            // should use a robust mechanism to generate keys, for example
   1194            // combine EXT addresses and call a hash function
   1195            //---------------------------------------------------------------------------
   1196            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000023                ; Setup parameters for call to function SSP_GetTrueRand
   \   000023   85..82       MOV     DPL,?V0
   \   000026   85..83       MOV     DPH,?V1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FA           MOV     R2,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   FB           MOV     R3,A
   \   00002E   7910         MOV     R1,#0x10
   \   000030   12....       LCALL   ??SSP_GetTrueRand?relay; Banked call to: SSP_GetTrueRand
   1197          
   1198            *keyType = ZDSecMgrAppKeyType;
   \   000033   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000036   E0           MOVX    A,@DPTR
   \   000037   C0E0         PUSH    A
   \   000039   8E82         MOV     DPL,R6
   \   00003B   8F83         MOV     DPH,R7
   \   00003D   D0E0         POP     A
   \   00003F   F0           MOVX    @DPTR,A
   1199          
   1200            return ZSuccess;
   \   000040   7900         MOV     R1,#0x0
   \   000042   7F06         MOV     R7,#0x6
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
   1201          }
   1202          
   1203          /******************************************************************************
   1204           * @fn          ZDSecMgrAppKeyReq
   1205           *
   1206           * @brief       Process request for APP key between two devices.
   1207           *
   1208           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1209           *
   1210           * @return      none
   1211           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1212          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1213          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1214            APSME_TransportKeyReq_t req;
   1215            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1216            uint16                  partNwkAddr;
   1217            uint8                   key[SEC_KEY_LEN];
   1218          
   1219          
   1220            // validate initiator and partner
   1221            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1222                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   2405         ADD     A,#0x5
   \   000015   FA           MOV     R2,A
   \   000016   E4           CLR     A
   \   000017   3F           ADDC    A,R7
   \   000018   FB           MOV     R3,A
   \   000019   12....       LCALL   ??APSME_LookupNwkAddr?relay; Banked call to: APSME_LookupNwkAddr
   \   00001C   E9           MOV     A,R1
   \   00001D   6401         XRL     A,#0x1
   \   00001F   6003         JZ      $+5
   \   000021   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000024                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000024   740F         MOV     A,#0xf
   \   000026   12....       LCALL   ?XSTACK_DISP102_8
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FB           MOV     R3,A
   \   000034   12....       LCALL   ??APSME_LookupExtAddr?relay; Banked call to: APSME_LookupExtAddr
   \   000037   E9           MOV     A,R1
   \   000038   6401         XRL     A,#0x1
   \   00003A   6003         JZ      $+5
   \   00003C   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1223            {
   1224              // point the key to some memory
   1225              req.key = key;
   \   00003F   7417         MOV     A,#0x17
   \   000041   12....       LCALL   ?XSTACK_DISP100_8
   \   000044   7406         MOV     A,#0x6
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E8           MOV     A,R0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E9           MOV     A,R1
   \   00004D   F0           MOVX    @DPTR,A
   1226          
   1227              // get an APP key - option APP (MASTER or LINK) key
   1228              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1229                                      initExtAddr,
   1230                                      partNwkAddr,
   1231                                      ind->partExtAddr,
   1232                                      &req.key,
   1233                                      &req.keyType ) == ZSuccess )
   \   00004E                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00004E   7404         MOV     A,#0x4
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   8582..       MOV     ?V0,DPL
   \   000056   8583..       MOV     ?V1,DPH
   \   000059   78..         MOV     R0,#?V0
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   7408         MOV     A,#0x8
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   8582..       MOV     ?V0,DPL
   \   000066   8583..       MOV     ?V1,DPH
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006E   EE           MOV     A,R6
   \   00006F   2405         ADD     A,#0x5
   \   000071   F5..         MOV     ?V0,A
   \   000073   E4           CLR     A
   \   000074   3F           ADDC    A,R7
   \   000075   F5..         MOV     ?V1,A
   \   000077   78..         MOV     R0,#?V0
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   7406         MOV     A,#0x6
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000084   7417         MOV     A,#0x17
   \   000086   12....       LCALL   ?XSTACK_DISP102_8
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   FA           MOV     R2,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   FB           MOV     R3,A
   \   000094   12....       LCALL   ??ZDSecMgrAppKeyGet?relay; Banked call to: ZDSecMgrAppKeyGet
   \   000097   7408         MOV     A,#0x8
   \   000099   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009C   E9           MOV     A,R1
   \   00009D   6003         JZ      $+5
   \   00009F   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1234              {
   1235                // always secure
   1236                req.nwkSecure = TRUE;
   \   0000A2   740C         MOV     A,#0xc
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   7401         MOV     A,#0x1
   \   0000A9   F0           MOVX    @DPTR,A
   1237                req.apsSecure = TRUE;
   \   0000AA   740B         MOV     A,#0xb
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   7401         MOV     A,#0x1
   \   0000B1   F0           MOVX    @DPTR,A
   1238                req.tunnel    = NULL;
   \   0000B2   740D         MOV     A,#0xd
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   7400         MOV     A,#0x0
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   7400         MOV     A,#0x0
   \   0000BD   F0           MOVX    @DPTR,A
   1239          
   1240                // send key to initiator device
   1241                req.dstAddr   = ind->srcAddr;
   \   0000BE   8E82         MOV     DPL,R6
   \   0000C0   8F83         MOV     DPH,R7
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   F8           MOV     R0,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F9           MOV     R1,A
   \   0000C9   7402         MOV     A,#0x2
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   E8           MOV     A,R0
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E9           MOV     A,R1
   \   0000D2   F0           MOVX    @DPTR,A
   1242                req.extAddr   = ind->partExtAddr;
   \   0000D3   EE           MOV     A,R6
   \   0000D4   2405         ADD     A,#0x5
   \   0000D6   F8           MOV     R0,A
   \   0000D7   E4           CLR     A
   \   0000D8   3F           ADDC    A,R7
   \   0000D9   F9           MOV     R1,A
   \   0000DA   7408         MOV     A,#0x8
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   E8           MOV     A,R0
   \   0000E0   F0           MOVX    @DPTR,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   E9           MOV     A,R1
   \   0000E3   F0           MOVX    @DPTR,A
   1243                req.initiator = TRUE;
   \   0000E4   740A         MOV     A,#0xa
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   7401         MOV     A,#0x1
   \   0000EB   F0           MOVX    @DPTR,A
   1244                APSME_TransportKeyReq( &req );
   \   0000EC                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000EC   7402         MOV     A,#0x2
   \   0000EE   12....       LCALL   ?XSTACK_DISP101_8
   \   0000F1   12....       LCALL   ??APSME_TransportKeyReq?relay; Banked call to: APSME_TransportKeyReq
   \   0000F4   E9           MOV     A,R1
   1245          
   1246                // send key to partner device
   1247                req.dstAddr   = partNwkAddr;
   \   0000F5   85..82       MOV     DPL,?XSP + 0
   \   0000F8   85..83       MOV     DPH,?XSP + 1
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   F8           MOV     R0,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   F9           MOV     R1,A
   \   000100   7402         MOV     A,#0x2
   \   000102   12....       LCALL   ?XSTACK_DISP0_8
   \   000105   E8           MOV     A,R0
   \   000106   F0           MOVX    @DPTR,A
   \   000107   A3           INC     DPTR
   \   000108   E9           MOV     A,R1
   \   000109   F0           MOVX    @DPTR,A
   1248                req.extAddr   = initExtAddr;
   \   00010A   740F         MOV     A,#0xf
   \   00010C   12....       LCALL   ?XSTACK_DISP100_8
   \   00010F   7408         MOV     A,#0x8
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   E8           MOV     A,R0
   \   000115   F0           MOVX    @DPTR,A
   \   000116   A3           INC     DPTR
   \   000117   E9           MOV     A,R1
   \   000118   F0           MOVX    @DPTR,A
   1249                req.initiator = FALSE;
   \   000119   740A         MOV     A,#0xa
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   7400         MOV     A,#0x0
   \   000120   F0           MOVX    @DPTR,A
   1250          
   1251                APSME_TransportKeyReq( &req );
   \   000121                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000121   7402         MOV     A,#0x2
   \   000123   12....       LCALL   ?XSTACK_DISP101_8
   \   000126   12....       LCALL   ??APSME_TransportKeyReq?relay; Banked call to: APSME_TransportKeyReq
   \   000129   E9           MOV     A,R1
   1252                
   1253                // clear copy of key in RAM
   1254                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   00012A                ; Setup parameters for call to function osal_memset
   \   00012A   7C10         MOV     R4,#0x10
   \   00012C   7D00         MOV     R5,#0x0
   \   00012E   7900         MOV     R1,#0x0
   \   000130   7417         MOV     A,#0x17
   \   000132   12....       LCALL   ?XSTACK_DISP101_8
   \   000135   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1255          
   1256              }
   1257            }
   1258          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   000138   7427         MOV     A,#0x27
   \   00013A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013D   7F02         MOV     R7,#0x2
   \   00013F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1259          
   1260          /******************************************************************************
   1261           * @fn          ZDSecMgrEstablishKey
   1262           *
   1263           * @brief       Start SKKE with device joining network.
   1264           *
   1265           * @param       device - [in] ZDSecMgrDevice_t, device info
   1266           *
   1267           * @return      ZStatus_t
   1268           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1269          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1270          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1271            ZStatus_t               status;
   1272            APSME_EstablishKeyReq_t req;
   1273          
   1274          
   1275            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E8           MOV     A,R0
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
   1276            req.method      = APSME_SKKE_METHOD;
   \   000023   7404         MOV     A,#0x4
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   7400         MOV     A,#0x0
   \   00002A   F0           MOVX    @DPTR,A
   1277          
   1278            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00002B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002B   12....       LCALL   ??NLME_GetShortAddr?relay; Banked call to: NLME_GetShortAddr
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   \   000032   A8..         MOV     R0,?V2
   \   000034   A9..         MOV     R1,?V3
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   68           XRL     A,R0
   \   000040   7003         JNZ     ??ZDSecMgrEstablishKey_0
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   69           XRL     A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   000045   7026         JNZ     ??ZDSecMgrEstablishKey_1
   1279            {
   1280              req.dstAddr   = device->nwkAddr;
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F8           MOV     R0,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F9           MOV     R1,A
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   E8           MOV     A,R0
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   E9           MOV     A,R1
   \   00005A   F0           MOVX    @DPTR,A
   1281              //devtag.0604.todo - remove obsolete
   1282              req.apsSecure = FALSE;
   \   00005B   7405         MOV     A,#0x5
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   7400         MOV     A,#0x0
   \   000062   F0           MOVX    @DPTR,A
   1283              req.nwkSecure = FALSE;
   \   000063   7406         MOV     A,#0x6
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   7400         MOV     A,#0x0
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   8028         SJMP    ??ZDSecMgrEstablishKey_2
   1284            }
   1285            else
   1286            {
   1287              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   00006D   8E82         MOV     DPL,R6
   \   00006F   8F83         MOV     DPH,R7
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   E0           MOVX    A,@DPTR
   \   000076   F8           MOV     R0,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F9           MOV     R1,A
   \   00007A   85..82       MOV     DPL,?XSP + 0
   \   00007D   85..83       MOV     DPH,?XSP + 1
   \   000080   E8           MOV     A,R0
   \   000081   F0           MOVX    @DPTR,A
   \   000082   A3           INC     DPTR
   \   000083   E9           MOV     A,R1
   \   000084   F0           MOVX    @DPTR,A
   1288              //devtag.0604.todo - remove obsolete
   1289              req.apsSecure = TRUE;
   \   000085   7405         MOV     A,#0x5
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   7401         MOV     A,#0x1
   \   00008C   F0           MOVX    @DPTR,A
   1290              req.nwkSecure = TRUE;
   \   00008D   7406         MOV     A,#0x6
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   7401         MOV     A,#0x1
   \   000094   F0           MOVX    @DPTR,A
   1291            }
   1292          
   1293            status = APSME_EstablishKeyReq( &req );
   \                     ??ZDSecMgrEstablishKey_2:
   \   000095                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000095   AA..         MOV     R2,?XSP + 0
   \   000097   AB..         MOV     R3,?XSP + 1
   \   000099   12....       LCALL   ??APSME_EstablishKeyReq?relay; Banked call to: APSME_EstablishKeyReq
   \   00009C   E9           MOV     A,R1
   \   00009D   F5..         MOV     ?V0,A
   1294          
   1295            return status;
   \   00009F   A9..         MOV     R1,?V0
   \   0000A1   7407         MOV     A,#0x7
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A6   7F04         MOV     R7,#0x4
   \   0000A8   02....       LJMP    ?BANKED_LEAVE_XDATA
   1296          }
   1297          
   1298          /******************************************************************************
   1299           * @fn          ZDSecMgrSendMasterKey
   1300           *
   1301           * @brief       Send MASTER key to device joining network.
   1302           *
   1303           * @param       device - [in] ZDSecMgrDevice_t, device info
   1304           *
   1305           * @return      ZStatus_t
   1306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1307          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1308          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1309            ZStatus_t status;
   1310            APSME_TransportKeyReq_t req;
   1311            uint16 keyNvId;
   1312            uint8 masterKey[SEC_KEY_LEN];
   1313          
   1314          
   1315            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   1316            req.extAddr = device->extAddr;
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   7408         MOV     A,#0x8
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E8           MOV     A,R0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E9           MOV     A,R1
   \   00002A   F0           MOVX    @DPTR,A
   1317            req.tunnel  = NULL;
   \   00002B   740D         MOV     A,#0xd
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   7400         MOV     A,#0x0
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7400         MOV     A,#0x0
   \   000036   F0           MOVX    @DPTR,A
   1318          
   1319            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   \   000037                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000037   AC..         MOV     R4,?XSP + 0
   \   000039   AD..         MOV     R5,?XSP + 1
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F8           MOV     R0,A
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F583         MOV     DPH,A
   \   00004D   8882         MOV     DPL,R0
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F8           MOV     R0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F583         MOV     DPH,A
   \   000055   8882         MOV     DPL,R0
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FA           MOV     R2,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   FB           MOV     R3,A
   \   00005C   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay; Banked call to: ZDSecMgrMasterKeyLookup
   \   00005F   E9           MOV     A,R1
   \   000060   7032         JNZ     ??ZDSecMgrSendMasterKey_0
   1320            {
   1321              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1322                            SEC_KEY_LEN, masterKey );
   \   000062                ; Setup parameters for call to function osal_nv_read
   \   000062   740F         MOV     A,#0xf
   \   000064   12....       LCALL   ?XSTACK_DISP100_8
   \   000067   88..         MOV     ?V2,R0
   \   000069   89..         MOV     ?V3,R1
   \   00006B   78..         MOV     R0,#?V2
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000070   75..10       MOV     ?V2,#0x10
   \   000073   75..00       MOV     ?V3,#0x0
   \   000076   78..         MOV     R0,#?V2
   \   000078   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007B   7C02         MOV     R4,#0x2
   \   00007D   7D00         MOV     R5,#0x0
   \   00007F   7404         MOV     A,#0x4
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FA           MOV     R2,A
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   FB           MOV     R3,A
   \   000089   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   00008C   7404         MOV     A,#0x4
   \   00008E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000091   E9           MOV     A,R1
   \   000092   800E         SJMP    ??ZDSecMgrSendMasterKey_1
   1323            }
   1324            else
   1325            {
   1326              // in case read from NV fails
   1327              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000094                ; Setup parameters for call to function osal_memset
   \   000094   7C10         MOV     R4,#0x10
   \   000096   7D00         MOV     R5,#0x0
   \   000098   7900         MOV     R1,#0x0
   \   00009A   740F         MOV     A,#0xf
   \   00009C   12....       LCALL   ?XSTACK_DISP101_8
   \   00009F   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1328            }
   1329          
   1330            req.key = masterKey;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   0000A2   740F         MOV     A,#0xf
   \   0000A4   12....       LCALL   ?XSTACK_DISP100_8
   \   0000A7   7406         MOV     A,#0x6
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   E8           MOV     A,R0
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E9           MOV     A,R1
   \   0000B0   F0           MOVX    @DPTR,A
   1331          
   1332            //check if using secure hop to to parent
   1333            if ( device->parentAddr != NLME_GetShortAddr() )
   \   0000B1                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000B1   12....       LCALL   ??NLME_GetShortAddr?relay; Banked call to: NLME_GetShortAddr
   \   0000B4   8A..         MOV     ?V2,R2
   \   0000B6   8B..         MOV     ?V3,R3
   \   0000B8   A8..         MOV     R0,?V2
   \   0000BA   A9..         MOV     R1,?V3
   \   0000BC   8E82         MOV     DPL,R6
   \   0000BE   8F83         MOV     DPH,R7
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   68           XRL     A,R0
   \   0000C6   7003         JNZ     ??ZDSecMgrSendMasterKey_2
   \   0000C8   A3           INC     DPTR
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   69           XRL     A,R1
   \                     ??ZDSecMgrSendMasterKey_2:
   \   0000CB   6029         JZ      ??ZDSecMgrSendMasterKey_3
   1334            {
   1335              //send to parent with security
   1336              req.dstAddr   = device->parentAddr;
   \   0000CD   8E82         MOV     DPL,R6
   \   0000CF   8F83         MOV     DPH,R7
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   F8           MOV     R0,A
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   F9           MOV     R1,A
   \   0000DA   7402         MOV     A,#0x2
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   E8           MOV     A,R0
   \   0000E0   F0           MOVX    @DPTR,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   E9           MOV     A,R1
   \   0000E3   F0           MOVX    @DPTR,A
   1337              req.nwkSecure = TRUE;
   \   0000E4   740C         MOV     A,#0xc
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   7401         MOV     A,#0x1
   \   0000EB   F0           MOVX    @DPTR,A
   1338              req.apsSecure = TRUE;
   \   0000EC   740B         MOV     A,#0xb
   \   0000EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F1   7401         MOV     A,#0x1
   \   0000F3   F0           MOVX    @DPTR,A
   \   0000F4   8023         SJMP    ??ZDSecMgrSendMasterKey_4
   1339            }
   1340            else
   1341            {
   1342              //direct with no security
   1343              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_3:
   \   0000F6   8E82         MOV     DPL,R6
   \   0000F8   8F83         MOV     DPH,R7
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F8           MOV     R0,A
   \   0000FC   A3           INC     DPTR
   \   0000FD   E0           MOVX    A,@DPTR
   \   0000FE   F9           MOV     R1,A
   \   0000FF   7402         MOV     A,#0x2
   \   000101   12....       LCALL   ?XSTACK_DISP0_8
   \   000104   E8           MOV     A,R0
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   E9           MOV     A,R1
   \   000108   F0           MOVX    @DPTR,A
   1344              req.nwkSecure = FALSE;
   \   000109   740C         MOV     A,#0xc
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   7400         MOV     A,#0x0
   \   000110   F0           MOVX    @DPTR,A
   1345              req.apsSecure = FALSE;
   \   000111   740B         MOV     A,#0xb
   \   000113   12....       LCALL   ?XSTACK_DISP0_8
   \   000116   7400         MOV     A,#0x0
   \   000118   F0           MOVX    @DPTR,A
   1346            }
   1347          
   1348            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendMasterKey_4:
   \   000119                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?XSTACK_DISP101_8
   \   00011E   12....       LCALL   ??APSME_TransportKeyReq?relay; Banked call to: APSME_TransportKeyReq
   \   000121   E9           MOV     A,R1
   \   000122   F5..         MOV     ?V0,A
   1349          
   1350            // clear copy of key in RAM
   1351            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \   000124                ; Setup parameters for call to function osal_memset
   \   000124   7C10         MOV     R4,#0x10
   \   000126   7D00         MOV     R5,#0x0
   \   000128   7900         MOV     R1,#0x0
   \   00012A   740F         MOV     A,#0xf
   \   00012C   12....       LCALL   ?XSTACK_DISP101_8
   \   00012F   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1352          
   1353            return status;
   \   000132   A9..         MOV     R1,?V0
   \   000134   741F         MOV     A,#0x1f
   \   000136   12....       LCALL   ?DEALLOC_XSTACK8
   \   000139   7F04         MOV     R7,#0x4
   \   00013B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1354          }
   1355          
   1356          /******************************************************************************
   1357           * @fn          ZDSecMgrSendNwkKey
   1358           *
   1359           * @brief       Send NWK key to device joining network.
   1360           *
   1361           * @param       device - [in] ZDSecMgrDevice_t, device info
   1362           *
   1363           * @return      ZStatus_t
   1364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1365          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1366          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1367            ZStatus_t status;
   1368            APSME_TransportKeyReq_t req;
   1369            APSDE_FrameTunnel_t tunnel;
   1370            nwkKeyDesc tmpKey;
   1371              
   1372            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E8           MOV     A,R0
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   E9           MOV     A,R1
   \   000021   F0           MOVX    @DPTR,A
   1373            req.extAddr   = device->extAddr;
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   7406         MOV     A,#0x6
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E8           MOV     A,R0
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   E9           MOV     A,R1
   \   000036   F0           MOVX    @DPTR,A
   1374          
   1375            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1376              req.keyType   = KEY_TYPE_NWK_HIGH;
   1377            else
   1378              req.keyType   = KEY_TYPE_NWK;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   7401         MOV     A,#0x1
   \   00003E   F0           MOVX    @DPTR,A
   1379          
   1380            // get the Active Key into a local variable 
   1381            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1382                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   00003F                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   00003F   75..3A       MOV     ?V2,#0x3a
   \   000042   75..00       MOV     ?V3,#0x0
   \   000045   78..         MOV     R0,#?V2
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   740F         MOV     A,#0xf
   \   00004C   12....       LCALL   ?XSTACK_DISP100_8
   \   00004F   88..         MOV     ?V2,R0
   \   000051   89..         MOV     ?V3,R1
   \   000053   78..         MOV     R0,#?V2
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   7C11         MOV     R4,#0x11
   \   00005A   7D00         MOV     R5,#0x0
   \   00005C   7A00         MOV     R2,#0x0
   \   00005E   7B00         MOV     R3,#0x0
   \   000060   12....       LCALL   ??NLME_ReadNwkKeyInfo?relay; Banked call to: NLME_ReadNwkKeyInfo
   \   000063   7404         MOV     A,#0x4
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   E9           MOV     A,R1
   \   000069   600E         JZ      ??ZDSecMgrSendNwkKey_0
   1383            {
   1384              // set key data to all 0s if NV read fails
   1385              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   00006B                ; Setup parameters for call to function osal_memset
   \   00006B   7C11         MOV     R4,#0x11
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   7900         MOV     R1,#0x0
   \   000071   740D         MOV     A,#0xd
   \   000073   12....       LCALL   ?XSTACK_DISP101_8
   \   000076   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1386            }
   1387            
   1388            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1389                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1390            {
   1391              // set values
   1392              req.keySeqNum = tmpKey.keySeqNum;
   1393              req.key       = tmpKey.key;
   1394          
   1395              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1396              //key isn't used to secure the frame at the APS layer -- since the receiving
   1397              //device may not have a NWK key yet
   1398              req.apsSecure = TRUE;
   1399          
   1400              // check if using secure hop to to parent
   1401              if ( device->parentAddr == NLME_GetShortAddr() )
   1402              {
   1403                req.nwkSecure = FALSE;
   1404                req.tunnel    = NULL;
   1405              }
   1406              else
   1407              {
   1408                req.nwkSecure   = TRUE;
   1409                req.tunnel      = &tunnel;
   1410                req.tunnel->tna = device->parentAddr;
   1411                req.tunnel->dea = device->extAddr;
   1412              }
   1413            }
   1414            else
   1415            {
   1416              // default values
   1417              //devtag.0604.verify
   1418              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000079   740A         MOV     A,#0xa
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   7401         MOV     A,#0x1
   \   000080   F0           MOVX    @DPTR,A
   1419              req.apsSecure = FALSE;
   \   000081   7409         MOV     A,#0x9
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   7400         MOV     A,#0x0
   \   000088   F0           MOVX    @DPTR,A
   1420              req.tunnel    = NULL;
   \   000089   740B         MOV     A,#0xb
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   7400         MOV     A,#0x0
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   7400         MOV     A,#0x0
   \   000094   F0           MOVX    @DPTR,A
   1421          
   1422              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000095                ; Setup parameters for call to function NLME_GetShortAddr
   \   000095   12....       LCALL   ??NLME_GetShortAddr?relay; Banked call to: NLME_GetShortAddr
   \   000098   8A..         MOV     ?V2,R2
   \   00009A   8B..         MOV     ?V3,R3
   \   00009C   A8..         MOV     R0,?V2
   \   00009E   A9..         MOV     R1,?V3
   \   0000A0   8E82         MOV     DPL,R6
   \   0000A2   8F83         MOV     DPH,R7
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   68           XRL     A,R0
   \   0000AA   7003         JNZ     ??ZDSecMgrSendNwkKey_1
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000AF   6018         JZ      ??ZDSecMgrSendNwkKey_2
   1423              {
   1424                req.dstAddr = device->parentAddr;
   \   0000B1   8E82         MOV     DPL,R6
   \   0000B3   8F83         MOV     DPH,R7
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   85..82       MOV     DPL,?XSP + 0
   \   0000C1   85..83       MOV     DPH,?XSP + 1
   \   0000C4   E8           MOV     A,R0
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E9           MOV     A,R1
   \   0000C8   F0           MOVX    @DPTR,A
   1425              }
   1426          
   1427              // special cases
   1428              //devtag.0604.todo - modify to preconfig flag
   1429              if ( device->secure == FALSE )
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000C9   8E82         MOV     DPL,R6
   \   0000CB   8F83         MOV     DPH,R7
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   7049         JNZ     ??ZDSecMgrSendNwkKey_3
   1430              {
   1431                req.keySeqNum = tmpKey.keySeqNum;
   \   0000D6   740D         MOV     A,#0xd
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   C0E0         PUSH    A
   \   0000DE   7403         MOV     A,#0x3
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   D0E0         POP     A
   \   0000E5   F0           MOVX    @DPTR,A
   1432                req.key       = tmpKey.key;
   \   0000E6   740E         MOV     A,#0xe
   \   0000E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EB   A882         MOV     R0,DPL
   \   0000ED   A983         MOV     R1,DPH
   \   0000EF   7404         MOV     A,#0x4
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   E8           MOV     A,R0
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   A3           INC     DPTR
   \   0000F7   E9           MOV     A,R1
   \   0000F8   F0           MOVX    @DPTR,A
   1433          
   1434                // check if using secure hop to to parent
   1435                if ( device->parentAddr == NLME_GetShortAddr() )
   \   0000F9                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000F9   12....       LCALL   ??NLME_GetShortAddr?relay; Banked call to: NLME_GetShortAddr
   \   0000FC   8A..         MOV     ?V2,R2
   \   0000FE   8B..         MOV     ?V3,R3
   \   000100   A8..         MOV     R0,?V2
   \   000102   A9..         MOV     R1,?V3
   \   000104   8E82         MOV     DPL,R6
   \   000106   8F83         MOV     DPH,R7
   \   000108   A3           INC     DPTR
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   68           XRL     A,R0
   \   00010E   7003         JNZ     ??ZDSecMgrSendNwkKey_4
   \   000110   A3           INC     DPTR
   \   000111   E0           MOVX    A,@DPTR
   \   000112   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_4:
   \   000113   701E         JNZ     ??ZDSecMgrSendNwkKey_5
   1436                {
   1437                  req.nwkSecure = FALSE;
   \   000115   740A         MOV     A,#0xa
   \   000117   12....       LCALL   ?XSTACK_DISP0_8
   \   00011A   7400         MOV     A,#0x0
   \   00011C   F0           MOVX    @DPTR,A
   \   00011D   8014         SJMP    ??ZDSecMgrSendNwkKey_5
   1438                }
   1439              }
   1440              else
   1441              {
   1442                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   00011F   7404         MOV     A,#0x4
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   7400         MOV     A,#0x0
   \   000126   F0           MOVX    @DPTR,A
   \   000127   A3           INC     DPTR
   \   000128   7400         MOV     A,#0x0
   \   00012A   F0           MOVX    @DPTR,A
   1443                req.keySeqNum = 0;
   \   00012B   7403         MOV     A,#0x3
   \   00012D   12....       LCALL   ?XSTACK_DISP0_8
   \   000130   7400         MOV     A,#0x0
   \   000132   F0           MOVX    @DPTR,A
   1444              }
   1445            }
   1446          
   1447            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_5:
   \   000133                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000133   AA..         MOV     R2,?XSP + 0
   \   000135   AB..         MOV     R3,?XSP + 1
   \   000137   12....       LCALL   ??APSME_TransportKeyReq?relay; Banked call to: APSME_TransportKeyReq
   \   00013A   E9           MOV     A,R1
   \   00013B   F5..         MOV     ?V0,A
   1448          
   1449            // clear copy of key in RAM before return
   1450            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   00013D                ; Setup parameters for call to function osal_memset
   \   00013D   7C11         MOV     R4,#0x11
   \   00013F   7D00         MOV     R5,#0x0
   \   000141   7900         MOV     R1,#0x0
   \   000143   740D         MOV     A,#0xd
   \   000145   12....       LCALL   ?XSTACK_DISP101_8
   \   000148   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1451          
   1452            return status;
   \   00014B   A9..         MOV     R1,?V0
   \   00014D   741E         MOV     A,#0x1e
   \   00014F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000152   7F04         MOV     R7,#0x4
   \   000154   02....       LJMP    ?BANKED_LEAVE_XDATA
   1453          }
   1454          
   1455          /******************************************************************************
   1456           * @fn          ZDSecMgrDeviceEntryRemove
   1457           *
   1458           * @brief       Remove device entry.
   1459           *
   1460           * @param       entry - [in] valid entry
   1461           *
   1462           * @return      none
   1463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1464          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1465          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1466            // terminate device control
   1467            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   \   000009   90....       MOV     DPTR,#zgDeviceLogicalType
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7007         JNZ     ??ZDSecMgrDeviceEntryRemove_0
   1468            {
   1469              ZDSecMgrCtrlTerm( entry );
   \   00000F                ; Setup parameters for call to function ZDSecMgrCtrlTerm
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??ZDSecMgrCtrlTerm?relay; Banked call to: ZDSecMgrCtrlTerm
   1470            }
   1471          
   1472            // remove device from entry data
   1473            ZDSecMgrEntryFree( entry );
   \                     ??ZDSecMgrDeviceEntryRemove_0:
   \   000016                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??ZDSecMgrEntryFree?relay; Banked call to: ZDSecMgrEntryFree
   1474          
   1475            // remove EXT address
   1476            //ZDSecMgrExtAddrRelease( aiOld );
   1477          }
   \   00001D   7F01         MOV     R7,#0x1
   \   00001F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1478          
   1479          /******************************************************************************
   1480           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1481           *
   1482           * @brief       Remove device entry by its ext address.
   1483           *
   1484           * @param       pAddr - pointer to the extended address
   1485           *
   1486           * @return      ZStatus_t
   1487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1488          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1489          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1490            ZDSecMgrEntry_t *pEntry;
   1491            uint8           retValue;
   1492            
   1493            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   FA           MOV     R2,A
   \   000014   EF           MOV     A,R7
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay; Banked call to: ZDSecMgrEntryLookupExt
   \   000019   E9           MOV     A,R1
   \   00001A   F5..         MOV     ?V0,A
   1494            
   1495            if( retValue == ZSuccess )
   \   00001C   E5..         MOV     A,?V0
   \   00001E   700E         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
   1496            {
   1497              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000020                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FB           MOV     R3,A
   \   00002B   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay; Banked call to: ZDSecMgrDeviceEntryRemove
   1498            }
   1499            
   1500            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   00002E   A9..         MOV     R1,?V0
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
   \   000035   7F01         MOV     R7,#0x1
   \   000037   02....       LJMP    ?BANKED_LEAVE_XDATA
   1501          }
   1502          
   1503          /******************************************************************************
   1504           * @fn          ZDSecMgrDeviceEntryAdd
   1505           *
   1506           * @brief       Add entry.
   1507           *
   1508           * @param       device - [in] ZDSecMgrDevice_t, device info
   1509           * @param       ami    - [in] Address Manager index
   1510           *
   1511           * @return      ZStatus_t
   1512           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1513          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1514          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1515            AddrMgrEntry_t entry;
   1516          
   1517            // get the ami data
   1518            entry.user  = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
   1519            entry.index = ami;
   \   00001B   740B         MOV     A,#0xb
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E5..         MOV     A,?V0
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E5..         MOV     A,?V1
   \   000026   F0           MOVX    @DPTR,A
   1520          
   1521            AddrMgrEntryGet( &entry );
   \   000027                ; Setup parameters for call to function AddrMgrEntryGet
   \   000027   AA..         MOV     R2,?XSP + 0
   \   000029   AB..         MOV     R3,?XSP + 1
   \   00002B   12....       LCALL   ??AddrMgrEntryGet?relay; Banked call to: AddrMgrEntryGet
   \   00002E   E9           MOV     A,R1
   1522          
   1523            // check if NWK address is same
   1524            if ( entry.nwkAddr != nwkAddr )
   \   00002F   7401         MOV     A,#0x1
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   6E           XRL     A,R6
   \   000036   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00003B   6012         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1525            {
   1526              // update NWK address
   1527              entry.nwkAddr = nwkAddr;
   \   00003D   7401         MOV     A,#0x1
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   EE           MOV     A,R6
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   EF           MOV     A,R7
   \   000046   F0           MOVX    @DPTR,A
   1528          
   1529              AddrMgrEntryUpdate( &entry );
   \   000047                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000047   AA..         MOV     R2,?XSP + 0
   \   000049   AB..         MOV     R3,?XSP + 1
   \   00004B   12....       LCALL   ??AddrMgrEntryUpdate?relay; Banked call to: AddrMgrEntryUpdate
   \   00004E   E9           MOV     A,R1
   1530            }
   1531          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00004F   740D         MOV     A,#0xd
   \   000051   12....       LCALL   ?DEALLOC_XSTACK8
   \   000054   7F02         MOV     R7,#0x2
   \   000056   02....       LJMP    ?BANKED_LEAVE_XDATA
   1532          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1533          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1534          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1535            ZStatus_t        status;
   1536            ZDSecMgrEntry_t* entry;
   1537          
   1538          
   1539            // initialize as unknown until completion
   1540            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0,#-0x38
   1541          
   1542            device->ctrl = NULL;
   \   000015   85..82       MOV     DPL,?V2
   \   000018   85..83       MOV     DPH,?V3
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   7400         MOV     A,#0x0
   \   000029   F0           MOVX    @DPTR,A
   1543          
   1544            // make sure not already registered
   1545            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   00002A                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   00002A   AC..         MOV     R4,?XSP + 0
   \   00002C   AD..         MOV     R5,?XSP + 1
   \   00002E   85..82       MOV     DPL,?V2
   \   000031   85..83       MOV     DPH,?V3
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FA           MOV     R2,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrEntryLookup?relay; Banked call to: ZDSecMgrEntryLookup
   \   00003C   E9           MOV     A,R1
   \   00003D   7047         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1546            {
   1547              // verify that address index is same
   1548              if ( entry->ami != ami )
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F583         MOV     DPH,A
   \   00004B   8882         MOV     DPL,R0
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   6E           XRL     A,R6
   \   00004F   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000054   6050         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1549              {
   1550                // remove conflicting entry
   1551                ZDSecMgrDeviceEntryRemove( entry );
   \   000056                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   FA           MOV     R2,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   FB           MOV     R3,A
   \   000061   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay; Banked call to: ZDSecMgrDeviceEntryRemove
   1552          
   1553                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \   000064                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000064   AC..         MOV     R4,?XSP + 0
   \   000066   AD..         MOV     R5,?XSP + 1
   \   000068   EE           MOV     A,R6
   \   000069   FA           MOV     R2,A
   \   00006A   EF           MOV     A,R7
   \   00006B   FB           MOV     R3,A
   \   00006C   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay; Banked call to: ZDSecMgrEntryLookupAMI
   \   00006F   E9           MOV     A,R1
   \   000070   7034         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1554                {
   1555                  // update NWK address
   1556                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   000072                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000072   85..82       MOV     DPL,?V2
   \   000075   85..83       MOV     DPH,?V3
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FC           MOV     R4,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   FD           MOV     R5,A
   \   00007D   EE           MOV     A,R6
   \   00007E   FA           MOV     R2,A
   \   00007F   EF           MOV     A,R7
   \   000080   FB           MOV     R3,A
   \   000081   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay; Banked call to: ZDSecMgrAddrMgrUpdate
   \   000084   8020         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1557                }
   1558              }
   1559            }
   1560            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000086                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000086   AC..         MOV     R4,?XSP + 0
   \   000088   AD..         MOV     R5,?XSP + 1
   \   00008A   EE           MOV     A,R6
   \   00008B   FA           MOV     R2,A
   \   00008C   EF           MOV     A,R7
   \   00008D   FB           MOV     R3,A
   \   00008E   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay; Banked call to: ZDSecMgrEntryLookupAMI
   \   000091   E9           MOV     A,R1
   \   000092   7012         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1561            {
   1562              // update NWK address
   1563              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   000094                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000094   85..82       MOV     DPL,?V2
   \   000097   85..83       MOV     DPH,?V3
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   FC           MOV     R4,A
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   FD           MOV     R5,A
   \   00009F   EE           MOV     A,R6
   \   0000A0   FA           MOV     R2,A
   \   0000A1   EF           MOV     A,R7
   \   0000A2   FB           MOV     R3,A
   \   0000A3   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay; Banked call to: ZDSecMgrAddrMgrUpdate
   1564            }
   1565          
   1566            // check if a new entry needs to be created
   1567            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   F8           MOV     R0,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   F9           MOV     R1,A
   \   0000B1   E8           MOV     A,R0
   \   0000B2   49           ORL     A,R1
   \   0000B3   7051         JNZ     ??ZDSecMgrDeviceEntryAdd_3
   1568            {
   1569              // get new entry
   1570              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   0000B5                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   0000B5   AA..         MOV     R2,?XSP + 0
   \   0000B7   AB..         MOV     R3,?XSP + 1
   \   0000B9   12....       LCALL   ??ZDSecMgrEntryNew?relay; Banked call to: ZDSecMgrEntryNew
   \   0000BC   E9           MOV     A,R1
   \   0000BD   7067         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   1571              {
   1572                // reset entry lkd
   1573          
   1574                // finish setting up entry
   1575                entry->ami = ami;
   \   0000BF   85..82       MOV     DPL,?XSP + 0
   \   0000C2   85..83       MOV     DPH,?XSP + 1
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   F8           MOV     R0,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F583         MOV     DPH,A
   \   0000CB   8882         MOV     DPL,R0
   \   0000CD   EE           MOV     A,R6
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   EF           MOV     A,R7
   \   0000D1   F0           MOVX    @DPTR,A
   1576          
   1577                // update NWK address
   1578                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000D2                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000D2   85..82       MOV     DPL,?V2
   \   0000D5   85..83       MOV     DPH,?V3
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   FC           MOV     R4,A
   \   0000DA   A3           INC     DPTR
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   FD           MOV     R5,A
   \   0000DD   EE           MOV     A,R6
   \   0000DE   FA           MOV     R2,A
   \   0000DF   EF           MOV     A,R7
   \   0000E0   FB           MOV     R3,A
   \   0000E1   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay; Banked call to: ZDSecMgrAddrMgrUpdate
   1579          
   1580                // enter new device into device control
   1581                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   \   0000E4   90....       MOV     DPTR,#zgDeviceLogicalType
   \   0000E7   E0           MOVX    A,@DPTR
   \   0000E8   7017         JNZ     ??ZDSecMgrDeviceEntryAdd_5
   1582                {
   1583                  status = ZDSecMgrCtrlAdd( device, entry );
   \   0000EA                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   0000EA   85..82       MOV     DPL,?XSP + 0
   \   0000ED   85..83       MOV     DPH,?XSP + 1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   FC           MOV     R4,A
   \   0000F2   A3           INC     DPTR
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FD           MOV     R5,A
   \   0000F5   AA..         MOV     R2,?V2
   \   0000F7   AB..         MOV     R3,?V3
   \   0000F9   12....       LCALL   ??ZDSecMgrCtrlAdd?relay; Banked call to: ZDSecMgrCtrlAdd
   \   0000FC   E9           MOV     A,R1
   \   0000FD   F5..         MOV     ?V0,A
   \   0000FF   8025         SJMP    ??ZDSecMgrDeviceEntryAdd_4
   1584                }
   1585                else
   1586                {
   1587                  status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   000101   75..00       MOV     ?V0,#0x0
   \   000104   8020         SJMP    ??ZDSecMgrDeviceEntryAdd_4
   1588                }
   1589              }
   1590            }
   1591            else
   1592            {
   1593              // reset entry lkd
   1594          
   1595              // reset entry in entry control
   1596              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000106   90....       MOV     DPTR,#zgDeviceLogicalType
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   7017         JNZ     ??ZDSecMgrDeviceEntryAdd_6
   1597              {
   1598                status = ZDSecMgrCtrlReset( device, entry );
   \   00010C                ; Setup parameters for call to function ZDSecMgrCtrlReset
   \   00010C   85..82       MOV     DPL,?XSP + 0
   \   00010F   85..83       MOV     DPH,?XSP + 1
   \   000112   E0           MOVX    A,@DPTR
   \   000113   FC           MOV     R4,A
   \   000114   A3           INC     DPTR
   \   000115   E0           MOVX    A,@DPTR
   \   000116   FD           MOV     R5,A
   \   000117   AA..         MOV     R2,?V2
   \   000119   AB..         MOV     R3,?V3
   \   00011B   12....       LCALL   ??ZDSecMgrCtrlReset?relay; Banked call to: ZDSecMgrCtrlReset
   \   00011E   E9           MOV     A,R1
   \   00011F   F5..         MOV     ?V0,A
   \   000121   8003         SJMP    ??ZDSecMgrDeviceEntryAdd_4
   1599              }
   1600              else
   1601              {
   1602                status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_6:
   \   000123   75..00       MOV     ?V0,#0x0
   1603              }
   1604            }
   1605          
   1606            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000126   A9..         MOV     R1,?V0
   \   000128   7402         MOV     A,#0x2
   \   00012A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012D   7F04         MOV     R7,#0x4
   \   00012F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1607          }
   1608          
   1609          /******************************************************************************
   1610           * @fn          ZDSecMgrDeviceCtrlHandler
   1611           *
   1612           * @brief       Device control handler.
   1613           *
   1614           * @param       device - [in] ZDSecMgrDevice_t, device info
   1615           *
   1616           * @return      none
   1617           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1618          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1619          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   1620            uint8 state;
   1621            uint8 cntr;
   1622          
   1623          
   1624            state = device->ctrl->state;
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F583         MOV     DPH,A
   \   00001D   8882         MOV     DPL,R0
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   FE           MOV     R6,A
   1625            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   000026   7F01         MOV     R7,#0x1
   1626          
   1627            switch ( state )
   \   000028   EE           MOV     A,R6
   \   000029   24FE         ADD     A,#-0x2
   \   00002B   600C         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   \   00002D   14           DEC     A
   \   00002E   6019         JZ      ??ZDSecMgrDeviceCtrlHandler_1
   \   000030   14           DEC     A
   \   000031   6034         JZ      ??ZDSecMgrDeviceCtrlHandler_2
   \   000033   24FD         ADD     A,#-0x3
   \   000035   6020         JZ      ??ZDSecMgrDeviceCtrlHandler_3
   \   000037   802C         SJMP    ??ZDSecMgrDeviceCtrlHandler_4
   1628            {
   1629              case ZDSECMGR_CTRL_TK_MASTER:
   1630                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000039                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000039   AA..         MOV     R2,?V0
   \   00003B   AB..         MOV     R3,?V1
   \   00003D   12....       LCALL   ??ZDSecMgrSendMasterKey?relay; Banked call to: ZDSecMgrSendMasterKey
   \   000040   E9           MOV     A,R1
   \   000041   7024         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1631                {
   1632                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000043   7E03         MOV     R6,#0x3
   1633                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   000045   7F01         MOV     R7,#0x1
   1634                }
   1635                break;
   \   000047   801E         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1636          
   1637              case ZDSECMGR_CTRL_SKKE_INIT:
   1638                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   000049                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   000049   AA..         MOV     R2,?V0
   \   00004B   AB..         MOV     R3,?V1
   \   00004D   12....       LCALL   ??ZDSecMgrEstablishKey?relay; Banked call to: ZDSecMgrEstablishKey
   \   000050   E9           MOV     A,R1
   \   000051   7014         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1639                {
   1640                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000053   7E04         MOV     R6,#0x4
   1641                }
   1642                break;
   \   000055   8010         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1643          
   1644              case ZDSECMGR_CTRL_SKKE_WAIT:
   1645                // continue to wait for SKA control timeout
   1646                break;
   1647          
   1648              case ZDSECMGR_CTRL_TK_NWK:
   1649                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000057                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000057   AA..         MOV     R2,?V0
   \   000059   AB..         MOV     R3,?V1
   \   00005B   12....       LCALL   ??ZDSecMgrSendNwkKey?relay; Banked call to: ZDSecMgrSendNwkKey
   \   00005E   E9           MOV     A,R1
   \   00005F   7006         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1650                {
   1651                  state = ZDSECMGR_CTRL_NONE;
   \   000061   7E00         MOV     R6,#0x0
   1652                }
   1653                break;
   \   000063   8002         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1654          
   1655              default:
   1656                state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000065   7E00         MOV     R6,#0x0
   1657                break;
   1658            }
   1659          
   1660            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000067   EE           MOV     A,R6
   \   000068   6056         JZ      ??ZDSecMgrDeviceCtrlHandler_5
   1661            {
   1662              device->ctrl->state = state;
   \   00006A   EE           MOV     A,R6
   \   00006B   C0E0         PUSH    A
   \   00006D   85..82       MOV     DPL,?V0
   \   000070   85..83       MOV     DPH,?V1
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F583         MOV     DPH,A
   \   000081   8882         MOV     DPL,R0
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   D0E0         POP     A
   \   00008A   F0           MOVX    @DPTR,A
   1663              device->ctrl->cntr  = cntr;
   \   00008B   EF           MOV     A,R7
   \   00008C   C0E0         PUSH    A
   \   00008E   85..82       MOV     DPL,?V0
   \   000091   85..83       MOV     DPH,?V1
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   F8           MOV     R0,A
   \   00009E   A3           INC     DPTR
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   C8           XCH     A,R0
   \   0000A1   2406         ADD     A,#0x6
   \   0000A3   F582         MOV     DPL,A
   \   0000A5   C8           XCH     A,R0
   \   0000A6   3400         ADDC    A,#0x0
   \   0000A8   F583         MOV     DPH,A
   \   0000AA   D0E0         POP     A
   \   0000AC   F0           MOVX    @DPTR,A
   1664          
   1665              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000AD                ; Setup parameters for call to function osal_start_timerEx
   \   0000AD   7C64         MOV     R4,#0x64
   \   0000AF   7D00         MOV     R5,#0x0
   \   0000B1   7A00         MOV     R2,#0x0
   \   0000B3   7B01         MOV     R3,#0x1
   \   0000B5   90....       MOV     DPTR,#ZDAppTaskID
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F9           MOV     R1,A
   \   0000BA   12....       LCALL   ??osal_start_timerEx?relay; Banked call to: osal_start_timerEx
   \   0000BD   E9           MOV     A,R1
   \   0000BE   8016         SJMP    ??ZDSecMgrDeviceCtrlHandler_6
   1666            }
   1667            else
   1668            {
   1669              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   0000C0                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   0000C0   85..82       MOV     DPL,?V0
   \   0000C3   85..83       MOV     DPH,?V1
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   FA           MOV     R2,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   FB           MOV     R3,A
   \   0000D3   12....       LCALL   ??ZDSecMgrCtrlRelease?relay; Banked call to: ZDSecMgrCtrlRelease
   1670            }
   1671          }
   \                     ??ZDSecMgrDeviceCtrlHandler_6:
   \   0000D6   7F02         MOV     R7,#0x2
   \   0000D8   02....       LJMP    ?BANKED_LEAVE_XDATA
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceCtrlSetup
   1675           *
   1676           * @brief       Setup device control.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      ZStatus_t
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1683          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1684            if ( device->ctrl != NULL )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F8           MOV     R0,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F9           MOV     R1,A
   \   00001A   E8           MOV     A,R0
   \   00001B   49           ORL     A,R1
   \   00001C   604E         JZ      ??ZDSecMgrDeviceCtrlSetup_0
   1685            {
   1686              if ( device->secure == FALSE )
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   701E         JNZ     ??ZDSecMgrDeviceCtrlSetup_1
   1687              {
   1688                // send the master key data to the joining device
   1689                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F583         MOV     DPH,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   7402         MOV     A,#0x2
   \   000046   F0           MOVX    @DPTR,A
   \   000047   801C         SJMP    ??ZDSecMgrDeviceCtrlSetup_2
   1690              }
   1691              else
   1692              {
   1693                // start SKKE
   1694                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F583         MOV     DPH,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   7403         MOV     A,#0x3
   \   000064   F0           MOVX    @DPTR,A
   1695              }
   1696          
   1697              ZDSecMgrDeviceCtrlHandler( device );
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000065                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000065   EE           MOV     A,R6
   \   000066   FA           MOV     R2,A
   \   000067   EF           MOV     A,R7
   \   000068   FB           MOV     R3,A
   \   000069   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay; Banked call to: ZDSecMgrDeviceCtrlHandler
   1698            }
   1699          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00006C   7F01         MOV     R7,#0x1
   \   00006E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1700          
   1701          /******************************************************************************
   1702           * @fn          ZDSecMgrDeviceCtrlUpdate
   1703           *
   1704           * @brief       Update control data.
   1705           *
   1706           * @param       extAddr - [in] EXT address
   1707           * @param       state   - [in] new control state
   1708           *
   1709           * @return      none
   1710           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1711          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1712          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0,R1
   1713            ZDSecMgrEntry_t* entry;
   1714            ZDSecMgrCtrl_t*  ctrl;
   1715          
   1716          
   1717            // lookup device entry data
   1718            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000010   7402         MOV     A,#0x2
   \   000012   12....       LCALL   ?XSTACK_DISP102_8
   \   000015   EE           MOV     A,R6
   \   000016   FA           MOV     R2,A
   \   000017   EF           MOV     A,R7
   \   000018   FB           MOV     R3,A
   \   000019   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay; Banked call to: ZDSecMgrEntryLookupExt
   \   00001C   E9           MOV     A,R1
   1719          
   1720            if ( entry != NULL )
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   E8           MOV     A,R0
   \   000028   49           ORL     A,R1
   \   000029   7003         JNZ     $+5
   \   00002B   02....       LJMP    ??ZDSecMgrDeviceCtrlUpdate_0 & 0xFFFF
   1721            {
   1722              // lookup device control data
   1723              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   00002E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00002E   AC..         MOV     R4,?XSP + 0
   \   000030   AD..         MOV     R5,?XSP + 1
   \   000032   7402         MOV     A,#0x2
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FA           MOV     R2,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FB           MOV     R3,A
   \   00003C   12....       LCALL   ??ZDSecMgrCtrlLookup?relay; Banked call to: ZDSecMgrCtrlLookup
   1724          
   1725              // make sure control data is valid
   1726              if ( ctrl != NULL )
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F9           MOV     R1,A
   \   00004A   E8           MOV     A,R0
   \   00004B   49           ORL     A,R1
   \   00004C   7003         JNZ     $+5
   \   00004E   02....       LJMP    ??ZDSecMgrDeviceCtrlUpdate_0 & 0xFFFF
   1727              {
   1728                // possible state transitions
   1729                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   000051   85..82       MOV     DPL,?XSP + 0
   \   000054   85..83       MOV     DPH,?XSP + 1
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F8           MOV     R0,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F583         MOV     DPH,A
   \   00005D   8882         MOV     DPL,R0
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   6404         XRL     A,#0x4
   \   000067   7068         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1730                {
   1731                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000069   7405         MOV     A,#0x5
   \   00006B   65..         XRL     A,?V0
   \   00006D   702F         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1732                  {
   1733                    // send the network key
   1734                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   E0           MOVX    A,@DPTR
   \   000076   F8           MOV     R0,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F583         MOV     DPH,A
   \   00007B   8882         MOV     DPL,R0
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   7407         MOV     A,#0x7
   \   000084   F0           MOVX    @DPTR,A
   1735                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   \   000085   85..82       MOV     DPL,?XSP + 0
   \   000088   85..83       MOV     DPH,?XSP + 1
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F8           MOV     R0,A
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   C8           XCH     A,R0
   \   000090   2406         ADD     A,#0x6
   \   000092   F582         MOV     DPL,A
   \   000094   C8           XCH     A,R0
   \   000095   3400         ADDC    A,#0x0
   \   000097   F583         MOV     DPH,A
   \   000099   7401         MOV     A,#0x1
   \   00009B   F0           MOVX    @DPTR,A
   \   00009C   8033         SJMP    ??ZDSecMgrDeviceCtrlUpdate_0
   1736                  }
   1737                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00009E   7406         MOV     A,#0x6
   \   0000A0   65..         XRL     A,?V0
   \   0000A2   702D         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1738                  {
   1739                    // force default timeout in order to cleanup control logic
   1740                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   0000A4   85..82       MOV     DPL,?XSP + 0
   \   0000A7   85..83       MOV     DPH,?XSP + 1
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F8           MOV     R0,A
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   F583         MOV     DPH,A
   \   0000B0   8882         MOV     DPL,R0
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   7406         MOV     A,#0x6
   \   0000B9   F0           MOVX    @DPTR,A
   1741                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   0000BA   85..82       MOV     DPL,?XSP + 0
   \   0000BD   85..83       MOV     DPH,?XSP + 1
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   F8           MOV     R0,A
   \   0000C2   A3           INC     DPTR
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   C8           XCH     A,R0
   \   0000C5   2406         ADD     A,#0x6
   \   0000C7   F582         MOV     DPL,A
   \   0000C9   C8           XCH     A,R0
   \   0000CA   3400         ADDC    A,#0x0
   \   0000CC   F583         MOV     DPH,A
   \   0000CE   7401         MOV     A,#0x1
   \   0000D0   F0           MOVX    @DPTR,A
   1742                  }
   1743                }
   1744                // timer should be active
   1745              }
   1746            }
   1747          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   0000D1   7404         MOV     A,#0x4
   \   0000D3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D6   7F01         MOV     R7,#0x1
   \   0000D8   02....       LJMP    ?BANKED_LEAVE_XDATA
   1748          
   1749          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1750          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1751          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   1752            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   \   00000B   90....       MOV     DPTR,#zgDeviceLogicalType
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   700F         JNZ     ??APSME_SKA_TimerExpired_0
   1753            {
   1754              if ( initiator == TRUE )
   \   000011   7401         MOV     A,#0x1
   \   000013   65..         XRL     A,?V0
   \   000015   7009         JNZ     ??APSME_SKA_TimerExpired_0
   1755              {
   1756                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   \   000017                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   000017   7906         MOV     R1,#0x6
   \   000019   EE           MOV     A,R6
   \   00001A   FA           MOV     R2,A
   \   00001B   EF           MOV     A,R7
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   ??ZDSecMgrDeviceCtrlUpdate?relay; Banked call to: ZDSecMgrDeviceCtrlUpdate
   1757              }
   1758            }
   1759          }
   \                     ??APSME_SKA_TimerExpired_0:
   \   000020   7F01         MOV     R7,#0x1
   \   000022   02....       LJMP    ?BANKED_LEAVE_XDATA
   1760          
   1761          /******************************************************************************
   1762           * @fn          ZDSecMgrDeviceRemove
   1763           *
   1764           * @brief       Remove device from network.
   1765           *
   1766           * @param       device - [in] ZDSecMgrDevice_t, device info
   1767           *
   1768           * @return      none
   1769           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1770          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1771          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1772            APSME_RemoveDeviceReq_t remDevReq;
   1773            NLME_LeaveReq_t         leaveReq;
   1774            associated_devices_t*   assoc;
   1775          
   1776          
   1777            // check if parent, remove the device
   1778            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   ??NLME_GetShortAddr?relay; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV     ?V2,R2
   \   000013   8B..         MOV     ?V3,R3
   \   000015   A8..         MOV     R0,?V2
   \   000017   A9..         MOV     R1,?V3
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   68           XRL     A,R0
   \   000023   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??ZDSecMgrDeviceRemove_1 & 0xFFFF
   1779            {
   1780              // this is the parent of the device
   1781              leaveReq.extAddr        = device->extAddr;
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E8           MOV     A,R0
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   E9           MOV     A,R1
   \   000042   F0           MOVX    @DPTR,A
   1782              leaveReq.removeChildren = FALSE;
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   7400         MOV     A,#0x0
   \   00004A   F0           MOVX    @DPTR,A
   1783              leaveReq.rejoin         = FALSE;
   \   00004B   7403         MOV     A,#0x3
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   7400         MOV     A,#0x0
   \   000052   F0           MOVX    @DPTR,A
   1784          
   1785              // find child association
   1786              assoc = AssocGetWithExt( device->extAddr );
   \   000053                ; Setup parameters for call to function AssocGetWithExt
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   FA           MOV     R2,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   FB           MOV     R3,A
   \   00005E   12....       LCALL   ??AssocGetWithExt?relay; Banked call to: AssocGetWithExt
   \   000061   8A..         MOV     ?V2,R2
   \   000063   8B..         MOV     ?V3,R3
   \   000065   85....       MOV     ?V0,?V2
   \   000068   85....       MOV     ?V1,?V3
   1787          
   1788              if ( ( assoc != NULL                            ) &&
   1789                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1790                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00006B   E5..         MOV     A,?V0
   \   00006D   45..         ORL     A,?V1
   \   00006F   607E         JZ      ??ZDSecMgrDeviceRemove_2
   \   000071   85..82       MOV     DPL,?V0
   \   000074   85..83       MOV     DPH,?V1
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   6071         JZ      ??ZDSecMgrDeviceRemove_2
   \   00007E   85..82       MOV     DPL,?V0
   \   000081   85..83       MOV     DPH,?V1
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   C3           CLR     C
   \   00008A   9405         SUBB    A,#0x5
   \   00008C   5061         JNC     ??ZDSecMgrDeviceRemove_2
   1791              {
   1792                // check if associated device is authenticated
   1793                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00008E   85..82       MOV     DPL,?V0
   \   000091   85..83       MOV     DPH,?V1
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   A2E3         MOV     C,0xE0 /* A   */.3
   \   00009C   500A         JNC     ??ZDSecMgrDeviceRemove_3
   1794                {
   1795                  leaveReq.silent = FALSE;
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   7400         MOV     A,#0x0
   \   0000A5   F0           MOVX    @DPTR,A
   \   0000A6   8008         SJMP    ??ZDSecMgrDeviceRemove_4
   1796                }
   1797                else
   1798                {
   1799                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000A8   7404         MOV     A,#0x4
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   7401         MOV     A,#0x1
   \   0000AF   F0           MOVX    @DPTR,A
   1800                }
   1801          
   1802                NLME_LeaveReq( &leaveReq );
   \                     ??ZDSecMgrDeviceRemove_4:
   \   0000B0                ; Setup parameters for call to function NLME_LeaveReq
   \   0000B0   AA..         MOV     R2,?XSP + 0
   \   0000B2   AB..         MOV     R3,?XSP + 1
   \   0000B4   12....       LCALL   ??NLME_LeaveReq?relay; Banked call to: NLME_LeaveReq
   \   0000B7   E9           MOV     A,R1
   \   0000B8   8035         SJMP    ??ZDSecMgrDeviceRemove_2
   1803              }
   1804            }
   1805            else
   1806            {
   1807              // this is not the parent of the device
   1808              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000BA   8E82         MOV     DPL,R6
   \   0000BC   8F83         MOV     DPH,R7
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F8           MOV     R0,A
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   F9           MOV     R1,A
   \   0000C7   7405         MOV     A,#0x5
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   E8           MOV     A,R0
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   E9           MOV     A,R1
   \   0000D0   F0           MOVX    @DPTR,A
   1809              remDevReq.childExtAddr = device->extAddr;
   \   0000D1   8E82         MOV     DPL,R6
   \   0000D3   8F83         MOV     DPH,R7
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   F8           MOV     R0,A
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F9           MOV     R1,A
   \   0000DC   7407         MOV     A,#0x7
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   E8           MOV     A,R0
   \   0000E2   F0           MOVX    @DPTR,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   E9           MOV     A,R1
   \   0000E5   F0           MOVX    @DPTR,A
   1810          
   1811              APSME_RemoveDeviceReq( &remDevReq );
   \   0000E6                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000E6   7405         MOV     A,#0x5
   \   0000E8   12....       LCALL   ?XSTACK_DISP101_8
   \   0000EB   12....       LCALL   ??APSME_RemoveDeviceReq?relay; Banked call to: APSME_RemoveDeviceReq
   \   0000EE   E9           MOV     A,R1
   1812            }
   1813          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000EF   7409         MOV     A,#0x9
   \   0000F1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F4   7F04         MOV     R7,#0x4
   \   0000F6   02....       LJMP    ?BANKED_LEAVE_XDATA
   1814          
   1815          /******************************************************************************
   1816           * @fn          ZDSecMgrDeviceValidateSKKE
   1817           *
   1818           * @brief       Decide whether device is allowed for SKKE.
   1819           *
   1820           * @param       device - [in] ZDSecMgrDevice_t, device info
   1821           *
   1822           * @return      ZStatus_t
   1823           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1824          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1825          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1826            ZStatus_t status;
   1827            uint16 ami;
   1828            uint16 keyNvId;
   1829          
   1830          
   1831            // get EXT address
   1832            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   8E82         MOV     DPL,R6
   \   000014   8F83         MOV     DPH,R7
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FA           MOV     R2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay; Banked call to: ZDSecMgrExtAddrLookup
   \   000020   E9           MOV     A,R1
   \   000021   F5..         MOV     ?V0,A
   1833          
   1834            if ( status == ZSuccess )
   \   000023   E5..         MOV     A,?V0
   \   000025   702F         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1835            {
   1836              // get MASTER key
   1837              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   \   000027                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP102_8
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FA           MOV     R2,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FB           MOV     R3,A
   \   000037   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay; Banked call to: ZDSecMgrMasterKeyLookup
   \   00003A   E9           MOV     A,R1
   \   00003B   F5..         MOV     ?V0,A
   1838          
   1839              if ( status == ZSuccess )
   \   00003D   E5..         MOV     A,?V0
   \   00003F   7015         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1840              {
   1841                status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000041                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000041   85..82       MOV     DPL,?XSP + 0
   \   000044   85..83       MOV     DPH,?XSP + 1
   \   000047   E0           MOVX    A,@DPTR
   \   000048   FC           MOV     R4,A
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   FD           MOV     R5,A
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay; Banked call to: ZDSecMgrDeviceEntryAdd
   \   000053   E9           MOV     A,R1
   \   000054   F5..         MOV     ?V0,A
   1842              }
   1843            }
   1844          
   1845            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000056   A9..         MOV     R1,?V0
   \   000058   7404         MOV     A,#0x4
   \   00005A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005D   7F01         MOV     R7,#0x1
   \   00005F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1846          }
   1847          
   1848          /******************************************************************************
   1849           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1850           *
   1851           * @brief       Decide whether device is allowed.
   1852           *
   1853           * @param       device - [in] ZDSecMgrDevice_t, device info
   1854           *
   1855           * @return      ZStatus_t
   1856           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1857          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1858          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1859          
   1860            ZStatus_t status;
   1861            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1862          
   1863            (void)device;  // Intentionally unreferenced parameter
   1864            
   1865            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1866            // the trust center to reject any newly joining devices by sending
   1867            // Remove-device to the parents.
   1868            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1869            {
   1870              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1871            }
   1872          
   1873          
   1874          
   1875          #if 0  // Taken out because the following functionality is only used for test
   1876                 // purpose. A more efficient (above) way is used. It can be put
   1877                 // back in if customers request for a white/black list feature.
   1878                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1879          
   1880            // The following code processes the device black list (stored device list)
   1881            // If the joining device is not part of the forbidden device list
   1882            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1883            // will send Remove-device and ban the device from joining.
   1884          
   1885            uint8     index;
   1886            uint8*    restricted;
   1887          
   1888            // Look through the stored device list - used for restricted devices
   1889            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1890            {
   1891              restricted = ZDSecMgrStoredDeviceList[index];
   1892          
   1893              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1894              {
   1895                // return as unknown device in regards to validation
   1896                status = ZNwkUnknownDevice;
   1897          
   1898                // break from loop
   1899                index = ZDSECMGR_STORED_DEVICES;
   1900              }
   1901            }
   1902          
   1903          #endif
   1904          
   1905            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
   1906          }
   1907          
   1908          /******************************************************************************
   1909           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1910           *
   1911           * @brief       Decide whether device is allowed.
   1912           *
   1913           * @param       device - [in] ZDSecMgrDevice_t, device info
   1914           *
   1915           * @return      ZStatus_t
   1916           */
   1917          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1918          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1919          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   1920            ZStatus_t status;
   1921            uint16    ami;
   1922            uint8     key[SEC_KEY_LEN];
   1923          
   1924          
   1925            // implement EXT address and MASTER key policy here -- the total number of
   1926            // Security Manager entries should never exceed the number of EXT addresses
   1927            // and MASTER keys available
   1928            
   1929            // set status based on policy
   1930            //status = ZNwkUnknownDevice;
   1931            
   1932            // set status based on policy
   1933            status = ZSuccess; // ZNwkUnknownDevice;
   \   00000E   7E00         MOV     R6,#0x0
   1934            
   1935            // get key based on policy
   1936            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000010                ; Setup parameters for call to function osal_memcpy
   \   000010   75....       MOV     ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000013   75....       MOV     ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000016   75..80       MOV     ?V2,#-0x80
   \   000019   78..         MOV     R0,#?V0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00001E   7C10         MOV     R4,#0x10
   \   000020   7D00         MOV     R5,#0x0
   \   000022   7405         MOV     A,#0x5
   \   000024   12....       LCALL   ?XSTACK_DISP101_8
   \   000027   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00002A   7403         MOV     A,#0x3
   \   00002C   12....       LCALL   ?DEALLOC_XSTACK8
   1937            
   1938            // if policy, store new EXT address
   1939            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00002F                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00002F   A8..         MOV     R0,?XSP + 0
   \   000031   A9..         MOV     R1,?XSP + 1
   \   000033   88..         MOV     ?V0,R0
   \   000035   89..         MOV     ?V1,R1
   \   000037   78..         MOV     R0,#?V0
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   85..82       MOV     DPL,?V4
   \   00003F   85..83       MOV     DPH,?V5
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   FC           MOV     R4,A
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   FD           MOV     R5,A
   \   000049   85..82       MOV     DPL,?V4
   \   00004C   85..83       MOV     DPH,?V5
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FA           MOV     R2,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FB           MOV     R3,A
   \   000054   12....       LCALL   ??ZDSecMgrAddrStore?relay; Banked call to: ZDSecMgrAddrStore
   \   000057   7402         MOV     A,#0x2
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   E9           MOV     A,R1
   \   00005D   FE           MOV     R6,A
   1940            
   1941            // set the key
   1942            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   00005E                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   00005E   7402         MOV     A,#0x2
   \   000060   12....       LCALL   ?XSTACK_DISP102_8
   \   000063   85..82       MOV     DPL,?V4
   \   000066   85..83       MOV     DPH,?V5
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   FA           MOV     R2,A
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   FB           MOV     R3,A
   \   000070   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay; Banked call to: ZDSecMgrMasterKeyLoad
   \   000073   E9           MOV     A,R1
   1943            
   1944            // if EXT address and MASTER key available -- add device
   1945            if ( status == ZSuccess )
   \   000074   EE           MOV     A,R6
   \   000075   7014         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1946            {
   1947              // add device to internal data - with control
   1948              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000077                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000077   85..82       MOV     DPL,?XSP + 0
   \   00007A   85..83       MOV     DPH,?XSP + 1
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   FC           MOV     R4,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   FD           MOV     R5,A
   \   000082   AA..         MOV     R2,?V4
   \   000084   AB..         MOV     R3,?V5
   \   000086   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay; Banked call to: ZDSecMgrDeviceEntryAdd
   \   000089   E9           MOV     A,R1
   \   00008A   FE           MOV     R6,A
   1949            }
   1950          
   1951            // remove copy of key in RAM  
   1952            osal_memset( key, 0x00, SEC_KEY_LEN );
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   00008B                ; Setup parameters for call to function osal_memset
   \   00008B   7C10         MOV     R4,#0x10
   \   00008D   7D00         MOV     R5,#0x0
   \   00008F   7900         MOV     R1,#0x0
   \   000091   7402         MOV     A,#0x2
   \   000093   12....       LCALL   ?XSTACK_DISP101_8
   \   000096   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1953          
   1954            return status;
   \   000099   EE           MOV     A,R6
   \   00009A   F9           MOV     R1,A
   \   00009B   7412         MOV     A,#0x12
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A0   7F06         MOV     R7,#0x6
   \   0000A2   02....       LJMP    ?BANKED_LEAVE_XDATA
   1955          }
   1956          
   1957          /******************************************************************************
   1958           * @fn          ZDSecMgrDeviceValidate
   1959           *
   1960           * @brief       Decide whether device is allowed.
   1961           *
   1962           * @param       device - [in] ZDSecMgrDevice_t, device info
   1963           *
   1964           * @return      ZStatus_t
   1965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1966          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1967          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1968            ZStatus_t status;
   1969          
   1970          
   1971            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000009   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7030         JNZ     ??ZDSecMgrDeviceValidate_0
   1972            {
   1973              // device may be joining with a secure flag but it is ultimately the Trust
   1974              // Center that decides -- check if expected pre configured device --
   1975              // override settings
   1976              if ( zgPreConfigKeys == TRUE )
   \   000011   90....       MOV     DPTR,#zgPreConfigKeys
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6401         XRL     A,#0x1
   \   000017   700F         JNZ     ??ZDSecMgrDeviceValidate_1
   1977              {
   1978                device->secure = TRUE;
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   7401         MOV     A,#0x1
   \   000025   F0           MOVX    @DPTR,A
   \   000026   800D         SJMP    ??ZDSecMgrDeviceValidate_2
   1979              }
   1980              else
   1981              {
   1982                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   7400         MOV     A,#0x0
   \   000034   F0           MOVX    @DPTR,A
   1983              }
   1984          
   1985              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1986              {
   1987                status = ZDSecMgrDeviceValidateCM( device );
   1988              }
   1989              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1990              {
   1991                status = ZDSecMgrDeviceValidateRM( device );
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000035                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000035   EE           MOV     A,R6
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay; Banked call to: ZDSecMgrDeviceValidateRM
   \   00003C   E9           MOV     A,R1
   \   00003D   F5..         MOV     ?V0,A
   \   00003F   8003         SJMP    ??ZDSecMgrDeviceValidate_3
   1992              }
   1993            }
   1994            else
   1995            {
   1996              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   000041   75..C8       MOV     ?V0,#-0x38
   1997            }
   1998          
   1999            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   000044   A9..         MOV     R1,?V0
   \   000046   7F01         MOV     R7,#0x1
   \   000048   02....       LJMP    ?BANKED_LEAVE_XDATA
   2000          }
   2001          
   2002          /******************************************************************************
   2003           * @fn          ZDSecMgrDeviceJoin
   2004           *
   2005           * @brief       Try to join this device.
   2006           *
   2007           * @param       device - [in] ZDSecMgrDevice_t, device info
   2008           *
   2009           * @return      ZStatus_t
   2010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2011          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2012          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2013            ZStatus_t status;
   2014            uint16    ami;
   2015          
   2016            // attempt to validate device
   2017            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   EE           MOV     A,R6
   \   00000F   FA           MOV     R2,A
   \   000010   EF           MOV     A,R7
   \   000011   FB           MOV     R3,A
   \   000012   12....       LCALL   ??ZDSecMgrDeviceValidate?relay; Banked call to: ZDSecMgrDeviceValidate
   \   000015   E9           MOV     A,R1
   \   000016   F5..         MOV     ?V0,A
   2018          
   2019            if ( status == ZSuccess )
   \   000018   E5..         MOV     A,?V0
   \   00001A   7036         JNZ     ??ZDSecMgrDeviceJoin_0
   2020            {
   2021              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2022              {
   2023                ZDSecMgrDeviceCtrlSetup( device );
   2024              }
   2025              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2026              {
   2027                // Add the device to the address manager
   2028                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00001C                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001C   A8..         MOV     R0,?XSP + 0
   \   00001E   A9..         MOV     R1,?XSP + 1
   \   000020   88..         MOV     ?V2,R0
   \   000022   89..         MOV     ?V3,R1
   \   000024   78..         MOV     R0,#?V2
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FC           MOV     R4,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FD           MOV     R5,A
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??ZDSecMgrAddrStore?relay; Banked call to: ZDSecMgrAddrStore
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   E9           MOV     A,R1
   2029                //send the nwk key data to the joining device
   2030                status = ZDSecMgrSendNwkKey( device );
   \   000046                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000046   EE           MOV     A,R6
   \   000047   FA           MOV     R2,A
   \   000048   EF           MOV     A,R7
   \   000049   FB           MOV     R3,A
   \   00004A   12....       LCALL   ??ZDSecMgrSendNwkKey?relay; Banked call to: ZDSecMgrSendNwkKey
   \   00004D   E9           MOV     A,R1
   \   00004E   F5..         MOV     ?V0,A
   \   000050   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2031              }
   2032            }
   2033            else
   2034            {
   2035              // not allowed, remove the device
   2036              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000052                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000052   EE           MOV     A,R6
   \   000053   FA           MOV     R2,A
   \   000054   EF           MOV     A,R7
   \   000055   FB           MOV     R3,A
   \   000056   12....       LCALL   ??ZDSecMgrDeviceRemove?relay; Banked call to: ZDSecMgrDeviceRemove
   2037            }
   2038          
   2039            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000059   A9..         MOV     R1,?V0
   \   00005B   7402         MOV     A,#0x2
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   7F04         MOV     R7,#0x4
   \   000062   02....       LJMP    ?BANKED_LEAVE_XDATA
   2040          }
   2041          
   2042          /******************************************************************************
   2043           * @fn          ZDSecMgrDeviceJoinDirect
   2044           *
   2045           * @brief       Try to join this device as a direct child.
   2046           *
   2047           * @param       device - [in] ZDSecMgrDevice_t, device info
   2048           *
   2049           * @return      ZStatus_t
   2050           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2051          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2052          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2053            ZStatus_t status;
   2054          
   2055            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??ZDSecMgrDeviceJoin?relay; Banked call to: ZDSecMgrDeviceJoin
   \   000010   E9           MOV     A,R1
   \   000011   F5..         MOV     ?V0,A
   2056          
   2057            if ( status == ZSuccess )
   \   000013   E5..         MOV     A,?V0
   \   000015   700F         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2058            {
   2059              // set association status to authenticated
   2060              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000017                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000017                ; Setup parameters for call to function AssocGetWithShort
   \   000017   8E82         MOV     DPL,R6
   \   000019   8F83         MOV     DPH,R7
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FA           MOV     R2,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??AssocGetWithShort?relay; Banked call to: AssocGetWithShort
   \   000023   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay; Banked call to: ZDSecMgrAssocDeviceAuth
   2061            }
   2062          
   2063            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   000026   A9..         MOV     R1,?V0
   \   000028   7F01         MOV     R7,#0x1
   \   00002A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2064          }
   2065          
   2066          /******************************************************************************
   2067           * @fn          ZDSecMgrDeviceJoinFwd
   2068           *
   2069           * @brief       Forward join to Trust Center.
   2070           *
   2071           * @param       device - [in] ZDSecMgrDevice_t, device info
   2072           *
   2073           * @return      ZStatus_t
   2074           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2075          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2076          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2077            ZStatus_t               status;
   2078            APSME_UpdateDeviceReq_t req;
   2079          
   2080          
   2081            // forward any joining device to the Trust Center -- the Trust Center will
   2082            // decide if the device is allowed to join
   2083            status = ZSuccess;
   \   00000E   75..00       MOV     ?V0,#0x0
   2084          
   2085            // forward authorization to the Trust Center
   2086            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   7400         MOV     A,#0x0
   \   00001D   F0           MOVX    @DPTR,A
   2087            req.devAddr    = device->nwkAddr;
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E8           MOV     A,R0
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   E9           MOV     A,R1
   \   000030   F0           MOVX    @DPTR,A
   2088            req.devExtAddr = device->extAddr;
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E8           MOV     A,R0
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   E9           MOV     A,R1
   \   000045   F0           MOVX    @DPTR,A
   2089          
   2090            // set security status, option for router to reject if policy set
   2091            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   A2E7         MOV     C,0xE0 /* A   */.7
   \   000054   503D         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2092            {
   2093              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   A2E6         MOV     C,0xE0 /* A   */.6
   \   000064   5023         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2094              {
   2095                if ( device->secure == TRUE )
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6401         XRL     A,#0x1
   \   000073   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2096                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000075   7406         MOV     A,#0x6
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   7404         MOV     A,#0x4
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   804F         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2097                else
   2098                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00007F   7406         MOV     A,#0x6
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   7407         MOV     A,#0x7
   \   000086   F0           MOVX    @DPTR,A
   \   000087   8045         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2099              }
   2100              else
   2101                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000089   7406         MOV     A,#0x6
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   7405         MOV     A,#0x5
   \   000090   F0           MOVX    @DPTR,A
   \   000091   803B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2102            }
   2103            else
   2104            {
   2105              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   A2E6         MOV     C,0xE0 /* A   */.6
   \   0000A1   5023         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2106              {
   2107                if ( device->secure == TRUE )
   \   0000A3   8E82         MOV     DPL,R6
   \   0000A5   8F83         MOV     DPH,R7
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   6401         XRL     A,#0x1
   \   0000B0   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2108                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   0000B2   7406         MOV     A,#0x6
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   7400         MOV     A,#0x0
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   8012         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2109                else
   2110                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   0000BC   7406         MOV     A,#0x6
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   7403         MOV     A,#0x3
   \   0000C3   F0           MOVX    @DPTR,A
   \   0000C4   8008         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2111              }
   2112              else
   2113                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   0000C6   7406         MOV     A,#0x6
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   F0           MOVX    @DPTR,A
   2114            }
   2115          
   2116            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2117              req.apsSecure = TRUE;
   2118            else
   2119              req.apsSecure = FALSE;
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   0000CE   7407         MOV     A,#0x7
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   7400         MOV     A,#0x0
   \   0000D5   F0           MOVX    @DPTR,A
   2120          
   2121            // send and APSME_UPDATE_DEVICE request to the trust center
   2122            status = APSME_UpdateDeviceReq( &req );
   \   0000D6                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000D6   AA..         MOV     R2,?XSP + 0
   \   0000D8   AB..         MOV     R3,?XSP + 1
   \   0000DA   12....       LCALL   ??APSME_UpdateDeviceReq?relay; Banked call to: APSME_UpdateDeviceReq
   \   0000DD   E9           MOV     A,R1
   \   0000DE   F5..         MOV     ?V0,A
   2123          
   2124            return status;
   \   0000E0   A9..         MOV     R1,?V0
   \   0000E2   7408         MOV     A,#0x8
   \   0000E4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E7   7F01         MOV     R7,#0x1
   \   0000E9   02....       LJMP    ?BANKED_LEAVE_XDATA
   2125          }
   2126          
   2127          /******************************************************************************
   2128           * @fn          ZDSecMgrDeviceNew
   2129           *
   2130           * @brief       Process a new device.
   2131           *
   2132           * @param       device - [in] ZDSecMgrDevice_t, device info
   2133           *
   2134           * @return      ZStatus_t
   2135           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2136          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2137          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2138            ZStatus_t status;
   2139          
   2140            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   \   000009   90....       MOV     DPTR,#zgDeviceLogicalType
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   700C         JNZ     ??ZDSecMgrDeviceNew_0
   2141            {
   2142              // try to join this device
   2143              status = ZDSecMgrDeviceJoinDirect( joiner );
   \   00000F                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??ZDSecMgrDeviceJoinDirect?relay; Banked call to: ZDSecMgrDeviceJoinDirect
   \   000016   E9           MOV     A,R1
   \   000017   F5..         MOV     ?V0,A
   \   000019   800A         SJMP    ??ZDSecMgrDeviceNew_1
   2144            }
   2145            else
   2146            {
   2147              status = ZDSecMgrDeviceJoinFwd( joiner );
   \                     ??ZDSecMgrDeviceNew_0:
   \   00001B                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   00001B   EE           MOV     A,R6
   \   00001C   FA           MOV     R2,A
   \   00001D   EF           MOV     A,R7
   \   00001E   FB           MOV     R3,A
   \   00001F   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay; Banked call to: ZDSecMgrDeviceJoinFwd
   \   000022   E9           MOV     A,R1
   \   000023   F5..         MOV     ?V0,A
   2148            }
   2149          
   2150            return status;
   \                     ??ZDSecMgrDeviceNew_1:
   \   000025   A9..         MOV     R1,?V0
   \   000027   7F01         MOV     R7,#0x1
   \   000029   02....       LJMP    ?BANKED_LEAVE_XDATA
   2151          }
   2152          
   2153          /******************************************************************************
   2154           * @fn          ZDSecMgrAssocDeviceAuth
   2155           *
   2156           * @brief       Set associated device status to authenticated
   2157           *
   2158           * @param       assoc - [in, out] associated_devices_t
   2159           *
   2160           * @return      none
   2161           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2162          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2163          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2164            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   2165            {
   2166              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   2167            }
   2168          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrAuthInitiate
   2172           *
   2173           * @brief       Initiate entity authentication
   2174           *
   2175           * @param       responder - [in] responder EXT address
   2176           *
   2177           * @return      none
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2180          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2181            APSME_AuthenticateReq_t req;
   2182          
   2183          
   2184            // make sure NWK address is available
   2185            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   FA           MOV     R2,A
   \   000014   EF           MOV     A,R7
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   ??APSME_LookupNwkAddr?relay; Banked call to: APSME_LookupNwkAddr
   \   000019   E9           MOV     A,R1
   \   00001A   6026         JZ      ??ZDSecMgrAuthInitiate_0
   2186            {
   2187              // set request fields
   2188              req.extAddr   = responder;
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   EE           MOV     A,R6
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   EF           MOV     A,R7
   \   000025   F0           MOVX    @DPTR,A
   2189              req.action    = APSME_EA_INITIATE;
   \   000026   7406         MOV     A,#0x6
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   7400         MOV     A,#0x0
   \   00002D   F0           MOVX    @DPTR,A
   2190              req.challenge = NULL;
   \   00002E   7404         MOV     A,#0x4
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   7400         MOV     A,#0x0
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   7400         MOV     A,#0x0
   \   000039   F0           MOVX    @DPTR,A
   2191          
   2192              // start EA processing
   2193              APSME_AuthenticateReq( &req );
   \   00003A                ; Setup parameters for call to function APSME_AuthenticateReq
   \   00003A   AA..         MOV     R2,?XSP + 0
   \   00003C   AB..         MOV     R3,?XSP + 1
   \   00003E   12....       LCALL   ??APSME_AuthenticateReq?relay; Banked call to: APSME_AuthenticateReq
   \   000041   E9           MOV     A,R1
   2194            }
   2195          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000042   7407         MOV     A,#0x7
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   \   000047   7F01         MOV     R7,#0x1
   \   000049   02....       LJMP    ?BANKED_LEAVE_XDATA
   2196          
   2197          /******************************************************************************
   2198           * @fn          ZDSecMgrAuthNwkKey
   2199           *
   2200           * @brief       Handle next step in authentication process
   2201           *
   2202           * @param       none
   2203           *
   2204           * @return      none
   2205           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2206          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2207          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2208            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700D         JNZ     ??ZDSecMgrAuthNwkKey_0
   2209            {
   2210              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2211              {
   2212                uint8 parent[Z_EXTADDR_LEN];
   2213          
   2214                // get parent's EXT address
   2215                NLME_GetCoordExtAddr( parent );
   2216          
   2217                // begin entity authentication with parent
   2218                ZDSecMgrAuthInitiate( parent );
   2219              }
   2220              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2221              {
   2222                // inform ZDO that device has been authenticated
   2223                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay; Banked call to: osal_set_event
   \   000018   E9           MOV     A,R1
   2224              }
   2225            }
   2226          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000019   D083         POP     DPH
   \   00001B   D082         POP     DPL
   \   00001D   02....       LJMP    ?BRET
   2227          
   2228          /******************************************************************************
   2229           * PUBLIC FUNCTIONS
   2230           */
   2231          /******************************************************************************
   2232           * @fn          ZDSecMgrInit
   2233           *
   2234           * @brief       Initialize ZigBee Device Security Manager.
   2235           *
   2236           * @param       state - device initialization state
   2237           *
   2238           * @return      none
   2239           */
   2240          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2241          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2242          void ZDSecMgrAddrMgrCB( uint8           update,
   2243                                  AddrMgrEntry_t* newEntry,
   2244                                  AddrMgrEntry_t* oldEntry )
   2245          {
   2246            (void)update;
   2247            (void)newEntry;
   2248            (void)oldEntry;
   2249          }
   2250          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2251          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2252          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   2253          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2254            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2255                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2256            {
   2257              // initialize sub modules
   2258              ZDSecMgrEntryInit(state);
   2259          
   2260              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2261              {
   2262                ZDSecMgrCtrlInit();
   2263              }
   2264          
   2265              // register with Address Manager
   2266              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2267              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2268              #endif
   2269            }
   2270          
   2271            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2272            {
   2273              // configure SKA slot data
   2274              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2275            }
   2276            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2277            {
   2278              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2279            }
   2280          
   2281            if ( ZG_SECURE_ENABLED )
   2282            {
   2283              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2284              {
   2285                // setup joining permissions
   2286                ZDSecMgrPermitJoiningEnabled = TRUE;
   2287                ZDSecMgrPermitJoiningTimed   = FALSE;
   2288              }
   2289            }
   2290          
   2291            
   2292            // configure security based on security mode and type of device
   2293            ZDSecMgrConfig();
   \   000007                ; Setup parameters for call to function ZDSecMgrConfig
   \   000007   12....       LCALL   ??ZDSecMgrConfig?relay; Banked call to: ZDSecMgrConfig
   2294          }
   \   00000A   7F01         MOV     R7,#0x1
   \   00000C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2295          
   2296          /******************************************************************************
   2297           * @fn          ZDSecMgrConfig
   2298           *
   2299           * @brief       Configure ZigBee Device Security Manager.
   2300           *
   2301           * @param       none
   2302           *
   2303           * @return      none
   2304           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2305          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   2306          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2307            if ( ZG_SECURE_ENABLED )
   2308            {
   2309              SSP_Init();
   2310          
   2311              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2312                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2313              {
   2314                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2315                {
   2316                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2317                  APSME_SecurityCM_CD();
   2318                }
   2319                else if ( ZSTACK_ROUTER_BUILD )
   2320                {
   2321                  // COMMERCIAL MODE - ROUTER DEVICE
   2322                  APSME_SecurityCM_RD();
   2323                }
   2324                else
   2325                {
   2326                  // COMMERCIAL MODE - END DEVICE
   2327                  APSME_SecurityCM_ED();
   2328                }
   2329              }
   2330              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2331              {
   2332                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2333                {
   2334                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2335                  APSME_SecurityRM_CD();
   2336                }
   2337                else if ( ZSTACK_ROUTER_BUILD )
   2338                {
   2339                  // RESIDENTIAL MODE - ROUTER DEVICE
   2340                  APSME_SecurityRM_RD();
   2341                }
   2342                else
   2343                {
   2344                  // RESIDENTIAL MODE - END DEVICE
   2345                  APSME_SecurityRM_ED();
   2346                }
   2347              }
   2348            }
   2349            else
   2350            {
   2351              // NO SECURITY
   2352              APSME_SecurityNM();
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay; Banked call to: APSME_SecurityNM
   2353            }
   2354          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2355          
   2356          /******************************************************************************
   2357           * @fn          ZDSecMgrPermitJoining
   2358           *
   2359           * @brief       Process request to change joining permissions.
   2360           *
   2361           * @param       duration - [in] timed duration for join in seconds
   2362           *                         - 0x00 not allowed
   2363           *                         - 0xFF allowed without timeout
   2364           *
   2365           * @return      uint8 - success(TRUE:FALSE)
   2366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2367          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2368          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2369            uint8 accept;
   2370          
   2371          
   2372            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   7400         MOV     A,#0x0
   \   00000B   F0           MOVX    @DPTR,A
   2373          
   2374            if ( duration > 0 )
   \   00000C   E8           MOV     A,R0
   \   00000D   6013         JZ      ??ZDSecMgrPermitJoining_0
   2375            {
   2376              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00000F   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000012   7401         MOV     A,#0x1
   \   000014   F0           MOVX    @DPTR,A
   2377          
   2378              if ( duration != 0xFF )
   \   000015   74FF         MOV     A,#-0x1
   \   000017   68           XRL     A,R0
   \   000018   600E         JZ      ??ZDSecMgrPermitJoining_1
   2379              {
   2380                ZDSecMgrPermitJoiningTimed = TRUE;
   \   00001A   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001D   7401         MOV     A,#0x1
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   8006         SJMP    ??ZDSecMgrPermitJoining_1
   2381              }
   2382            }
   2383            else
   2384            {
   2385              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000022   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000025   7400         MOV     A,#0x0
   \   000027   F0           MOVX    @DPTR,A
   2386            }
   2387          
   2388            accept = TRUE;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000028   7901         MOV     R1,#0x1
   2389          
   2390            return accept;
   \   00002A   D083         POP     DPH
   \   00002C   D082         POP     DPL
   \   00002E   02....       LJMP    ?BRET
   2391          }
   2392          
   2393          /******************************************************************************
   2394           * @fn          ZDSecMgrPermitJoiningTimeout
   2395           *
   2396           * @brief       Process permit joining timeout
   2397           *
   2398           * @param       none
   2399           *
   2400           * @return      none
   2401           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2402          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2403          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2404            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   700C         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2405            {
   2406              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   7400         MOV     A,#0x0
   \   000011   F0           MOVX    @DPTR,A
   2407              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000012   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000015   7400         MOV     A,#0x0
   \   000017   F0           MOVX    @DPTR,A
   2408            }
   2409          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000018   D083         POP     DPH
   \   00001A   D082         POP     DPL
   \   00001C   02....       LJMP    ?BRET
   2410          
   2411          /******************************************************************************
   2412           * @fn          ZDSecMgrNewDeviceEvent
   2413           *
   2414           * @brief       Process a the new device event, if found reset new device
   2415           *              event/timer.
   2416           *
   2417           * @param       none
   2418           *
   2419           * @return      uint8 - found(TRUE:FALSE)
   2420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2421          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2422          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2423            uint8                 found;
   2424            ZDSecMgrDevice_t      device;
   2425            AddrMgrEntry_t        addrEntry;
   2426            associated_devices_t* assoc;
   2427            ZStatus_t             status;
   2428          
   2429            // initialize return results
   2430            found = FALSE;
   \   00000A   75..00       MOV     ?V0,#0x0
   2431          
   2432            // look for device in the security init state
   2433            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay; Banked call to: AssocMatchDeviceStatus
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   AE..         MOV     R6,?V2
   \   000018   AF..         MOV     R7,?V3
   2434          
   2435            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2436            {
   2437              // device found
   2438              found = TRUE;
   \   000021   75..01       MOV     ?V0,#0x1
   2439          
   2440              // check for preconfigured security
   2441              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV     DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7007         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2442              {
   2443                // set association status to authenticated
   2444                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   EE           MOV     A,R6
   \   00002D   FA           MOV     R2,A
   \   00002E   EF           MOV     A,R7
   \   00002F   FB           MOV     R3,A
   \   000030   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay; Banked call to: ZDSecMgrAssocDeviceAuth
   2445              }
   2446          
   2447              // set up device info
   2448              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   000033   740A         MOV     A,#0xa
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   7400         MOV     A,#0x0
   \   00003A   F0           MOVX    @DPTR,A
   2449              addrEntry.index = assoc->addrIdx;
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   7415         MOV     A,#0x15
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E8           MOV     A,R0
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   E9           MOV     A,R1
   \   00004F   F0           MOVX    @DPTR,A
   2450              AddrMgrEntryGet( &addrEntry );
   \   000050                ; Setup parameters for call to function AddrMgrEntryGet
   \   000050   740A         MOV     A,#0xa
   \   000052   12....       LCALL   ?XSTACK_DISP101_8
   \   000055   12....       LCALL   ??AddrMgrEntryGet?relay; Banked call to: AddrMgrEntryGet
   \   000058   E9           MOV     A,R1
   2451          
   2452              device.nwkAddr    = assoc->shortAddr;
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F8           MOV     R0,A
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F9           MOV     R1,A
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   E8           MOV     A,R0
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   E9           MOV     A,R1
   \   00006C   F0           MOVX    @DPTR,A
   2453              device.extAddr    = addrEntry.extAddr;
   \   00006D   740D         MOV     A,#0xd
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   A882         MOV     R0,DPL
   \   000074   A983         MOV     R1,DPH
   \   000076   7402         MOV     A,#0x2
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   E8           MOV     A,R0
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   E9           MOV     A,R1
   \   00007F   F0           MOVX    @DPTR,A
   2454              device.parentAddr = NLME_GetShortAddr();
   \   000080                ; Setup parameters for call to function NLME_GetShortAddr
   \   000080   12....       LCALL   ??NLME_GetShortAddr?relay; Banked call to: NLME_GetShortAddr
   \   000083   7404         MOV     A,#0x4
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   EA           MOV     A,R2
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   EB           MOV     A,R3
   \   00008C   F0           MOVX    @DPTR,A
   2455              device.secure     = FALSE;
   \   00008D   7406         MOV     A,#0x6
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   7400         MOV     A,#0x0
   \   000094   F0           MOVX    @DPTR,A
   2456              device.devStatus  = assoc->devStatus;
   \   000095   8E82         MOV     DPL,R6
   \   000097   8F83         MOV     DPH,R7
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   C0E0         PUSH    A
   \   0000A1   7407         MOV     A,#0x7
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   D0E0         POP     A
   \   0000A8   F0           MOVX    @DPTR,A
   2457          
   2458              // process new device
   2459              status = ZDSecMgrDeviceNew( &device );
   \   0000A9                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   0000A9   AA..         MOV     R2,?XSP + 0
   \   0000AB   AB..         MOV     R3,?XSP + 1
   \   0000AD   12....       LCALL   ??ZDSecMgrDeviceNew?relay; Banked call to: ZDSecMgrDeviceNew
   \   0000B0   E9           MOV     A,R1
   \   0000B1   F5..         MOV     ?V1,A
   2460          
   2461              if ( status == ZSuccess )
   \   0000B3   E5..         MOV     A,?V1
   \   0000B5   700F         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2462              {
   2463                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   C2E2         CLR     0xE0 /* A   */.2
   \   0000C3   F0           MOVX    @DPTR,A
   \   0000C4   8013         SJMP    ??ZDSecMgrNewDeviceEvent_0
   2464              }
   2465              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   0000C6   74C8         MOV     A,#-0x38
   \   0000C8   65..         XRL     A,?V1
   \   0000CA   700D         JNZ     ??ZDSecMgrNewDeviceEvent_0
   2466              {
   2467                AssocRemove( addrEntry.extAddr );
   \   0000CC                ; Setup parameters for call to function AssocRemove
   \   0000CC   740D         MOV     A,#0xd
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   AA82         MOV     R2,DPL
   \   0000D3   AB83         MOV     R3,DPH
   \   0000D5   12....       LCALL   ??AssocRemove?relay  ; Banked call to: AssocRemove
   \   0000D8   E9           MOV     A,R1
   2468              }
   2469            }
   2470          
   2471            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000D9   A9..         MOV     R1,?V0
   \   0000DB   7417         MOV     A,#0x17
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0   7F04         MOV     R7,#0x4
   \   0000E2   02....       LJMP    ?BANKED_LEAVE_XDATA
   2472          }
   2473          
   2474          /******************************************************************************
   2475           * @fn          ZDSecMgrEvent
   2476           *
   2477           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2478           *
   2479           * @param       none
   2480           *
   2481           * @return      none
   2482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2483          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2484          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2485            uint8            action;
   2486            uint8            restart;
   2487            uint16           index;
   2488            AddrMgrEntry_t   entry;
   2489            ZDSecMgrDevice_t device;
   2490          
   2491          
   2492            // verify data is available
   2493            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   7003         JNZ     $+5
   \   000016   02....       LJMP    ??ZDSecMgrEvent_0 & 0xFFFF
   2494            {
   2495              action  = FALSE;
   \   000019   75..00       MOV     ?V1,#0x0
   2496              restart = FALSE;
   \   00001C   75..00       MOV     ?V0,#0x0
   2497          
   2498              // update all the counters
   2499              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEvent_1:
   \   000023   C3           CLR     C
   \   000024   EE           MOV     A,R6
   \   000025   9403         SUBB    A,#0x3
   \   000027   EF           MOV     A,R7
   \   000028   9400         SUBB    A,#0x0
   \   00002A   4003         JC      $+5
   \   00002C   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2500              {
   2501                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \   00002F   EE           MOV     A,R6
   \   000030   F8           MOV     R0,A
   \   000031   EF           MOV     A,R7
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   75F007       MOV     B,#0x7
   \   000037   A4           MUL     AB
   \   000038   C8           XCH     A,R0
   \   000039   AAF0         MOV     R2,B
   \   00003B   75F000       MOV     B,#0x0
   \   00003E   A4           MUL     AB
   \   00003F   2A           ADD     A,R2
   \   000040   FA           MOV     R2,A
   \   000041   75F007       MOV     B,#0x7
   \   000044   E9           MOV     A,R1
   \   000045   A4           MUL     AB
   \   000046   2A           ADD     A,R2
   \   000047   F9           MOV     R1,A
   \   000048   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   28           ADD     A,R0
   \   00004D   FA           MOV     R2,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   39           ADDC    A,R1
   \   000051   8A82         MOV     DPL,R2
   \   000053   F583         MOV     DPH,A
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   7003         JNZ     $+5
   \   00005D   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2502                {
   2503                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   000060   EE           MOV     A,R6
   \   000061   F8           MOV     R0,A
   \   000062   EF           MOV     A,R7
   \   000063   F9           MOV     R1,A
   \   000064   E8           MOV     A,R0
   \   000065   75F007       MOV     B,#0x7
   \   000068   A4           MUL     AB
   \   000069   C8           XCH     A,R0
   \   00006A   AAF0         MOV     R2,B
   \   00006C   75F000       MOV     B,#0x0
   \   00006F   A4           MUL     AB
   \   000070   2A           ADD     A,R2
   \   000071   FA           MOV     R2,A
   \   000072   75F007       MOV     B,#0x7
   \   000075   E9           MOV     A,R1
   \   000076   A4           MUL     AB
   \   000077   2A           ADD     A,R2
   \   000078   F9           MOV     R1,A
   \   000079   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   28           ADD     A,R0
   \   00007E   FA           MOV     R2,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   39           ADDC    A,R1
   \   000082   8A82         MOV     DPL,R2
   \   000084   F583         MOV     DPH,A
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   6030         JZ      ??ZDSecMgrEvent_4
   2504                  {
   2505                    ZDSecMgrCtrlData[index].cntr--;
   \   00008F   EE           MOV     A,R6
   \   000090   F8           MOV     R0,A
   \   000091   EF           MOV     A,R7
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   75F007       MOV     B,#0x7
   \   000097   A4           MUL     AB
   \   000098   C8           XCH     A,R0
   \   000099   AAF0         MOV     R2,B
   \   00009B   75F000       MOV     B,#0x0
   \   00009E   A4           MUL     AB
   \   00009F   2A           ADD     A,R2
   \   0000A0   FA           MOV     R2,A
   \   0000A1   75F007       MOV     B,#0x7
   \   0000A4   E9           MOV     A,R1
   \   0000A5   A4           MUL     AB
   \   0000A6   2A           ADD     A,R2
   \   0000A7   F9           MOV     R1,A
   \   0000A8   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   28           ADD     A,R0
   \   0000AD   FA           MOV     R2,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   39           ADDC    A,R1
   \   0000B1   8A82         MOV     DPL,R2
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   24FF         ADD     A,#-0x1
   \   0000BE   F0           MOVX    @DPTR,A
   2506                  }
   2507          
   2508                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_4:
   \   0000BF   E5..         MOV     A,?V1
   \   0000C1   6003         JZ      $+5
   \   0000C3   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   \   0000C6   EE           MOV     A,R6
   \   0000C7   F8           MOV     R0,A
   \   0000C8   EF           MOV     A,R7
   \   0000C9   F9           MOV     R1,A
   \   0000CA   E8           MOV     A,R0
   \   0000CB   75F007       MOV     B,#0x7
   \   0000CE   A4           MUL     AB
   \   0000CF   C8           XCH     A,R0
   \   0000D0   AAF0         MOV     R2,B
   \   0000D2   75F000       MOV     B,#0x0
   \   0000D5   A4           MUL     AB
   \   0000D6   2A           ADD     A,R2
   \   0000D7   FA           MOV     R2,A
   \   0000D8   75F007       MOV     B,#0x7
   \   0000DB   E9           MOV     A,R1
   \   0000DC   A4           MUL     AB
   \   0000DD   2A           ADD     A,R2
   \   0000DE   F9           MOV     R1,A
   \   0000DF   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   28           ADD     A,R0
   \   0000E4   FA           MOV     R2,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   39           ADDC    A,R1
   \   0000E8   8A82         MOV     DPL,R2
   \   0000EA   F583         MOV     DPH,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   6003         JZ      $+5
   \   0000F5   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   2509                  {
   2510                    action = TRUE;
   \   0000F8   75..01       MOV     ?V1,#0x1
   2511          
   2512                    // update from control data
   2513                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   0000FB   EE           MOV     A,R6
   \   0000FC   F8           MOV     R0,A
   \   0000FD   EF           MOV     A,R7
   \   0000FE   F9           MOV     R1,A
   \   0000FF   E8           MOV     A,R0
   \   000100   75F007       MOV     B,#0x7
   \   000103   A4           MUL     AB
   \   000104   C8           XCH     A,R0
   \   000105   AAF0         MOV     R2,B
   \   000107   75F000       MOV     B,#0x0
   \   00010A   A4           MUL     AB
   \   00010B   2A           ADD     A,R2
   \   00010C   FA           MOV     R2,A
   \   00010D   75F007       MOV     B,#0x7
   \   000110   E9           MOV     A,R1
   \   000111   A4           MUL     AB
   \   000112   2A           ADD     A,R2
   \   000113   F9           MOV     R1,A
   \   000114   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000117   E0           MOVX    A,@DPTR
   \   000118   28           ADD     A,R0
   \   000119   FA           MOV     R2,A
   \   00011A   A3           INC     DPTR
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   39           ADDC    A,R1
   \   00011D   8A82         MOV     DPL,R2
   \   00011F   F583         MOV     DPH,A
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F8           MOV     R0,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F9           MOV     R1,A
   \   000128   7404         MOV     A,#0x4
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   E8           MOV     A,R0
   \   00012E   F0           MOVX    @DPTR,A
   \   00012F   A3           INC     DPTR
   \   000130   E9           MOV     A,R1
   \   000131   F0           MOVX    @DPTR,A
   2514                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \   000132   EE           MOV     A,R6
   \   000133   F8           MOV     R0,A
   \   000134   EF           MOV     A,R7
   \   000135   F9           MOV     R1,A
   \   000136   E8           MOV     A,R0
   \   000137   75F007       MOV     B,#0x7
   \   00013A   A4           MUL     AB
   \   00013B   C8           XCH     A,R0
   \   00013C   AAF0         MOV     R2,B
   \   00013E   75F000       MOV     B,#0x0
   \   000141   A4           MUL     AB
   \   000142   2A           ADD     A,R2
   \   000143   FA           MOV     R2,A
   \   000144   75F007       MOV     B,#0x7
   \   000147   E9           MOV     A,R1
   \   000148   A4           MUL     AB
   \   000149   2A           ADD     A,R2
   \   00014A   F9           MOV     R1,A
   \   00014B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00014E   E0           MOVX    A,@DPTR
   \   00014F   28           ADD     A,R0
   \   000150   FA           MOV     R2,A
   \   000151   A3           INC     DPTR
   \   000152   E0           MOVX    A,@DPTR
   \   000153   39           ADDC    A,R1
   \   000154   8A82         MOV     DPL,R2
   \   000156   F583         MOV     DPH,A
   \   000158   A3           INC     DPTR
   \   000159   A3           INC     DPTR
   \   00015A   A3           INC     DPTR
   \   00015B   A3           INC     DPTR
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   C0E0         PUSH    A
   \   00015F   7406         MOV     A,#0x6
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   D0E0         POP     A
   \   000166   F0           MOVX    @DPTR,A
   2515                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   000167   EE           MOV     A,R6
   \   000168   F8           MOV     R0,A
   \   000169   EF           MOV     A,R7
   \   00016A   F9           MOV     R1,A
   \   00016B   E8           MOV     A,R0
   \   00016C   75F007       MOV     B,#0x7
   \   00016F   A4           MUL     AB
   \   000170   C8           XCH     A,R0
   \   000171   AAF0         MOV     R2,B
   \   000173   75F000       MOV     B,#0x0
   \   000176   A4           MUL     AB
   \   000177   2A           ADD     A,R2
   \   000178   FA           MOV     R2,A
   \   000179   75F007       MOV     B,#0x7
   \   00017C   E9           MOV     A,R1
   \   00017D   A4           MUL     AB
   \   00017E   2A           ADD     A,R2
   \   00017F   F9           MOV     R1,A
   \   000180   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000183   E0           MOVX    A,@DPTR
   \   000184   28           ADD     A,R0
   \   000185   F8           MOV     R0,A
   \   000186   A3           INC     DPTR
   \   000187   E0           MOVX    A,@DPTR
   \   000188   39           ADDC    A,R1
   \   000189   F9           MOV     R1,A
   \   00018A   7408         MOV     A,#0x8
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   E8           MOV     A,R0
   \   000190   F0           MOVX    @DPTR,A
   \   000191   A3           INC     DPTR
   \   000192   E9           MOV     A,R1
   \   000193   F0           MOVX    @DPTR,A
   2516          
   2517                    // set the user and address index
   2518                    entry.user  = ADDRMGR_USER_SECURITY;
   \   000194   740A         MOV     A,#0xa
   \   000196   12....       LCALL   ?XSTACK_DISP0_8
   \   000199   7402         MOV     A,#0x2
   \   00019B   F0           MOVX    @DPTR,A
   2519                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \   00019C   EE           MOV     A,R6
   \   00019D   F8           MOV     R0,A
   \   00019E   EF           MOV     A,R7
   \   00019F   F9           MOV     R1,A
   \   0001A0   E8           MOV     A,R0
   \   0001A1   75F007       MOV     B,#0x7
   \   0001A4   A4           MUL     AB
   \   0001A5   C8           XCH     A,R0
   \   0001A6   AAF0         MOV     R2,B
   \   0001A8   75F000       MOV     B,#0x0
   \   0001AB   A4           MUL     AB
   \   0001AC   2A           ADD     A,R2
   \   0001AD   FA           MOV     R2,A
   \   0001AE   75F007       MOV     B,#0x7
   \   0001B1   E9           MOV     A,R1
   \   0001B2   A4           MUL     AB
   \   0001B3   2A           ADD     A,R2
   \   0001B4   F9           MOV     R1,A
   \   0001B5   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0001B8   E0           MOVX    A,@DPTR
   \   0001B9   28           ADD     A,R0
   \   0001BA   FA           MOV     R2,A
   \   0001BB   A3           INC     DPTR
   \   0001BC   E0           MOVX    A,@DPTR
   \   0001BD   39           ADDC    A,R1
   \   0001BE   8A82         MOV     DPL,R2
   \   0001C0   F583         MOV     DPH,A
   \   0001C2   E0           MOVX    A,@DPTR
   \   0001C3   F8           MOV     R0,A
   \   0001C4   A3           INC     DPTR
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   F583         MOV     DPH,A
   \   0001C8   8882         MOV     DPL,R0
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   F8           MOV     R0,A
   \   0001CC   A3           INC     DPTR
   \   0001CD   E0           MOVX    A,@DPTR
   \   0001CE   F9           MOV     R1,A
   \   0001CF   7415         MOV     A,#0x15
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   E8           MOV     A,R0
   \   0001D5   F0           MOVX    @DPTR,A
   \   0001D6   A3           INC     DPTR
   \   0001D7   E9           MOV     A,R1
   \   0001D8   F0           MOVX    @DPTR,A
   2520          
   2521                    // get the address data
   2522                    AddrMgrEntryGet( &entry );
   \   0001D9                ; Setup parameters for call to function AddrMgrEntryGet
   \   0001D9   740A         MOV     A,#0xa
   \   0001DB   12....       LCALL   ?XSTACK_DISP101_8
   \   0001DE   12....       LCALL   ??AddrMgrEntryGet?relay; Banked call to: AddrMgrEntryGet
   \   0001E1   E9           MOV     A,R1
   2523          
   2524                    // set device address data
   2525                    device.nwkAddr = entry.nwkAddr;
   \   0001E2   740B         MOV     A,#0xb
   \   0001E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E7   E0           MOVX    A,@DPTR
   \   0001E8   F8           MOV     R0,A
   \   0001E9   A3           INC     DPTR
   \   0001EA   E0           MOVX    A,@DPTR
   \   0001EB   F9           MOV     R1,A
   \   0001EC   85..82       MOV     DPL,?XSP + 0
   \   0001EF   85..83       MOV     DPH,?XSP + 1
   \   0001F2   E8           MOV     A,R0
   \   0001F3   F0           MOVX    @DPTR,A
   \   0001F4   A3           INC     DPTR
   \   0001F5   E9           MOV     A,R1
   \   0001F6   F0           MOVX    @DPTR,A
   2526                    device.extAddr = entry.extAddr;
   \   0001F7   740D         MOV     A,#0xd
   \   0001F9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FC   A882         MOV     R0,DPL
   \   0001FE   A983         MOV     R1,DPH
   \   000200   7402         MOV     A,#0x2
   \   000202   12....       LCALL   ?XSTACK_DISP0_8
   \   000205   E8           MOV     A,R0
   \   000206   F0           MOVX    @DPTR,A
   \   000207   A3           INC     DPTR
   \   000208   E9           MOV     A,R1
   \   000209   F0           MOVX    @DPTR,A
   2527          
   2528                    // update from entry data
   2529                    ZDSecMgrDeviceCtrlHandler( &device );
   \   00020A                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00020A   AA..         MOV     R2,?XSP + 0
   \   00020C   AB..         MOV     R3,?XSP + 1
   \   00020E   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay; Banked call to: ZDSecMgrDeviceCtrlHandler
   \   000211   8003         SJMP    ??ZDSecMgrEvent_3
   2530                  }
   2531                  else
   2532                  {
   2533                    restart = TRUE;
   \                     ??ZDSecMgrEvent_5:
   \   000213   75..01       MOV     ?V0,#0x1
   2534                  }
   2535                }
   2536              }
   \                     ??ZDSecMgrEvent_3:
   \   000216   0E           INC     R6
   \   000217   EE           MOV     A,R6
   \   000218   7001         JNZ     ??ZDSecMgrEvent_6
   \   00021A   0F           INC     R7
   \                     ??ZDSecMgrEvent_6:
   \   00021B   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2537          
   2538              // check for timer restart
   2539              if ( restart == TRUE )
   \                     ??ZDSecMgrEvent_2:
   \   00021E   7401         MOV     A,#0x1
   \   000220   65..         XRL     A,?V0
   \   000222   7011         JNZ     ??ZDSecMgrEvent_0
   2540              {
   2541                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000224                ; Setup parameters for call to function osal_start_timerEx
   \   000224   7C64         MOV     R4,#0x64
   \   000226   7D00         MOV     R5,#0x0
   \   000228   7A00         MOV     R2,#0x0
   \   00022A   7B01         MOV     R3,#0x1
   \   00022C   90....       MOV     DPTR,#ZDAppTaskID
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   F9           MOV     R1,A
   \   000231   12....       LCALL   ??osal_start_timerEx?relay; Banked call to: osal_start_timerEx
   \   000234   E9           MOV     A,R1
   2542              }
   2543            }
   2544          }
   \                     ??ZDSecMgrEvent_0:
   \   000235   7417         MOV     A,#0x17
   \   000237   12....       LCALL   ?DEALLOC_XSTACK8
   \   00023A   7F02         MOV     R7,#0x2
   \   00023C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2545          
   2546          /******************************************************************************
   2547           * @fn          ZDSecMgrEstablishKeyCfm
   2548           *
   2549           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2550           *
   2551           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2552           *
   2553           * @return      none
   2554           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2555          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2556          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2557            // send the NWK key
   2558            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   \   000009   90....       MOV     DPTR,#zgDeviceLogicalType
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   700C         JNZ     ??ZDSecMgrEstablishKeyCfm_0
   2559            {
   2560              // update control for specified EXT address
   2561              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   \   00000F                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   00000F   7905         MOV     R1,#0x5
   \   000011   EE           MOV     A,R6
   \   000012   2402         ADD     A,#0x2
   \   000014   FA           MOV     R2,A
   \   000015   E4           CLR     A
   \   000016   3F           ADDC    A,R7
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   ??ZDSecMgrDeviceCtrlUpdate?relay; Banked call to: ZDSecMgrDeviceCtrlUpdate
   2562            }
   2563            else
   2564            {
   2565              // this should be done when receiving the NWK key
   2566              // if devState ==
   2567              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2568                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2569          
   2570              // if not in joining state -- this should trigger an event for an
   2571              // end point that requested SKKE
   2572              // if ( devState == DEV_END_DEVICE )
   2573             //       devState == DEV_ROUTER;
   2574          
   2575            }
   2576          }
   \                     ??ZDSecMgrEstablishKeyCfm_0:
   \   00001B   7F01         MOV     R7,#0x1
   \   00001D   02....       LJMP    ?BANKED_LEAVE_XDATA
   2577          
   2578          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2579          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2580          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2581            uint8  match;
   2582            uint8  lookup[Z_EXTADDR_LEN];
   2583          
   2584            match = FALSE;
   \   00000E   75..00       MOV     ?V0,#0x0
   2585          
   2586            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   AC..         MOV     R4,?XSP + 0
   \   000013   AD..         MOV     R5,?XSP + 1
   \   000015   7A00         MOV     R2,#0x0
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   ??AddrMgrExtAddrLookup?relay; Banked call to: AddrMgrExtAddrLookup
   \   00001C   E9           MOV     A,R1
   \   00001D   600E         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2587            {
   2588              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00001F   EE           MOV     A,R6
   \   000020   FC           MOV     R4,A
   \   000021   EF           MOV     A,R7
   \   000022   FD           MOV     R5,A
   \   000023   AA..         MOV     R2,?XSP + 0
   \   000025   AB..         MOV     R3,?XSP + 1
   \   000027   12....       LCALL   ??AddrMgrExtAddrEqual?relay; Banked call to: AddrMgrExtAddrEqual
   \   00002A   E9           MOV     A,R1
   \   00002B   F5..         MOV     ?V0,A
   2589            }
   2590          
   2591            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   00002D   A9..         MOV     R1,?V0
   \   00002F   7408         MOV     A,#0x8
   \   000031   12....       LCALL   ?DEALLOC_XSTACK8
   \   000034   7F01         MOV     R7,#0x1
   \   000036   02....       LJMP    ?BANKED_LEAVE_XDATA
   2592          }
   2593          
   2594          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2595          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2596          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2597            uint16 ami;
   2598            uint16 keyNvId;   
   2599            uint8 masterKey[SEC_KEY_LEN];
   2600          
   2601            if ( !ZDSecMgrTCDataLoaded )
   \   00000E   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6003         JZ      $+5
   \   000014   02....       LJMP    ??ZDSecMgrTCDataLoad_0 & 0xFFFF
   2602            {
   2603              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000017                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000017   A8..         MOV     R0,?XSP + 0
   \   000019   A9..         MOV     R1,?XSP + 1
   \   00001B   88..         MOV     ?V0,R0
   \   00001D   89..         MOV     ?V1,R1
   \   00001F   78..         MOV     R0,#?V0
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   EE           MOV     A,R6
   \   000025   FC           MOV     R4,A
   \   000026   EF           MOV     A,R7
   \   000027   FD           MOV     R5,A
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \   00002C   12....       LCALL   ??ZDSecMgrAddrStore?relay; Banked call to: ZDSecMgrAddrStore
   \   00002F   7402         MOV     A,#0x2
   \   000031   12....       LCALL   ?DEALLOC_XSTACK8
   \   000034   E9           MOV     A,R1
   \   000035   705F         JNZ     ??ZDSecMgrTCDataLoad_1
   2604              {
   2605                // if preconfigured load key
   2606                if ( zgPreConfigKeys == TRUE )
   \   000037   90....       MOV     DPTR,#zgPreConfigKeys
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   6401         XRL     A,#0x1
   \   00003D   7057         JNZ     ??ZDSecMgrTCDataLoad_1
   2607                {
   2608                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   \   00003F                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?XSTACK_DISP102_8
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   FA           MOV     R2,A
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   FB           MOV     R3,A
   \   00004F   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay; Banked call to: ZDSecMgrMasterKeyLookup
   \   000052   E9           MOV     A,R1
   \   000053   6041         JZ      ??ZDSecMgrTCDataLoad_1
   2609                  {
   2610                    // temporary copy
   2611                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000055                ; Setup parameters for call to function osal_memcpy
   \   000055   75....       MOV     ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000058   75....       MOV     ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00005B   75..80       MOV     ?V2,#-0x80
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000063   7C10         MOV     R4,#0x10
   \   000065   7D00         MOV     R5,#0x0
   \   000067   7407         MOV     A,#0x7
   \   000069   12....       LCALL   ?XSTACK_DISP101_8
   \   00006C   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00006F   7403         MOV     A,#0x3
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   2612          
   2613                    ZDSecMgrMasterKeyStore( ami, masterKey );
   \   000074                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000074   7404         MOV     A,#0x4
   \   000076   12....       LCALL   ?XSTACK_DISP102_8
   \   000079   85..82       MOV     DPL,?XSP + 0
   \   00007C   85..83       MOV     DPH,?XSP + 1
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   FA           MOV     R2,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   FB           MOV     R3,A
   \   000084   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay; Banked call to: ZDSecMgrMasterKeyStore
   \   000087   E9           MOV     A,R1
   2614                      
   2615                    // remove copy of key in RAM  
   2616                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   \   000088                ; Setup parameters for call to function osal_memset
   \   000088   7C10         MOV     R4,#0x10
   \   00008A   7D00         MOV     R5,#0x0
   \   00008C   7900         MOV     R1,#0x0
   \   00008E   7404         MOV     A,#0x4
   \   000090   12....       LCALL   ?XSTACK_DISP101_8
   \   000093   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   2617                  }
   2618                }
   2619              }
   2620          
   2621              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   000096   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000099   7401         MOV     A,#0x1
   \   00009B   F0           MOVX    @DPTR,A
   2622            }
   2623          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00009C   7414         MOV     A,#0x14
   \   00009E   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A1   7F03         MOV     R7,#0x3
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
   2624          
   2625          /******************************************************************************
   2626           * @fn          ZDSecMgrEstablishKeyInd
   2627           *
   2628           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2629           *
   2630           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2631           *
   2632           * @return      none
   2633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2634          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2635          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2636            ZDSecMgrDevice_t        device;
   2637            APSME_EstablishKeyRsp_t rsp;
   2638          
   2639          
   2640            // load Trust Center data if needed
   2641            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EE           MOV     A,R6
   \   00000F   2404         ADD     A,#0x4
   \   000011   FA           MOV     R2,A
   \   000012   E4           CLR     A
   \   000013   3F           ADDC    A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??ZDSecMgrTCDataLoad?relay; Banked call to: ZDSecMgrTCDataLoad
   2642          
   2643            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   000018                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000018   EE           MOV     A,R6
   \   000019   2404         ADD     A,#0x4
   \   00001B   FA           MOV     R2,A
   \   00001C   E4           CLR     A
   \   00001D   3F           ADDC    A,R7
   \   00001E   FB           MOV     R3,A
   \   00001F   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay; Banked call to: ZDSecMgrTCExtAddrCheck
   \   000022   E9           MOV     A,R1
   \   000023   6023         JZ      ??ZDSecMgrEstablishKeyInd_0
   2644            {
   2645              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2646              //OR
   2647              //!ZDSecMgrTCAuthenticated
   2648              //devtag.0604.critical
   2649                  //how is the parentAddr used here
   2650          
   2651              // initial SKKE from Trust Center via parent
   2652              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000025   7407         MOV     A,#0x7
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   7400         MOV     A,#0x0
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   7400         MOV     A,#0x0
   \   000030   F0           MOVX    @DPTR,A
   2653              device.parentAddr = ind->srcAddr;
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   740B         MOV     A,#0xb
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E8           MOV     A,R0
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   E9           MOV     A,R1
   \   000045   F0           MOVX    @DPTR,A
   \   000046   8021         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2654            }
   2655            else
   2656            {
   2657              // Trust Center direct or E2E SKKE
   2658              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000048   8E82         MOV     DPL,R6
   \   00004A   8F83         MOV     DPH,R7
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F8           MOV     R0,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F9           MOV     R1,A
   \   000053   7407         MOV     A,#0x7
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   E8           MOV     A,R0
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   E9           MOV     A,R1
   \   00005C   F0           MOVX    @DPTR,A
   2659              device.parentAddr = INVALID_NODE_ADDR;
   \   00005D   740B         MOV     A,#0xb
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   74FE         MOV     A,#-0x2
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   74FF         MOV     A,#-0x1
   \   000068   F0           MOVX    @DPTR,A
   2660            }
   2661          
   2662            device.extAddr = ind->initExtAddr;
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000069   EE           MOV     A,R6
   \   00006A   2404         ADD     A,#0x4
   \   00006C   F8           MOV     R0,A
   \   00006D   E4           CLR     A
   \   00006E   3F           ADDC    A,R7
   \   00006F   F9           MOV     R1,A
   \   000070   7409         MOV     A,#0x9
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E8           MOV     A,R0
   \   000076   F0           MOVX    @DPTR,A
   \   000077   A3           INC     DPTR
   \   000078   E9           MOV     A,R1
   \   000079   F0           MOVX    @DPTR,A
   2663            //devtag.pro.security.0724.todo - verify usage
   2664            device.secure  = ind->nwkSecure;
   \   00007A   EE           MOV     A,R6
   \   00007B   240E         ADD     A,#0xe
   \   00007D   F582         MOV     DPL,A
   \   00007F   E4           CLR     A
   \   000080   3F           ADDC    A,R7
   \   000081   F583         MOV     DPH,A
   \   000083   E0           MOVX    A,@DPTR
   \   000084   C0E0         PUSH    A
   \   000086   740D         MOV     A,#0xd
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   D0E0         POP     A
   \   00008D   F0           MOVX    @DPTR,A
   2665          
   2666            // validate device for SKKE
   2667            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   00008E                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   00008E   7407         MOV     A,#0x7
   \   000090   12....       LCALL   ?XSTACK_DISP101_8
   \   000093   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay; Banked call to: ZDSecMgrDeviceValidateSKKE
   \   000096   E9           MOV     A,R1
   \   000097   700A         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2668            {
   2669              rsp.accept = TRUE;
   \   000099   7404         MOV     A,#0x4
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   7401         MOV     A,#0x1
   \   0000A0   F0           MOVX    @DPTR,A
   \   0000A1   8008         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2670            }
   2671            else
   2672            {
   2673              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   0000A3   7404         MOV     A,#0x4
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   7400         MOV     A,#0x0
   \   0000AA   F0           MOVX    @DPTR,A
   2674            }
   2675          
   2676            rsp.dstAddr     = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   0000AB   8E82         MOV     DPL,R6
   \   0000AD   8F83         MOV     DPH,R7
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F8           MOV     R0,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   F9           MOV     R1,A
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   E8           MOV     A,R0
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E9           MOV     A,R1
   \   0000C0   F0           MOVX    @DPTR,A
   2677            rsp.initExtAddr = &ind->initExtAddr[0];
   \   0000C1   EE           MOV     A,R6
   \   0000C2   2404         ADD     A,#0x4
   \   0000C4   F8           MOV     R0,A
   \   0000C5   E4           CLR     A
   \   0000C6   3F           ADDC    A,R7
   \   0000C7   F9           MOV     R1,A
   \   0000C8   7402         MOV     A,#0x2
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   E8           MOV     A,R0
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   E9           MOV     A,R1
   \   0000D1   F0           MOVX    @DPTR,A
   2678            //devtag.0604.todo - remove obsolete
   2679            rsp.apsSecure   = ind->apsSecure;
   \   0000D2   EE           MOV     A,R6
   \   0000D3   240D         ADD     A,#0xd
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   E4           CLR     A
   \   0000D8   3F           ADDC    A,R7
   \   0000D9   F583         MOV     DPH,A
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   C0E0         PUSH    A
   \   0000DE   7405         MOV     A,#0x5
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   D0E0         POP     A
   \   0000E5   F0           MOVX    @DPTR,A
   2680            rsp.nwkSecure   = ind->nwkSecure;
   \   0000E6   EE           MOV     A,R6
   \   0000E7   240E         ADD     A,#0xe
   \   0000E9   F582         MOV     DPL,A
   \   0000EB   E4           CLR     A
   \   0000EC   3F           ADDC    A,R7
   \   0000ED   F583         MOV     DPH,A
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   C0E0         PUSH    A
   \   0000F2   7406         MOV     A,#0x6
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   D0E0         POP     A
   \   0000F9   F0           MOVX    @DPTR,A
   2681          
   2682            APSME_EstablishKeyRsp( &rsp );
   \   0000FA                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   0000FA   AA..         MOV     R2,?XSP + 0
   \   0000FC   AB..         MOV     R3,?XSP + 1
   \   0000FE   12....       LCALL   ??APSME_EstablishKeyRsp?relay; Banked call to: APSME_EstablishKeyRsp
   \   000101   E9           MOV     A,R1
   2683          }
   \   000102   7411         MOV     A,#0x11
   \   000104   12....       LCALL   ?DEALLOC_XSTACK8
   \   000107   7F01         MOV     R7,#0x1
   \   000109   02....       LJMP    ?BANKED_LEAVE_XDATA
   2684          //devtag.pro.security
   2685          #if 0
   2686          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2687          {
   2688            ZDSecMgrDevice_t        device;
   2689            APSME_EstablishKeyRsp_t rsp;
   2690          
   2691          
   2692            device.extAddr = ind->initExtAddr;
   2693            device.secure  = ind->secure;
   2694          
   2695            if ( ind->secure == FALSE )
   2696            {
   2697              // SKKE from Trust Center is not secured between child and parent
   2698              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2699              device.parentAddr = ind->srcAddr;
   2700            }
   2701            else
   2702            {
   2703              // SKKE from initiator should be secured
   2704              device.nwkAddr    = ind->srcAddr;
   2705              device.parentAddr = INVALID_NODE_ADDR;
   2706            }
   2707          
   2708            rsp.dstAddr     = ind->srcAddr;
   2709            rsp.initExtAddr = &ind->initExtAddr[0];
   2710            rsp.secure      = ind->secure;
   2711          
   2712            // validate device for SKKE
   2713            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2714            {
   2715              rsp.accept = TRUE;
   2716            }
   2717            else
   2718            {
   2719              rsp.accept = FALSE;
   2720            }
   2721          
   2722            APSME_EstablishKeyRsp( &rsp );
   2723          }
   2724          #endif
   2725          
   2726          /******************************************************************************
   2727           * @fn          ZDSecMgrTransportKeyInd
   2728           *
   2729           * @brief       Process the ZDO_TransportKeyInd_t message.
   2730           *
   2731           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2732           *
   2733           * @return      none
   2734           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2735          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2736          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2737            uint8 index;
   2738            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2739          
   2740            // load Trust Center data if needed
   2741            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EE           MOV     A,R6
   \   00000F   2416         ADD     A,#0x16
   \   000011   FA           MOV     R2,A
   \   000012   E4           CLR     A
   \   000013   3F           ADDC    A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??ZDSecMgrTCDataLoad?relay; Banked call to: ZDSecMgrTCDataLoad
   2742          
   2743            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2744            {
   2745              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2746              //ZDSecMgrTCMasterKey( ind );
   2747              {
   2748                if ( zgPreConfigKeys != TRUE )
   2749                {
   2750                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2751                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2752                }
   2753                else
   2754                {
   2755                  // error condition - reject key
   2756                }
   2757              }
   2758            }
   2759            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2760                      ( ind->keyType == 6                 ) ||
   2761                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000026   8E82         MOV     DPL,R6
   \   000028   8F83         MOV     DPH,R7
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6401         XRL     A,#0x1
   \   000031   601D         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6406         XRL     A,#0x6
   \   00003E   6010         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   6405         XRL     A,#0x5
   \   00004B   6003         JZ      $+5
   \   00004D   02....       LJMP    ??ZDSecMgrTransportKeyInd_2 & 0xFFFF
   2762            {
   2763              // check for dummy NWK key (all zeros)
   2764              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000050   75..00       MOV     ?V0,#0x0
   2765                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000053   E5..         MOV     A,?V0
   \   000055   C3           CLR     C
   \   000056   9410         SUBB    A,#0x10
   \   000058   5019         JNC     ??ZDSecMgrTransportKeyInd_4
   \   00005A   A8..         MOV     R0,?V0
   \   00005C   7900         MOV     R1,#0x0
   \   00005E   EE           MOV     A,R6
   \   00005F   28           ADD     A,R0
   \   000060   F582         MOV     DPL,A
   \   000062   EF           MOV     A,R7
   \   000063   39           ADDC    A,R1
   \   000064   F583         MOV     DPH,A
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   7004         JNZ     ??ZDSecMgrTransportKeyInd_4
   2766                    index++ );
   \   00006F   05..         INC     ?V0
   \   000071   80E0         SJMP    ??ZDSecMgrTransportKeyInd_3
   2767          
   2768              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000073   7410         MOV     A,#0x10
   \   000075   65..         XRL     A,?V0
   \   000077   702F         JNZ     ??ZDSecMgrTransportKeyInd_5
   2769              {
   2770                // load preconfigured key - once!!
   2771                if ( !_NIB.nwkKeyLoaded )
   \   000079   90....       MOV     DPTR,#_NIB + 61
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   7052         JNZ     ??ZDSecMgrTransportKeyInd_6
   2772                {
   2773                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   00007F                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   00007F   AC..         MOV     R4,?XSP + 0
   \   000081   AD..         MOV     R5,?XSP + 1
   \   000083   7A62         MOV     R2,#0x62
   \   000085   7B00         MOV     R3,#0x0
   \   000087   12....       LCALL   ??ZDSecMgrReadKeyFromNv?relay; Banked call to: ZDSecMgrReadKeyFromNv
   \   00008A   E9           MOV     A,R1
   2774                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   00008B                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00008B   7900         MOV     R1,#0x0
   \   00008D   AA..         MOV     R2,?XSP + 0
   \   00008F   AB..         MOV     R3,?XSP + 1
   \   000091   12....       LCALL   ??SSP_UpdateNwkKey?relay; Banked call to: SSP_UpdateNwkKey
   2775                  SSP_SwitchNwkKey( 0 );
   \   000094                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000094   7900         MOV     R1,#0x0
   \   000096   12....       LCALL   ??SSP_SwitchNwkKey?relay; Banked call to: SSP_SwitchNwkKey
   2776                  
   2777                  // clear local copy of key
   2778                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   000099                ; Setup parameters for call to function osal_memset
   \   000099   7C10         MOV     R4,#0x10
   \   00009B   7D00         MOV     R5,#0x0
   \   00009D   7900         MOV     R1,#0x0
   \   00009F   AA..         MOV     R2,?XSP + 0
   \   0000A1   AB..         MOV     R3,?XSP + 1
   \   0000A3   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   \   0000A6   8029         SJMP    ??ZDSecMgrTransportKeyInd_6
   2779                }
   2780              }
   2781              else
   2782              {
   2783                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000A8                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   0000A8   8E82         MOV     DPL,R6
   \   0000AA   8F83         MOV     DPH,R7
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F9           MOV     R1,A
   \   0000B3   EE           MOV     A,R6
   \   0000B4   2406         ADD     A,#0x6
   \   0000B6   FA           MOV     R2,A
   \   0000B7   E4           CLR     A
   \   0000B8   3F           ADDC    A,R7
   \   0000B9   FB           MOV     R3,A
   \   0000BA   12....       LCALL   ??SSP_UpdateNwkKey?relay; Banked call to: SSP_UpdateNwkKey
   2784                if ( !_NIB.nwkKeyLoaded )
   \   0000BD   90....       MOV     DPTR,#_NIB + 61
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   700E         JNZ     ??ZDSecMgrTransportKeyInd_6
   2785                {
   2786                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000C3                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000C3   8E82         MOV     DPL,R6
   \   0000C5   8F83         MOV     DPH,R7
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   F9           MOV     R1,A
   \   0000CE   12....       LCALL   ??SSP_SwitchNwkKey?relay; Banked call to: SSP_SwitchNwkKey
   2787                }
   2788              }
   2789          
   2790              // handle next step in authentication process
   2791              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   0000D1                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000D1   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay; Banked call to: ZDSecMgrAuthNwkKey
   \   0000D4   8025         SJMP    ??ZDSecMgrTransportKeyInd_0
   2792            }
   2793            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   0000D6   8E82         MOV     DPL,R6
   \   0000D8   8F83         MOV     DPH,R7
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   6404         XRL     A,#0x4
   \   0000E1   6018         JZ      ??ZDSecMgrTransportKeyInd_0
   2794            {
   2795              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2796              {
   2797                // This should not happen because TCLK should not be Tx
   2798              }
   2799            }
   2800            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   0000E3   8E82         MOV     DPL,R6
   \   0000E5   8F83         MOV     DPH,R7
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   6402         XRL     A,#0x2
   \   0000EE   600B         JZ      ??ZDSecMgrTransportKeyInd_0
   2801            {
   2802              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2803              {
   2804                uint16           ami;
   2805                AddrMgrEntry_t   entry;
   2806                ZDSecMgrEntry_t* entryZD;
   2807          
   2808                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2809          
   2810                if ( ind->initiator == TRUE )
   2811                {
   2812                  // get the ami data
   2813                  entry.user  = ADDRMGR_USER_SECURITY;
   2814                  entry.index = ami;
   2815                  AddrMgrEntryGet( &entry );
   2816          
   2817                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2818                  {
   2819                    APSME_EstablishKeyReq_t req;
   2820                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2821          
   2822                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2823          
   2824                    if ( entryZD == NULL )
   2825                    {
   2826                      // get new entry
   2827                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2828                      {
   2829                        // finish setting up entry
   2830                        entryZD->ami = ami;
   2831                      }
   2832                    }
   2833          
   2834                    req.respExtAddr = ind->srcExtAddr;
   2835                    req.method      = APSME_SKKE_METHOD;
   2836                    req.dstAddr     = entry.nwkAddr;
   2837                    req.apsSecure   = FALSE;
   2838                    req.nwkSecure   = TRUE;
   2839                    APSME_EstablishKeyReq( &req );
   2840                  }
   2841                }
   2842                else
   2843                {
   2844                  if ( ami == INVALID_NODE_ADDR )
   2845                  {
   2846                    // store new EXT address
   2847                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2848                  }
   2849          
   2850                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2851                }
   2852              }
   2853            }
   2854            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   \   0000F0   8E82         MOV     DPL,R6
   \   0000F2   8F83         MOV     DPH,R7
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   A3           INC     DPTR
   \   0000F7   A3           INC     DPTR
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   6403         XRL     A,#0x3
   2855            {
   2856              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2857              {
   2858                uint16           ami;
   2859                ZDSecMgrEntry_t* entry;
   2860          
   2861                // get the address index
   2862                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2863                {
   2864                  // store new EXT address
   2865                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2866                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2867                }
   2868          
   2869                ZDSecMgrEntryLookupAMI( ami, &entry );
   2870          
   2871                if ( entry == NULL )
   2872                {
   2873                  // get new entry
   2874                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2875                  {
   2876                    // finish setting up entry
   2877                    entry->ami = ami;
   2878                  }
   2879                }
   2880          
   2881                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2882              }
   2883            }
   2884          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   0000FB   7410         MOV     A,#0x10
   \   0000FD   12....       LCALL   ?DEALLOC_XSTACK8
   \   000100   7F01         MOV     R7,#0x1
   \   000102   02....       LJMP    ?BANKED_LEAVE_XDATA
   2885          
   2886          /******************************************************************************
   2887           * @fn          ZDSecMgrUpdateDeviceInd
   2888           *
   2889           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2890           *
   2891           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2892           *
   2893           * @return      none
   2894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2895          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2896          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2897            ZDSecMgrDevice_t device;
   2898          
   2899          
   2900            device.nwkAddr    = ind->devAddr;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   E8           MOV     A,R0
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   E9           MOV     A,R1
   \   000026   F0           MOVX    @DPTR,A
   2901            device.extAddr    = ind->devExtAddr;
   \   000027   EE           MOV     A,R6
   \   000028   2404         ADD     A,#0x4
   \   00002A   F8           MOV     R0,A
   \   00002B   E4           CLR     A
   \   00002C   3F           ADDC    A,R7
   \   00002D   F9           MOV     R1,A
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   E8           MOV     A,R0
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   E9           MOV     A,R1
   \   000037   F0           MOVX    @DPTR,A
   2902            device.parentAddr = ind->srcAddr;
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F8           MOV     R0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F9           MOV     R1,A
   \   000043   7404         MOV     A,#0x4
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E8           MOV     A,R0
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   E9           MOV     A,R1
   \   00004C   F0           MOVX    @DPTR,A
   2903          
   2904            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2905            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2906            //{
   2907            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2908            //  {
   2909            //    device.secure = TRUE;
   2910            //  }
   2911            //  else
   2912            //  {
   2913            //    device.secure = FALSE;
   2914            //  }
   2915          
   2916              // try to join this device
   2917              ZDSecMgrDeviceJoin( &device );
   \   00004D                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   00004D   AA..         MOV     R2,?XSP + 0
   \   00004F   AB..         MOV     R3,?XSP + 1
   \   000051   12....       LCALL   ??ZDSecMgrDeviceJoin?relay; Banked call to: ZDSecMgrDeviceJoin
   \   000054   E9           MOV     A,R1
   2918            //}
   2919          }
   \   000055   740A         MOV     A,#0xa
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   7F01         MOV     R7,#0x1
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2920          
   2921          /******************************************************************************
   2922           * @fn          ZDSecMgrRemoveDeviceInd
   2923           *
   2924           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2925           *
   2926           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2927           *
   2928           * @return      none
   2929           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2930          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2931          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2932            ZDSecMgrDevice_t device;
   2933          
   2934          
   2935            // only accept from Trust Center
   2936            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   49           ORL     A,R1
   \   00001B   7038         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2937            {
   2938              // look up NWK address
   2939              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   00001D                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001D   AC..         MOV     R4,?XSP + 0
   \   00001F   AD..         MOV     R5,?XSP + 1
   \   000021   EE           MOV     A,R6
   \   000022   2404         ADD     A,#0x4
   \   000024   FA           MOV     R2,A
   \   000025   E4           CLR     A
   \   000026   3F           ADDC    A,R7
   \   000027   FB           MOV     R3,A
   \   000028   12....       LCALL   ??APSME_LookupNwkAddr?relay; Banked call to: APSME_LookupNwkAddr
   \   00002B   E9           MOV     A,R1
   \   00002C   6401         XRL     A,#0x1
   \   00002E   7025         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2940              {
   2941                device.parentAddr = NLME_GetShortAddr();
   \   000030                ; Setup parameters for call to function NLME_GetShortAddr
   \   000030   12....       LCALL   ??NLME_GetShortAddr?relay; Banked call to: NLME_GetShortAddr
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   EA           MOV     A,R2
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   EB           MOV     A,R3
   \   00003C   F0           MOVX    @DPTR,A
   2942                device.extAddr    = ind->childExtAddr;
   \   00003D   EE           MOV     A,R6
   \   00003E   2404         ADD     A,#0x4
   \   000040   F8           MOV     R0,A
   \   000041   E4           CLR     A
   \   000042   3F           ADDC    A,R7
   \   000043   F9           MOV     R1,A
   \   000044   7402         MOV     A,#0x2
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E8           MOV     A,R0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E9           MOV     A,R1
   \   00004D   F0           MOVX    @DPTR,A
   2943          
   2944                // remove device
   2945                ZDSecMgrDeviceRemove( &device );
   \   00004E                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00004E   AA..         MOV     R2,?XSP + 0
   \   000050   AB..         MOV     R3,?XSP + 1
   \   000052   12....       LCALL   ??ZDSecMgrDeviceRemove?relay; Banked call to: ZDSecMgrDeviceRemove
   2946              }
   2947            }
   2948          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000055   740A         MOV     A,#0xa
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   7F01         MOV     R7,#0x1
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2949          
   2950          /******************************************************************************
   2951           * @fn          ZDSecMgrRequestKeyInd
   2952           *
   2953           * @brief       Process the ZDO_RequestKeyInd_t message.
   2954           *
   2955           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2956           *
   2957           * @return      none
   2958           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2960          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2961            if ( ind->keyType == KEY_TYPE_NWK )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6401         XRL     A,#0x1
   \   000014   6014         JZ      ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963            }
   2964            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6402         XRL     A,#0x2
   \   000021   7007         JNZ     ??ZDSecMgrRequestKeyInd_0
   2965            {
   2966              ZDSecMgrAppKeyReq( ind );
   \   000023                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   ??ZDSecMgrAppKeyReq?relay; Banked call to: ZDSecMgrAppKeyReq
   2967            }
   2968            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2969            {
   2970            }
   2971            //else ignore
   2972          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00002A   7F01         MOV     R7,#0x1
   \   00002C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2973          
   2974          /******************************************************************************
   2975           * @fn          ZDSecMgrSwitchKeyInd
   2976           *
   2977           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2978           *
   2979           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2980           *
   2981           * @return      none
   2982           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2983          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2984          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2985            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000009                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   12....       LCALL   ??SSP_SwitchNwkKey?relay; Banked call to: SSP_SwitchNwkKey
   2986          
   2987            // Save if nv
   2988            ZDApp_NVUpdate();
   \   000016                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000016   12....       LCALL   ??ZDApp_NVUpdate?relay; Banked call to: ZDApp_NVUpdate
   2989          }
   \   000019   7F01         MOV     R7,#0x1
   \   00001B   02....       LJMP    ?BANKED_LEAVE_XDATA
   2990          
   2991          /******************************************************************************
   2992           * @fn          ZDSecMgrAuthenticateInd
   2993           *
   2994           * @brief       Process the ZDO_AuthenticateInd_t message.
   2995           *
   2996           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2997           *
   2998           * @return      none
   2999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3000          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3001          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3002            APSME_AuthenticateReq_t req;
   3003            AddrMgrEntry_t          entry;
   3004          
   3005          
   3006            // update the address manager
   3007            //---------------------------------------------------------------------------
   3008            // note:
   3009            // required for EA processing, but ultimately EA logic could also use the
   3010            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3011            // table is supposed to have authentication states for neighbors
   3012            //---------------------------------------------------------------------------
   3013            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3014            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   7408         MOV     A,#0x8
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E8           MOV     A,R0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E9           MOV     A,R1
   \   00002A   F0           MOVX    @DPTR,A
   3015            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \   00002B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00002B   EE           MOV     A,R6
   \   00002C   2404         ADD     A,#0x4
   \   00002E   FC           MOV     R4,A
   \   00002F   E4           CLR     A
   \   000030   3F           ADDC    A,R7
   \   000031   FD           MOV     R5,A
   \   000032   740A         MOV     A,#0xa
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   AA82         MOV     R2,DPL
   \   000039   AB83         MOV     R3,DPH
   \   00003B   12....       LCALL   ??AddrMgrExtAddrSet?relay; Banked call to: AddrMgrExtAddrSet
   3016          
   3017            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00003E                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003E   7407         MOV     A,#0x7
   \   000040   12....       LCALL   ?XSTACK_DISP101_8
   \   000043   12....       LCALL   ??AddrMgrEntryUpdate?relay; Banked call to: AddrMgrEntryUpdate
   \   000046   E9           MOV     A,R1
   \   000047   6401         XRL     A,#0x1
   \   000049   7048         JNZ     ??ZDSecMgrAuthenticateInd_0
   3018            {
   3019              // set request fields
   3020              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00004B   8E82         MOV     DPL,R6
   \   00004D   8F83         MOV     DPH,R7
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F8           MOV     R0,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F9           MOV     R1,A
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   E8           MOV     A,R0
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E9           MOV     A,R1
   \   000060   F0           MOVX    @DPTR,A
   3021              req.extAddr   = ind->aps.initExtAddr;
   \   000061   EE           MOV     A,R6
   \   000062   2404         ADD     A,#0x4
   \   000064   F8           MOV     R0,A
   \   000065   E4           CLR     A
   \   000066   3F           ADDC    A,R7
   \   000067   F9           MOV     R1,A
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E8           MOV     A,R0
   \   00006E   F0           MOVX    @DPTR,A
   \   00006F   A3           INC     DPTR
   \   000070   E9           MOV     A,R1
   \   000071   F0           MOVX    @DPTR,A
   3022              req.action    = APSME_EA_ACCEPT;
   \   000072   7406         MOV     A,#0x6
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   7401         MOV     A,#0x1
   \   000079   F0           MOVX    @DPTR,A
   3023              req.challenge = ind->aps.challenge;
   \   00007A   EE           MOV     A,R6
   \   00007B   240C         ADD     A,#0xc
   \   00007D   F8           MOV     R0,A
   \   00007E   E4           CLR     A
   \   00007F   3F           ADDC    A,R7
   \   000080   F9           MOV     R1,A
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   E8           MOV     A,R0
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   E9           MOV     A,R1
   \   00008A   F0           MOVX    @DPTR,A
   3024          
   3025              // start EA processing
   3026              APSME_AuthenticateReq( &req );
   \   00008B                ; Setup parameters for call to function APSME_AuthenticateReq
   \   00008B   AA..         MOV     R2,?XSP + 0
   \   00008D   AB..         MOV     R3,?XSP + 1
   \   00008F   12....       LCALL   ??APSME_AuthenticateReq?relay; Banked call to: APSME_AuthenticateReq
   \   000092   E9           MOV     A,R1
   3027            }
   3028          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   000093   7414         MOV     A,#0x14
   \   000095   12....       LCALL   ?DEALLOC_XSTACK8
   \   000098   7F01         MOV     R7,#0x1
   \   00009A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateCfm
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3034           *
   3035           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3040          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3041            if ( cfm->aps.status == ZSuccess )
   \   000009   EE           MOV     A,R6
   \   00000A   240B         ADD     A,#0xb
   \   00000C   F582         MOV     DPL,A
   \   00000E   E4           CLR     A
   \   00000F   3F           ADDC    A,R7
   \   000010   F583         MOV     DPH,A
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7020         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3042            {
   3043              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6401         XRL     A,#0x1
   \   00001E   7015         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   000020   90....       MOV     DPTR,#devState
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6405         XRL     A,#0x5
   \   000026   700D         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3044              {
   3045                // inform ZDO that device has been authenticated
   3046                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000028                ; Setup parameters for call to function osal_set_event
   \   000028   7A80         MOV     R2,#-0x80
   \   00002A   7B00         MOV     R3,#0x0
   \   00002C   90....       MOV     DPTR,#ZDAppTaskID
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F9           MOV     R1,A
   \   000031   12....       LCALL   ??osal_set_event?relay; Banked call to: osal_set_event
   \   000034   E9           MOV     A,R1
   3047              }
   3048            }
   3049          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   000035   7F01         MOV     R7,#0x1
   \   000037   02....       LJMP    ?BANKED_LEAVE_XDATA
   3050          
   3051          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3052          /******************************************************************************
   3053           * @fn          ZDSecMgrUpdateNwkKey
   3054           *
   3055           * @brief       Load a new NWK key and trigger a network wide update.
   3056           *
   3057           * @param       key       - [in] new NWK key
   3058           * @param       keySeqNum - [in] new NWK key sequence number
   3059           *
   3060           * @return      ZStatus_t
   3061           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3062          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrUpdateNwkKey:
   3063          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   89..         MOV     ?V3,R1
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   3064            ZStatus_t               status;
   3065            APSME_TransportKeyReq_t req;
   3066          
   3067            // initialize common elements of local variables
   3068            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3069              req.keyType   = KEY_TYPE_NWK_HIGH;
   3070            else
   3071              req.keyType   = KEY_TYPE_NWK;
   \   000014   7402         MOV     A,#0x2
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   7401         MOV     A,#0x1
   \   00001B   F0           MOVX    @DPTR,A
   3072          
   3073            req.dstAddr   = dstAddr;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   3074            req.keySeqNum = keySeqNum;
   \   000027   E5..         MOV     A,?V3
   \   000029   C0E0         PUSH    A
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   D0E0         POP     A
   \   000032   F0           MOVX    @DPTR,A
   3075            req.key       = key;
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E5..         MOV     A,?V0
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   A3           INC     DPTR
   \   00003C   E5..         MOV     A,?V1
   \   00003E   F0           MOVX    @DPTR,A
   3076            req.extAddr   = NULL;
   \   00003F   7406         MOV     A,#0x6
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   7400         MOV     A,#0x0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   7400         MOV     A,#0x0
   \   00004A   F0           MOVX    @DPTR,A
   3077            req.nwkSecure = TRUE;
   \   00004B   740A         MOV     A,#0xa
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   7401         MOV     A,#0x1
   \   000052   F0           MOVX    @DPTR,A
   3078            req.apsSecure = TRUE;
   \   000053   7409         MOV     A,#0x9
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   7401         MOV     A,#0x1
   \   00005A   F0           MOVX    @DPTR,A
   3079            req.tunnel    = NULL;
   \   00005B   740B         MOV     A,#0xb
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   7400         MOV     A,#0x0
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   7400         MOV     A,#0x0
   \   000066   F0           MOVX    @DPTR,A
   3080          
   3081            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3082            {
   3083              ZDSecMgrEntry_t*        entry;
   3084              uint16                  index;
   3085              AddrMgrEntry_t          addrEntry;
   3086          
   3087              addrEntry.user = ADDRMGR_USER_SECURITY;
   3088          
   3089              status = ZFailure;
   3090          
   3091              // verify data is available
   3092              if ( ZDSecMgrEntries != NULL )
   3093              {
   3094                // find available entry
   3095                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3096                {
   3097                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3098                  {
   3099                    // return successful result
   3100                    entry = &ZDSecMgrEntries[index];
   3101          
   3102                    // get NWK address
   3103                    addrEntry.index = entry->ami;
   3104                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3105                    {
   3106                      req.dstAddr = addrEntry.nwkAddr;
   3107                      req.extAddr = addrEntry.extAddr;
   3108                      status = APSME_TransportKeyReq( &req );
   3109                    }
   3110                  }
   3111                }
   3112              }
   3113            }
   3114            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3115            {
   3116              status = APSME_TransportKeyReq( &req );
   \   000067                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000067   AA..         MOV     R2,?XSP + 0
   \   000069   AB..         MOV     R3,?XSP + 1
   \   00006B   12....       LCALL   ??APSME_TransportKeyReq?relay; Banked call to: APSME_TransportKeyReq
   \   00006E   E9           MOV     A,R1
   \   00006F   F5..         MOV     ?V2,A
   3117            }
   3118          
   3119            SSP_UpdateNwkKey( key, keySeqNum );
   \   000071                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000071   A9..         MOV     R1,?V3
   \   000073   AA..         MOV     R2,?V0
   \   000075   AB..         MOV     R3,?V1
   \   000077   12....       LCALL   ??SSP_UpdateNwkKey?relay; Banked call to: SSP_UpdateNwkKey
   3120          
   3121            // Save if nv
   3122            ZDApp_NVUpdate();
   \   00007A                ; Setup parameters for call to function ZDApp_NVUpdate
   \   00007A   12....       LCALL   ??ZDApp_NVUpdate?relay; Banked call to: ZDApp_NVUpdate
   3123          
   3124            return status;
   \   00007D   A9..         MOV     R1,?V2
   \   00007F   740D         MOV     A,#0xd
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   7F04         MOV     R7,#0x4
   \   000086   02....       LJMP    ?BANKED_LEAVE_XDATA
   3125          }
   3126          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3127          
   3128          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3129          /******************************************************************************
   3130           * @fn          ZDSecMgrSwitchNwkKey
   3131           *
   3132           * @brief       Causes the NWK key to switch via a network wide command.
   3133           *
   3134           * @param       keySeqNum - [in] new NWK key sequence number
   3135           *
   3136           * @return      ZStatus_t
   3137           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3138          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrSwitchNwkKey:
   3139          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V1,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   3140            ZStatus_t            status;
   3141            APSME_SwitchKeyReq_t req;
   3142          
   3143            // initialize common elements of local variables
   3144            req.dstAddr = dstAddr;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   EE           MOV     A,R6
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   EF           MOV     A,R7
   \   00001A   F0           MOVX    @DPTR,A
   3145            req.keySeqNum = keySeqNum;
   \   00001B   E5..         MOV     A,?V1
   \   00001D   C0E0         PUSH    A
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   D0E0         POP     A
   \   000026   F0           MOVX    @DPTR,A
   3146          
   3147            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3148            {
   3149              ZDSecMgrEntry_t*     entry;
   3150              uint16               index;
   3151              AddrMgrEntry_t       addrEntry;
   3152          
   3153              addrEntry.user = ADDRMGR_USER_SECURITY;
   3154          
   3155              status = ZFailure;
   3156          
   3157              // verify data is available
   3158              if ( ZDSecMgrEntries != NULL )
   3159              {
   3160                // find available entry
   3161                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3162                {
   3163                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3164                  {
   3165                    // return successful result
   3166                    entry = &ZDSecMgrEntries[index];
   3167          
   3168                    // get NWK address
   3169                    addrEntry.index = entry->ami;
   3170          
   3171                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3172                    {
   3173                      req.dstAddr = addrEntry.nwkAddr;
   3174                      status = APSME_SwitchKeyReq( &req );
   3175                    }
   3176                  }
   3177                }
   3178              }
   3179            }
   3180            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3181            {
   3182              status = APSME_SwitchKeyReq( &req );
   \   000027                ; Setup parameters for call to function APSME_SwitchKeyReq
   \   000027   AA..         MOV     R2,?XSP + 0
   \   000029   AB..         MOV     R3,?XSP + 1
   \   00002B   12....       LCALL   ??APSME_SwitchKeyReq?relay; Banked call to: APSME_SwitchKeyReq
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V0,A
   3183            }
   3184          
   3185            SSP_SwitchNwkKey( keySeqNum );
   \   000031                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000031   A9..         MOV     R1,?V1
   \   000033   12....       LCALL   ??SSP_SwitchNwkKey?relay; Banked call to: SSP_SwitchNwkKey
   3186          
   3187            // Save if nv
   3188            ZDApp_NVUpdate();
   \   000036                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000036   12....       LCALL   ??ZDApp_NVUpdate?relay; Banked call to: ZDApp_NVUpdate
   3189          
   3190            return status;
   \   000039   A9..         MOV     R1,?V0
   \   00003B   7403         MOV     A,#0x3
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000040   7F02         MOV     R7,#0x2
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
   3191          }
   3192          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3193          
   3194          #if ( ZG_BUILD_JOINING_TYPE )
   3195          /******************************************************************************
   3196           * @fn          ZDSecMgrRequestAppKey
   3197           *
   3198           * @brief       Request an application key with partner.
   3199           *
   3200           * @param       partNwkAddr - [in] partner network address
   3201           *
   3202           * @return      ZStatus_t
   3203           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3204          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3205          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3206            ZStatus_t             status;
   3207            APSME_RequestKeyReq_t req;
   3208            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3209          
   3210          
   3211            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   00000E                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP102_8
   \   000013   EE           MOV     A,R6
   \   000014   FA           MOV     R2,A
   \   000015   EF           MOV     A,R7
   \   000016   FB           MOV     R3,A
   \   000017   12....       LCALL   ??AddrMgrExtAddrLookup?relay; Banked call to: AddrMgrExtAddrLookup
   \   00001A   E9           MOV     A,R1
   \   00001B   602C         JZ      ??ZDSecMgrRequestAppKey_0
   3212            {
   3213              req.dstAddr = 0;
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
   3214              req.keyType = KEY_TYPE_APP_MASTER;
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   7402         MOV     A,#0x2
   \   00002D   F0           MOVX    @DPTR,A
   3215              req.partExtAddr = partExtAddr;
   \   00002E   7404         MOV     A,#0x4
   \   000030   12....       LCALL   ?XSTACK_DISP100_8
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E8           MOV     A,R0
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   E9           MOV     A,R1
   \   00003C   F0           MOVX    @DPTR,A
   3216              status = APSME_RequestKeyReq( &req );
   \   00003D                ; Setup parameters for call to function APSME_RequestKeyReq
   \   00003D   AA..         MOV     R2,?XSP + 0
   \   00003F   AB..         MOV     R3,?XSP + 1
   \   000041   12....       LCALL   ??APSME_RequestKeyReq?relay; Banked call to: APSME_RequestKeyReq
   \   000044   E9           MOV     A,R1
   \   000045   F5..         MOV     ?V0,A
   \   000047   8003         SJMP    ??ZDSecMgrRequestAppKey_1
   3217            }
   3218            else
   3219            {
   3220              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   000049   75..01       MOV     ?V0,#0x1
   3221            }
   3222          
   3223            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   00004C   A9..         MOV     R1,?V0
   \   00004E   740C         MOV     A,#0xc
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
   \   000053   7F01         MOV     R7,#0x1
   \   000055   02....       LJMP    ?BANKED_LEAVE_XDATA
   3224          }
   3225          #endif // ( ZG_BUILD_JOINING_TYPE )
   3226          
   3227          #if ( ZG_BUILD_JOINING_TYPE )
   3228          /******************************************************************************
   3229           * @fn          ZDSecMgrSetupPartner
   3230           *
   3231           * @brief       Setup for application key partner.
   3232           *
   3233           * @param       partNwkAddr - [in] partner network address
   3234           *
   3235           * @return      ZStatus_t
   3236           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3237          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3238          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   8C..         MOV     ?V2,R4
   \   000010   8D..         MOV     ?V3,R5
   3239            AddrMgrEntry_t entry;
   3240            ZStatus_t      status;
   3241          
   3242            status = ZFailure;
   \   000012   7E01         MOV     R6,#0x1
   3243          
   3244            // update the address manager
   3245            entry.user    = ADDRMGR_USER_SECURITY;
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   7402         MOV     A,#0x2
   \   00001C   F0           MOVX    @DPTR,A
   3246            entry.nwkAddr = partNwkAddr;
   \   00001D   7401         MOV     A,#0x1
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E5..         MOV     A,?V0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E5..         MOV     A,?V1
   \   000028   F0           MOVX    @DPTR,A
   3247            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000029                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000029   AC..         MOV     R4,?V2
   \   00002B   AD..         MOV     R5,?V3
   \   00002D   7403         MOV     A,#0x3
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AA82         MOV     R2,DPL
   \   000034   AB83         MOV     R3,DPH
   \   000036   12....       LCALL   ??AddrMgrExtAddrSet?relay; Banked call to: AddrMgrExtAddrSet
   3248          
   3249            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000039                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000039   AA..         MOV     R2,?XSP + 0
   \   00003B   AB..         MOV     R3,?XSP + 1
   \   00003D   12....       LCALL   ??AddrMgrEntryUpdate?relay; Banked call to: AddrMgrEntryUpdate
   \   000040   E9           MOV     A,R1
   \   000041   6401         XRL     A,#0x1
   \   000043   7038         JNZ     ??ZDSecMgrSetupPartner_0
   3250            {
   3251              status = ZSuccess;
   \   000045   7E00         MOV     R6,#0x0
   3252          
   3253              // check for address discovery
   3254              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000047   74FE         MOV     A,#-0x2
   \   000049   65..         XRL     A,?V0
   \   00004B   7004         JNZ     ??ZDSecMgrSetupPartner_1
   \   00004D   74FF         MOV     A,#-0x1
   \   00004F   65..         XRL     A,?V1
   \                     ??ZDSecMgrSetupPartner_1:
   \   000051   7011         JNZ     ??ZDSecMgrSetupPartner_2
   3255              {
   3256                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000053                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000053   7D00         MOV     R5,#0x0
   \   000055   7C00         MOV     R4,#0x0
   \   000057   7900         MOV     R1,#0x0
   \   000059   AA..         MOV     R2,?V2
   \   00005B   AB..         MOV     R3,?V3
   \   00005D   12....       LCALL   ??ZDP_NwkAddrReq?relay; Banked call to: ZDP_NwkAddrReq
   \   000060   E9           MOV     A,R1
   \   000061   FE           MOV     R6,A
   \   000062   8019         SJMP    ??ZDSecMgrSetupPartner_0
   3257              }
   3258              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   000064                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000064   AA..         MOV     R2,?V2
   \   000066   AB..         MOV     R3,?V3
   \   000068   12....       LCALL   ??AddrMgrExtAddrValid?relay; Banked call to: AddrMgrExtAddrValid
   \   00006B   E9           MOV     A,R1
   \   00006C   700F         JNZ     ??ZDSecMgrSetupPartner_0
   3259              {
   3260                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00006E                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   00006E   7D00         MOV     R5,#0x0
   \   000070   7C00         MOV     R4,#0x0
   \   000072   7900         MOV     R1,#0x0
   \   000074   AA..         MOV     R2,?V0
   \   000076   AB..         MOV     R3,?V1
   \   000078   12....       LCALL   ??ZDP_IEEEAddrReq?relay; Banked call to: ZDP_IEEEAddrReq
   \   00007B   E9           MOV     A,R1
   \   00007C   FE           MOV     R6,A
   3261              }
   3262            }
   3263          
   3264            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   00007D   EE           MOV     A,R6
   \   00007E   F9           MOV     R1,A
   \   00007F   740D         MOV     A,#0xd
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   7F04         MOV     R7,#0x4
   \   000086   02....       LJMP    ?BANKED_LEAVE_XDATA
   3265          }
   3266          #endif // ( ZG_BUILD_JOINING_TYPE )
   3267          
   3268          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3269          /******************************************************************************
   3270           * @fn          ZDSecMgrAppKeyTypeSet
   3271           *
   3272           * @brief       Set application key type.
   3273           *
   3274           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3275           *                                                   KEY_TYPE_APP_LINK@3
   3276           *
   3277           * @return      ZStatus_t
   3278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3279          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   \                     ZDSecMgrAppKeyTypeSet:
   3280          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   3281            if ( keyType == KEY_TYPE_APP_LINK )
   \   000006   7403         MOV     A,#0x3
   \   000008   68           XRL     A,R0
   \   000009   7008         JNZ     ??ZDSecMgrAppKeyTypeSet_0
   3282            {
   3283              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   \   00000B   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00000E   7403         MOV     A,#0x3
   \   000010   F0           MOVX    @DPTR,A
   \   000011   8006         SJMP    ??ZDSecMgrAppKeyTypeSet_1
   3284            }
   3285            else
   3286            {
   3287              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   \                     ??ZDSecMgrAppKeyTypeSet_0:
   \   000013   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000016   7402         MOV     A,#0x2
   \   000018   F0           MOVX    @DPTR,A
   3288            }
   3289          
   3290            return ZSuccess;
   \                     ??ZDSecMgrAppKeyTypeSet_1:
   \   000019   7900         MOV     R1,#0x0
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET
   3291          }
   3292          #endif
   3293          
   3294          /******************************************************************************
   3295           * ZigBee Device Security Manager - Stub Implementations
   3296           */
   3297          /******************************************************************************
   3298           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3299           *
   3300           * @brief       Get MASTER key for specified EXT address.
   3301           *
   3302           * @param       extAddr - [in] EXT address
   3303           * @param       pKeyNvId - [out] MASTER key NV ID
   3304           *
   3305           * @return      ZStatus_t
   3306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3307          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   \                     APSME_MasterKeyGet:
   3308          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3309            ZStatus_t status;
   3310            uint16 ami;
   3311          
   3312          
   3313            // lookup entry for specified EXT address
   3314            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   000012                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000012   AC..         MOV     R4,?XSP + 0
   \   000014   AD..         MOV     R5,?XSP + 1
   \   000016   AA..         MOV     R2,?V0
   \   000018   AB..         MOV     R3,?V1
   \   00001A   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay; Banked call to: ZDSecMgrExtAddrLookup
   \   00001D   E9           MOV     A,R1
   \   00001E   F5..         MOV     ?V2,A
   3315          
   3316            if ( status == ZSuccess )
   \   000020   E5..         MOV     A,?V2
   \   000022   7015         JNZ     ??APSME_MasterKeyGet_0
   3317            {
   3318              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   \   000024                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000024   EE           MOV     A,R6
   \   000025   FC           MOV     R4,A
   \   000026   EF           MOV     A,R7
   \   000027   FD           MOV     R5,A
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   FA           MOV     R2,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FB           MOV     R3,A
   \   000033   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay; Banked call to: ZDSecMgrMasterKeyLookup
   \   000036   E9           MOV     A,R1
   \   000037   800B         SJMP    ??APSME_MasterKeyGet_1
   3319            }
   3320            else
   3321            {
   3322              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_MasterKeyGet_0:
   \   000039   8E82         MOV     DPL,R6
   \   00003B   8F83         MOV     DPH,R7
   \   00003D   7400         MOV     A,#0x0
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   7400         MOV     A,#0x0
   \   000043   F0           MOVX    @DPTR,A
   3323            }
   3324          
   3325            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000044   A9..         MOV     R1,?V2
   \   000046   7402         MOV     A,#0x2
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004B   7F03         MOV     R7,#0x3
   \   00004D   02....       LJMP    ?BANKED_LEAVE_XDATA
   3326          }
   3327          
   3328          /******************************************************************************
   3329           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3330           *
   3331           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3332           *
   3333           * @param       extAddr - [in] EXT address
   3334           * @param       data    - [in] APSME_LinkKeyData_t
   3335           *
   3336           * @return      ZStatus_t
   3337           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3338          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3339          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7406         MOV     A,#0x6
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   7404         MOV     A,#0x4
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   EC           MOV     A,R4
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   ED           MOV     A,R5
   \   00001D   F0           MOVX    @DPTR,A
   3340            ZStatus_t status;
   3341            ZDSecMgrEntry_t* entry;
   3342            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   \   00001E   75..00       MOV     ?V0,#0x0
   \   000021   75..00       MOV     ?V1,#0x0
   3343            uint16 Index;
   3344          
   3345            // lookup entry index for specified EXT address
   3346            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index ); 
   \   000024                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   000024   7402         MOV     A,#0x2
   \   000026   12....       LCALL   ?XSTACK_DISP100_8
   \   000029   88..         MOV     ?V4,R0
   \   00002B   89..         MOV     ?V5,R1
   \   00002D   78..         MOV     R0,#?V4
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   7402         MOV     A,#0x2
   \   000034   12....       LCALL   ?XSTACK_DISP102_8
   \   000037   7408         MOV     A,#0x8
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   ??ZDSecMgrEntryLookupExtGetIndex?relay; Banked call to: ZDSecMgrEntryLookupExtGetIndex
   \   000044   7402         MOV     A,#0x2
   \   000046   12....       LCALL   ?DEALLOC_XSTACK8
   \   000049   E9           MOV     A,R1
   \   00004A   F5..         MOV     ?V2,A
   3347          
   3348            if ( status == ZSuccess )
   \   00004C   E5..         MOV     A,?V2
   \   00004E   6003         JZ      $+5
   \   000050   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   3349            {
   3350              // point to NV item
   3351              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000053   7402         MOV     A,#0x2
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   E0           MOVX    A,@DPTR
   \   000059   2401         ADD     A,#0x1
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   3402         ADDC    A,#0x2
   \   000060   F9           MOV     R1,A
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FA           MOV     R2,A
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F583         MOV     DPH,A
   \   00006D   8A82         MOV     DPL,R2
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   E8           MOV     A,R0
   \   000072   F0           MOVX    @DPTR,A
   \   000073   A3           INC     DPTR
   \   000074   E9           MOV     A,R1
   \   000075   F0           MOVX    @DPTR,A
   3352          
   3353              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000076                ; Setup parameters for call to function osal_mem_alloc
   \   000076   7A18         MOV     R2,#0x18
   \   000078   7B00         MOV     R3,#0x0
   \   00007A   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00007D   8A..         MOV     ?V4,R2
   \   00007F   8B..         MOV     ?V5,R3
   \   000081   85....       MOV     ?V0,?V4
   \   000084   85....       MOV     ?V1,?V5
   3354          
   3355              if (pApsLinkKey != NULL)
   \   000087   E5..         MOV     A,?V0
   \   000089   45..         ORL     A,?V1
   \   00008B   7003         JNZ     $+5
   \   00008D   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   3356              {
   3357                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3358                osal_nv_read( entry->keyNvId, 0, 
   3359                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000090                ; Setup parameters for call to function osal_nv_read
   \   000090   78..         MOV     R0,#?V0
   \   000092   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000095   75..18       MOV     ?V4,#0x18
   \   000098   75..00       MOV     ?V5,#0x0
   \   00009B   78..         MOV     R0,#?V4
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   7C00         MOV     R4,#0x0
   \   0000A2   7D00         MOV     R5,#0x0
   \   0000A4   7404         MOV     A,#0x4
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F8           MOV     R0,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   F583         MOV     DPH,A
   \   0000AF   8882         MOV     DPL,R0
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   FA           MOV     R2,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   FB           MOV     R3,A
   \   0000B8   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   0000BB   7404         MOV     A,#0x4
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C0   E9           MOV     A,R1
   3360                
   3361                // set new values of the key 
   3362                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   0000C1                ; Setup parameters for call to function osal_memcpy
   \   0000C1   7404         MOV     A,#0x4
   \   0000C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F5..         MOV     ?V4,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   F5..         MOV     ?V5,A
   \   0000CD   75..00       MOV     ?V6,#0x0
   \   0000D0   78..         MOV     R0,#?V4
   \   0000D2   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D5   7C10         MOV     R4,#0x10
   \   0000D7   7D00         MOV     R5,#0x0
   \   0000D9   AA..         MOV     R2,?V0
   \   0000DB   AB..         MOV     R3,?V1
   \   0000DD   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000E0   7403         MOV     A,#0x3
   \   0000E2   12....       LCALL   ?DEALLOC_XSTACK8
   3363                pApsLinkKey->rxFrmCntr = 0;
   \   0000E5   7C00         MOV     R4,#0x0
   \   0000E7   7D00         MOV     R5,#0x0
   \   0000E9   7E00         MOV     R6,#0x0
   \   0000EB   7F00         MOV     R7,#0x0
   \   0000ED   E5..         MOV     A,?V0
   \   0000EF   2414         ADD     A,#0x14
   \   0000F1   F582         MOV     DPL,A
   \   0000F3   E4           CLR     A
   \   0000F4   35..         ADDC    A,?V1
   \   0000F6   F583         MOV     DPH,A
   \   0000F8   EC           MOV     A,R4
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   A3           INC     DPTR
   \   0000FB   ED           MOV     A,R5
   \   0000FC   F0           MOVX    @DPTR,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   EE           MOV     A,R6
   \   0000FF   F0           MOVX    @DPTR,A
   \   000100   A3           INC     DPTR
   \   000101   EF           MOV     A,R7
   \   000102   F0           MOVX    @DPTR,A
   3364                pApsLinkKey->txFrmCntr = 0;
   \   000103   7C00         MOV     R4,#0x0
   \   000105   7D00         MOV     R5,#0x0
   \   000107   7E00         MOV     R6,#0x0
   \   000109   7F00         MOV     R7,#0x0
   \   00010B   E5..         MOV     A,?V0
   \   00010D   2410         ADD     A,#0x10
   \   00010F   F582         MOV     DPL,A
   \   000111   E4           CLR     A
   \   000112   35..         ADDC    A,?V1
   \   000114   F583         MOV     DPH,A
   \   000116   EC           MOV     A,R4
   \   000117   F0           MOVX    @DPTR,A
   \   000118   A3           INC     DPTR
   \   000119   ED           MOV     A,R5
   \   00011A   F0           MOVX    @DPTR,A
   \   00011B   A3           INC     DPTR
   \   00011C   EE           MOV     A,R6
   \   00011D   F0           MOVX    @DPTR,A
   \   00011E   A3           INC     DPTR
   \   00011F   EF           MOV     A,R7
   \   000120   F0           MOVX    @DPTR,A
   3365                
   3366                osal_nv_write( entry->keyNvId, 0, 
   3367                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000121                ; Setup parameters for call to function osal_nv_write
   \   000121   78..         MOV     R0,#?V0
   \   000123   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000126   75..18       MOV     ?V4,#0x18
   \   000129   75..00       MOV     ?V5,#0x0
   \   00012C   78..         MOV     R0,#?V4
   \   00012E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000131   7C00         MOV     R4,#0x0
   \   000133   7D00         MOV     R5,#0x0
   \   000135   7404         MOV     A,#0x4
   \   000137   12....       LCALL   ?XSTACK_DISP0_8
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   F8           MOV     R0,A
   \   00013C   A3           INC     DPTR
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   F583         MOV     DPH,A
   \   000140   8882         MOV     DPL,R0
   \   000142   A3           INC     DPTR
   \   000143   A3           INC     DPTR
   \   000144   E0           MOVX    A,@DPTR
   \   000145   FA           MOV     R2,A
   \   000146   A3           INC     DPTR
   \   000147   E0           MOVX    A,@DPTR
   \   000148   FB           MOV     R3,A
   \   000149   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   00014C   7404         MOV     A,#0x4
   \   00014E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000151   E9           MOV     A,R1
   3368                
   3369                // clear copy of key in RAM 
   3370                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   000152                ; Setup parameters for call to function osal_memset
   \   000152   7C18         MOV     R4,#0x18
   \   000154   7D00         MOV     R5,#0x0
   \   000156   7900         MOV     R1,#0x0
   \   000158   AA..         MOV     R2,?V0
   \   00015A   AB..         MOV     R3,?V1
   \   00015C   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3371                
   3372                osal_mem_free(pApsLinkKey);
   \   00015F                ; Setup parameters for call to function osal_mem_free
   \   00015F   AA..         MOV     R2,?V0
   \   000161   AB..         MOV     R3,?V1
   \   000163   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3373                
   3374                // set initial values for counters in RAM
   3375                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   \   000166   7C00         MOV     R4,#0x0
   \   000168   7D00         MOV     R5,#0x0
   \   00016A   7E00         MOV     R6,#0x0
   \   00016C   7F00         MOV     R7,#0x0
   \   00016E   85..82       MOV     DPL,?XSP + 0
   \   000171   85..83       MOV     DPH,?XSP + 1
   \   000174   E0           MOVX    A,@DPTR
   \   000175   F8           MOV     R0,A
   \   000176   A3           INC     DPTR
   \   000177   E0           MOVX    A,@DPTR
   \   000178   F583         MOV     DPH,A
   \   00017A   8882         MOV     DPL,R0
   \   00017C   A3           INC     DPTR
   \   00017D   A3           INC     DPTR
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   F8           MOV     R0,A
   \   000180   A3           INC     DPTR
   \   000181   E0           MOVX    A,@DPTR
   \   000182   F9           MOV     R1,A
   \   000183   E8           MOV     A,R0
   \   000184   75F009       MOV     B,#0x9
   \   000187   A4           MUL     AB
   \   000188   C8           XCH     A,R0
   \   000189   AAF0         MOV     R2,B
   \   00018B   75F000       MOV     B,#0x0
   \   00018E   A4           MUL     AB
   \   00018F   2A           ADD     A,R2
   \   000190   FA           MOV     R2,A
   \   000191   75F009       MOV     B,#0x9
   \   000194   E9           MOV     A,R1
   \   000195   A4           MUL     AB
   \   000196   2A           ADD     A,R2
   \   000197   F9           MOV     R1,A
   \   000198   74..         MOV     A,#(ApsLinkKeyFrmCntr + 247) & 0xff
   \   00019A   28           ADD     A,R0
   \   00019B   F582         MOV     DPL,A
   \   00019D   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4617) >> 8) & 0xff
   \   00019F   39           ADDC    A,R1
   \   0001A0   F583         MOV     DPH,A
   \   0001A2   EC           MOV     A,R4
   \   0001A3   F0           MOVX    @DPTR,A
   \   0001A4   A3           INC     DPTR
   \   0001A5   ED           MOV     A,R5
   \   0001A6   F0           MOVX    @DPTR,A
   \   0001A7   A3           INC     DPTR
   \   0001A8   EE           MOV     A,R6
   \   0001A9   F0           MOVX    @DPTR,A
   \   0001AA   A3           INC     DPTR
   \   0001AB   EF           MOV     A,R7
   \   0001AC   F0           MOVX    @DPTR,A
   3376                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \   0001AD   7C00         MOV     R4,#0x0
   \   0001AF   7D00         MOV     R5,#0x0
   \   0001B1   7E00         MOV     R6,#0x0
   \   0001B3   7F00         MOV     R7,#0x0
   \   0001B5   85..82       MOV     DPL,?XSP + 0
   \   0001B8   85..83       MOV     DPH,?XSP + 1
   \   0001BB   E0           MOVX    A,@DPTR
   \   0001BC   F8           MOV     R0,A
   \   0001BD   A3           INC     DPTR
   \   0001BE   E0           MOVX    A,@DPTR
   \   0001BF   F583         MOV     DPH,A
   \   0001C1   8882         MOV     DPL,R0
   \   0001C3   A3           INC     DPTR
   \   0001C4   A3           INC     DPTR
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   F8           MOV     R0,A
   \   0001C7   A3           INC     DPTR
   \   0001C8   E0           MOVX    A,@DPTR
   \   0001C9   F9           MOV     R1,A
   \   0001CA   E8           MOV     A,R0
   \   0001CB   75F009       MOV     B,#0x9
   \   0001CE   A4           MUL     AB
   \   0001CF   C8           XCH     A,R0
   \   0001D0   AAF0         MOV     R2,B
   \   0001D2   75F000       MOV     B,#0x0
   \   0001D5   A4           MUL     AB
   \   0001D6   2A           ADD     A,R2
   \   0001D7   FA           MOV     R2,A
   \   0001D8   75F009       MOV     B,#0x9
   \   0001DB   E9           MOV     A,R1
   \   0001DC   A4           MUL     AB
   \   0001DD   2A           ADD     A,R2
   \   0001DE   F9           MOV     R1,A
   \   0001DF   74..         MOV     A,#(ApsLinkKeyFrmCntr + 251) & 0xff
   \   0001E1   28           ADD     A,R0
   \   0001E2   F582         MOV     DPL,A
   \   0001E4   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4613) >> 8) & 0xff
   \   0001E6   39           ADDC    A,R1
   \   0001E7   F583         MOV     DPH,A
   \   0001E9   EC           MOV     A,R4
   \   0001EA   F0           MOVX    @DPTR,A
   \   0001EB   A3           INC     DPTR
   \   0001EC   ED           MOV     A,R5
   \   0001ED   F0           MOVX    @DPTR,A
   \   0001EE   A3           INC     DPTR
   \   0001EF   EE           MOV     A,R6
   \   0001F0   F0           MOVX    @DPTR,A
   \   0001F1   A3           INC     DPTR
   \   0001F2   EF           MOV     A,R7
   \   0001F3   F0           MOVX    @DPTR,A
   3377              }
   3378            }
   3379          
   3380            return status;
   \                     ??APSME_LinkKeySet_0:
   \   0001F4   A9..         MOV     R1,?V2
   \   0001F6   7408         MOV     A,#0x8
   \   0001F8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FB   7F07         MOV     R7,#0x7
   \   0001FD   02....       LJMP    ?BANKED_LEAVE_XDATA
   3381          }
   3382          
   3383          /******************************************************************************
   3384           * @fn          ZDSecMgrAuthenticationSet
   3385           *
   3386           * @brief       Mark the specific device as authenticated or not
   3387           *
   3388           * @param       extAddr - [in] EXT address
   3389           * @param       option  - [in] authenticated or not
   3390           *
   3391           * @return      ZStatus_t
   3392           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3393          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3394          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V1,R1
   3395            ZStatus_t        status;
   3396            ZDSecMgrEntry_t* entry;
   3397          
   3398          
   3399            // lookup entry index for specified EXT address
   3400            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000010   AC..         MOV     R4,?XSP + 0
   \   000012   AD..         MOV     R5,?XSP + 1
   \   000014   EE           MOV     A,R6
   \   000015   FA           MOV     R2,A
   \   000016   EF           MOV     A,R7
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay; Banked call to: ZDSecMgrEntryLookupExt
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0,A
   3401          
   3402            if ( status == ZSuccess )
   \   00001E   E5..         MOV     A,?V0
   \   000020   7019         JNZ     ??ZDSecMgrAuthenticationSet_0
   3403            {
   3404              entry->authenticateOption = option;
   \   000022   E5..         MOV     A,?V1
   \   000024   C0E0         PUSH    A
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F583         MOV     DPH,A
   \   000032   8882         MOV     DPL,R0
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   D0E0         POP     A
   \   00003A   F0           MOVX    @DPTR,A
   3405            }
   3406          
   3407            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   00003B   A9..         MOV     R1,?V0
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000042   7F02         MOV     R7,#0x2
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
   3408          }
   3409          
   3410          /******************************************************************************
   3411           * @fn          ZDSecMgrAuthenticationCheck
   3412           *
   3413           * @brief       Check if the specific device has been authenticated or not
   3414           *              For non-trust center device, always return true
   3415           *
   3416           * @param       shortAddr - [in] short address
   3417           *
   3418           * @return      TRUE @ authenticated with CBKE
   3419           *              FALSE @ not authenticated
   3420           */
   3421          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3422          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3423          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3424          #if defined (TC_LINKKEY_JOIN)
   3425          
   3426            ZDSecMgrEntry_t* entry;
   3427            uint8 extAddr[Z_EXTADDR_LEN];
   3428          
   3429            // If the local device is not the trust center, always return TRUE
   3430            if ( NLME_GetShortAddr() != TCshortAddr )
   3431            {
   3432              return TRUE;
   3433            }
   3434            // Otherwise, check the authentication option
   3435            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3436            {
   3437              // lookup entry index for specified EXT address
   3438              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3439              {
   3440                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3441                {
   3442                  return TRUE;
   3443                }
   3444                else
   3445                {
   3446                  return FALSE;
   3447                }
   3448              }
   3449            }
   3450            return FALSE;
   3451          
   3452          #else
   3453            (void)shortAddr;  // Intentionally unreferenced parameter
   3454            
   3455            // For non AMI/SE Profile, perform no check and always return true.
   3456            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3457          
   3458          #endif // TC_LINKKEY_JOIN
   3459          }
   3460          
   3461          
   3462          /******************************************************************************
   3463           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3464           *
   3465           * @brief       Get Key NV ID for specified NWK address.
   3466           *
   3467           * @param       extAddr - [in] EXT address
   3468           * @param       keyNvId - [out] NV ID
   3469           *
   3470           * @return      ZStatus_t
   3471           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3472          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   3473          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3474            ZStatus_t status;
   3475            ZDSecMgrEntry_t* entry;
   3476          
   3477            // lookup entry index for specified NWK address
   3478            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000012                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000012   AC..         MOV     R4,?XSP + 0
   \   000014   AD..         MOV     R5,?XSP + 1
   \   000016   AA..         MOV     R2,?V0
   \   000018   AB..         MOV     R3,?V1
   \   00001A   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay; Banked call to: ZDSecMgrEntryLookupExt
   \   00001D   E9           MOV     A,R1
   \   00001E   F5..         MOV     ?V2,A
   3479          
   3480            if ( status == ZSuccess )
   \   000020   E5..         MOV     A,?V2
   \   000022   7020         JNZ     ??APSME_LinkKeyNVIdGet_0
   3481            {
   3482              // return the index to the NV table
   3483              *pKeyNvId = entry->keyNvId;
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F583         MOV     DPH,A
   \   000030   8882         MOV     DPL,R0
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F8           MOV     R0,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F9           MOV     R1,A
   \   000039   8E82         MOV     DPL,R6
   \   00003B   8F83         MOV     DPH,R7
   \   00003D   E8           MOV     A,R0
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   E9           MOV     A,R1
   \   000041   F0           MOVX    @DPTR,A
   \   000042   800B         SJMP    ??APSME_LinkKeyNVIdGet_1
   3484            }
   3485            else
   3486            {
   3487              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   7400         MOV     A,#0x0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   7400         MOV     A,#0x0
   \   00004E   F0           MOVX    @DPTR,A
   3488            }
   3489          
   3490            return status;
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   00004F   A9..         MOV     R1,?V2
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   \   000056   7F03         MOV     R7,#0x3
   \   000058   02....       LJMP    ?BANKED_LEAVE_XDATA
   3491          }
   3492          
   3493          /******************************************************************************
   3494           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3495           *
   3496           * @brief       Verifies if Link Key in NV has been set.
   3497           *
   3498           * @param       extAddr - [in] EXT address
   3499           *
   3500           * @return      TRUE - Link Key has been established
   3501           *              FALSE - Link Key in NV has default value.
   3502           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3503          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   3504          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V6,R2
   \   00000C   8B..         MOV     ?V7,R3
   3505            APSME_LinkKeyData_t *pKeyData = NULL;
   \   00000E   75..00       MOV     ?V4,#0x0
   \   000011   75..00       MOV     ?V5,#0x0
   3506            uint16 apsLinkKeyNvId;
   3507            uint8 nullKey[SEC_KEY_LEN];
   3508            uint8 status = FALSE;
   \   000014   7E00         MOV     R6,#0x0
   3509          
   3510            // initialize default vealue to compare to
   3511            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000016                ; Setup parameters for call to function osal_memset
   \   000016   7C10         MOV     R4,#0x10
   \   000018   7D00         MOV     R5,#0x0
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP101_8
   \   000021   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3512          
   3513            // check for APS link NV ID
   3514            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   000024                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   000024   AC..         MOV     R4,?XSP + 0
   \   000026   AD..         MOV     R5,?XSP + 1
   \   000028   AA..         MOV     R2,?V6
   \   00002A   AB..         MOV     R3,?V7
   \   00002C   12....       LCALL   ??APSME_LinkKeyNVIdGet?relay; Banked call to: APSME_LinkKeyNVIdGet
   \   00002F   E9           MOV     A,R1
   3515          
   3516            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   000030   85..82       MOV     DPL,?XSP + 0
   \   000033   85..83       MOV     DPH,?XSP + 1
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F8           MOV     R0,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F9           MOV     R1,A
   \   00003B   E8           MOV     A,R0
   \   00003C   49           ORL     A,R1
   \   00003D   606E         JZ      ??APSME_IsLinkKeyValid_0
   3517            {
   3518              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00003F                ; Setup parameters for call to function osal_mem_alloc
   \   00003F   7A18         MOV     R2,#0x18
   \   000041   7B00         MOV     R3,#0x0
   \   000043   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000046   8A..         MOV     ?V0,R2
   \   000048   8B..         MOV     ?V1,R3
   \   00004A   85....       MOV     ?V4,?V0
   \   00004D   85....       MOV     ?V5,?V1
   3519              
   3520              if (pKeyData != NULL)
   \   000050   E5..         MOV     A,?V4
   \   000052   45..         ORL     A,?V5
   \   000054   6057         JZ      ??APSME_IsLinkKeyValid_0
   3521              {
   3522                // retrieve key from NV
   3523                if ( osal_nv_read( apsLinkKeyNvId, 0, 
   3524                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   000056                ; Setup parameters for call to function osal_nv_read
   \   000056   78..         MOV     R0,#?V4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..18       MOV     ?V0,#0x18
   \   00005E   75..00       MOV     ?V1,#0x0
   \   000061   78..         MOV     R0,#?V0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C00         MOV     R4,#0x0
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7404         MOV     A,#0x4
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   FA           MOV     R2,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   FB           MOV     R3,A
   \   000074   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000077   7404         MOV     A,#0x4
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007C   E9           MOV     A,R1
   \   00007D   702E         JNZ     ??APSME_IsLinkKeyValid_0
   3525                {
   3526                  // if stored key is different than default value, then a key has been established
   3527                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   00007F                ; Setup parameters for call to function osal_memcmp
   \   00007F   7402         MOV     A,#0x2
   \   000081   12....       LCALL   ?XSTACK_DISP100_8
   \   000084   88..         MOV     ?V0,R0
   \   000086   89..         MOV     ?V1,R1
   \   000088   75..00       MOV     ?V2,#0x0
   \   00008B   78..         MOV     R0,#?V0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000090   7C10         MOV     R4,#0x10
   \   000092   7D00         MOV     R5,#0x0
   \   000094   85..82       MOV     DPL,?V4
   \   000097   85..83       MOV     DPH,?V5
   \   00009A   A982         MOV     R1,DPL
   \   00009C   AA83         MOV     R2,DPH
   \   00009E   7B00         MOV     R3,#0x0
   \   0000A0   12....       LCALL   ??osal_memcmp?relay  ; Banked call to: osal_memcmp
   \   0000A3   7403         MOV     A,#0x3
   \   0000A5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A8   E9           MOV     A,R1
   \   0000A9   7002         JNZ     ??APSME_IsLinkKeyValid_0
   3528                  {
   3529                    status = TRUE;
   \   0000AB   7E01         MOV     R6,#0x1
   3530                  }
   3531                }
   3532              }
   3533            }
   3534          
   3535            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   0000AD   EE           MOV     A,R6
   \   0000AE   F9           MOV     R1,A
   \   0000AF   7412         MOV     A,#0x12
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B4   7F08         MOV     R7,#0x8
   \   0000B6   02....       LJMP    ?BANKED_LEAVE_XDATA
   3536          }
   3537          
   3538          /******************************************************************************
   3539           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3540           *
   3541           * @brief       Verify and process key transportation to child.
   3542           *
   3543           * @param       ind - [in] APSME_TransportKeyInd_t
   3544           *
   3545           * @return      uint8 - success(TRUE:FALSE)
   3546           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3547          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3548          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3549            uint8 success;
   3550          
   3551            success = FALSE;
   \   000009   75..00       MOV     ?V0,#0x0
   3552          
   3553            // verify from Trust Center
   3554            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000C   8E82         MOV     DPL,R6
   \   00000E   8F83         MOV     DPH,R7
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F8           MOV     R0,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   49           ORL     A,R1
   \   000017   7039         JNZ     ??APSME_KeyFwdToChild_0
   3555            {
   3556              success = TRUE;
   \   000019   75..01       MOV     ?V0,#0x1
   3557          
   3558              // check for initial NWK key
   3559              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3560                   ( ind->keyType == 6                 ) ||
   3561                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6401         XRL     A,#0x1
   \   000025   6016         JZ      ??APSME_KeyFwdToChild_1
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6406         XRL     A,#0x6
   \   000030   600B         JZ      ??APSME_KeyFwdToChild_1
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   6405         XRL     A,#0x5
   \   00003B   7015         JNZ     ??APSME_KeyFwdToChild_0
   3562              {
   3563                // set association status to authenticated
   3564                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00003D                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00003D                ; Setup parameters for call to function AssocGetWithExt
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   FA           MOV     R2,A
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   FB           MOV     R3,A
   \   00004C   12....       LCALL   ??AssocGetWithExt?relay; Banked call to: AssocGetWithExt
   \   00004F   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay; Banked call to: ZDSecMgrAssocDeviceAuth
   3565              }
   3566            }
   3567          
   3568            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000052   A9..         MOV     R1,?V0
   \   000054   7F01         MOV     R7,#0x1
   \   000056   02....       LJMP    ?BANKED_LEAVE_XDATA
   3569          }
   3570          
   3571          /******************************************************************************
   3572           * @fn          ZDSecMgrAddLinkKey
   3573           *
   3574           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3575           *              as authenticated in the authenticateOption. Note that this function
   3576           *              is hardwared to CBKE right now.
   3577           *
   3578           * @param       shortAddr - short address of the partner device
   3579           * @param       extAddr - extended address of the partner device
   3580           * @param       key - link key
   3581           *
   3582           * @return      ZStatus_t
   3583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3584          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3585          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V3,A
   3586            uint16           ami;
   3587            ZDSecMgrEntry_t* entry;
   3588          
   3589            /* Store the device address in the addr manager */
   3590            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP100_8
   \   000023   88..         MOV     ?V4,R0
   \   000025   89..         MOV     ?V5,R1
   \   000027   78..         MOV     R0,#?V4
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   EE           MOV     A,R6
   \   00002D   FC           MOV     R4,A
   \   00002E   EF           MOV     A,R7
   \   00002F   FD           MOV     R5,A
   \   000030   AA..         MOV     R2,?V0
   \   000032   AB..         MOV     R3,?V1
   \   000034   12....       LCALL   ??ZDSecMgrAddrStore?relay; Banked call to: ZDSecMgrAddrStore
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003C   E9           MOV     A,R1
   \   00003D   6004         JZ      ??ZDSecMgrAddLinkKey_0
   3591            {
   3592              /* Adding to Addr Manager fails */
   3593              return ZFailure;
   \   00003F   7901         MOV     R1,#0x1
   \   000041   805C         SJMP    ??ZDSecMgrAddLinkKey_1
   3594            }
   3595          
   3596            /* Lookup entry using specified address index */
   3597            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000043                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000043   AC..         MOV     R4,?XSP + 0
   \   000045   AD..         MOV     R5,?XSP + 1
   \   000047   7402         MOV     A,#0x2
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   FA           MOV     R2,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FB           MOV     R3,A
   \   000051   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay; Banked call to: ZDSecMgrEntryLookupAMI
   \   000054   E9           MOV     A,R1
   3598          
   3599            // If no existing entry, create one
   3600            if ( entry == NULL )
   \   000055   85..82       MOV     DPL,?XSP + 0
   \   000058   85..83       MOV     DPH,?XSP + 1
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   E8           MOV     A,R0
   \   000061   49           ORL     A,R1
   \   000062   702D         JNZ     ??ZDSecMgrAddLinkKey_2
   3601            {
   3602              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000064                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000064   AA..         MOV     R2,?XSP + 0
   \   000066   AB..         MOV     R3,?XSP + 1
   \   000068   12....       LCALL   ??ZDSecMgrEntryNew?relay; Banked call to: ZDSecMgrEntryNew
   \   00006B   E9           MOV     A,R1
   \   00006C   701F         JNZ     ??ZDSecMgrAddLinkKey_3
   3603              {
   3604                entry->ami = ami;
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E0           MOVX    A,@DPTR
   \   000074   FA           MOV     R2,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   FB           MOV     R3,A
   \   000078   85..82       MOV     DPL,?XSP + 0
   \   00007B   85..83       MOV     DPH,?XSP + 1
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F8           MOV     R0,A
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F583         MOV     DPH,A
   \   000084   8882         MOV     DPL,R0
   \   000086   EA           MOV     A,R2
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   EB           MOV     A,R3
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   8004         SJMP    ??ZDSecMgrAddLinkKey_2
   3605              }
   3606              else
   3607              {
   3608                /* Security Manager full */
   3609                return ZBufferFull;
   \                     ??ZDSecMgrAddLinkKey_3:
   \   00008D   7911         MOV     R1,#0x11
   \   00008F   800E         SJMP    ??ZDSecMgrAddLinkKey_1
   3610              }
   3611            }
   3612            // Write the link key
   3613            APSME_LinkKeySet( extAddr, key );
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000091                ; Setup parameters for call to function APSME_LinkKeySet
   \   000091   AC..         MOV     R4,?V2
   \   000093   AD..         MOV     R5,?V3
   \   000095   EE           MOV     A,R6
   \   000096   FA           MOV     R2,A
   \   000097   EF           MOV     A,R7
   \   000098   FB           MOV     R3,A
   \   000099   12....       LCALL   ??APSME_LinkKeySet?relay; Banked call to: APSME_LinkKeySet
   \   00009C   E9           MOV     A,R1
   3614          
   3615          #if defined (TC_LINKKEY_JOIN)
   3616            // Mark the device as authenticated.
   3617            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3618          #endif
   3619          
   3620          #if defined NV_RESTORE
   3621            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3622          #endif
   3623            
   3624            return ZSuccess;
   \   00009D   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   00009F   7404         MOV     A,#0x4
   \   0000A1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A4   7F06         MOV     R7,#0x6
   \   0000A6   02....       LJMP    ?BANKED_LEAVE_XDATA
   3625          }
   3626          
   3627          #if defined ( NV_RESTORE )
   3628          /******************************************************************************
   3629           * @fn          ZDSecMgrInitNV
   3630           *
   3631           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3632           *
   3633           * @param       none
   3634           *
   3635           * @return      uint8 - <osal_nv_item_init> return codes
   3636           */
   3637          uint8 ZDSecMgrInitNV(void)
   3638          {
   3639            
   3640            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3641                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3642            
   3643            // If the item does not already exist, set all values to 0 
   3644            if (rtrn != SUCCESS)  
   3645            {
   3646              nvDeviceListHdr_t hdr;
   3647              hdr.numRecs = 0;
   3648              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3649            }
   3650          
   3651            return rtrn;
   3652          }
   3653          #endif // NV_RESTORE
   3654          
   3655          #if defined ( NV_RESTORE )
   3656          /*********************************************************************
   3657           * @fn      ZDSecMgrWriteNV()
   3658           *
   3659           * @brief   Save off the APS link key list to NV
   3660           *
   3661           * @param   none
   3662           *
   3663           * @return  none
   3664           */
   3665          static void ZDSecMgrWriteNV( void )
   3666          {
   3667            uint16 i;
   3668            nvDeviceListHdr_t hdr;
   3669          
   3670            hdr.numRecs = 0;
   3671          
   3672            if (ZDSecMgrEntries != NULL)
   3673            {
   3674              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3675              {
   3676                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3677                {
   3678                  // Save off the record
   3679                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3680                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3681                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3682                  hdr.numRecs++;
   3683                }
   3684              }
   3685            }
   3686          
   3687            // Save off the header
   3688            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3689          }
   3690          #endif // NV_RESTORE
   3691          
   3692          #if defined ( NV_RESTORE )
   3693          /******************************************************************************
   3694           * @fn          ZDSecMgrRestoreFromNV
   3695           *
   3696           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3697           *              the key data itself as they remain in NV until they are used. 
   3698           *              Only list data is restored.
   3699           *
   3700           * @param       none
   3701           *
   3702           * @return      None.
   3703           */
   3704          static void ZDSecMgrRestoreFromNV( void )
   3705          {
   3706            nvDeviceListHdr_t hdr;
   3707            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3708            
   3709            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3710                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3711            {
   3712              uint8 x;
   3713          
   3714              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3715              
   3716              for (x = 0; x < hdr.numRecs; x++)
   3717              {
   3718                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3719                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3720                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3721                {
   3722                  // update data only for valid entries 
   3723                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3724                  {
   3725                    if (pApsLinkKey != NULL)
   3726                    {
   3727                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3728                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0, 
   3729                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3730                      
   3731                      // set new values for the counter 
   3732                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3733          
   3734                      // restore values for counters in RAM
   3735                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 
   3736                                                      pApsLinkKey->txFrmCntr;
   3737          
   3738                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 
   3739                                                      pApsLinkKey->rxFrmCntr;
   3740                      
   3741                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0, 
   3742                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3743                      
   3744                      // clear copy of key in RAM 
   3745                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3746                    }
   3747                  }
   3748                }
   3749              }
   3750              
   3751              if (pApsLinkKey != NULL)
   3752              {
   3753                osal_mem_free(pApsLinkKey);
   3754              }    
   3755            }
   3756          }
   3757          #endif // NV_RESTORE
   3758          
   3759          /*********************************************************************
   3760           * @fn          ZDSecMgrSetDefaultNV
   3761           *
   3762           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3763           *
   3764           * @param       none
   3765           *
   3766           * @return      none
   3767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3768          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3769          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3770            uint16 i;
   3771            nvDeviceListHdr_t hdr;
   3772            ZDSecMgrEntry_t secMgrEntry;
   3773            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   \   00000A   75..00       MOV     ?V0,#0x0
   \   00000D   75..00       MOV     ?V1,#0x0
   3774              
   3775            // Initialize the header
   3776            hdr.numRecs = 0;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
   3777          
   3778            // clear the header
   3779            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   00001D                ; Setup parameters for call to function osal_nv_write
   \   00001D   A8..         MOV     R0,?XSP + 0
   \   00001F   A9..         MOV     R1,?XSP + 1
   \   000021   88..         MOV     ?V2,R0
   \   000023   89..         MOV     ?V3,R1
   \   000025   78..         MOV     R0,#?V2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   75..02       MOV     ?V2,#0x2
   \   00002D   75..00       MOV     ?V3,#0x0
   \   000030   78..         MOV     R0,#?V2
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   7C00         MOV     R4,#0x0
   \   000037   7D00         MOV     R5,#0x0
   \   000039   7A4C         MOV     R2,#0x4c
   \   00003B   7B00         MOV     R3,#0x0
   \   00003D   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000040   7404         MOV     A,#0x4
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   E9           MOV     A,R1
   3780            
   3781            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   000046                ; Setup parameters for call to function osal_memset
   \   000046   7C05         MOV     R4,#0x5
   \   000048   7D00         MOV     R5,#0x0
   \   00004A   7900         MOV     R1,#0x0
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP101_8
   \   000051   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3782          
   3783            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000054   7E00         MOV     R6,#0x0
   \   000056   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   000058   C3           CLR     C
   \   000059   EE           MOV     A,R6
   \   00005A   9403         SUBB    A,#0x3
   \   00005C   EF           MOV     A,R7
   \   00005D   9400         SUBB    A,#0x0
   \   00005F   504D         JNC     ??ZDSecMgrSetDefaultNV_1
   3784            {
   3785              // Clear the record
   3786              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3787                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3788                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \   000061                ; Setup parameters for call to function osal_nv_write
   \   000061   7402         MOV     A,#0x2
   \   000063   12....       LCALL   ?XSTACK_DISP100_8
   \   000066   88..         MOV     ?V2,R0
   \   000068   89..         MOV     ?V3,R1
   \   00006A   78..         MOV     R0,#?V2
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006F   75..05       MOV     ?V2,#0x5
   \   000072   75..00       MOV     ?V3,#0x0
   \   000075   78..         MOV     R0,#?V2
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   EE           MOV     A,R6
   \   00007B   F8           MOV     R0,A
   \   00007C   EF           MOV     A,R7
   \   00007D   F9           MOV     R1,A
   \   00007E   E8           MOV     A,R0
   \   00007F   75F005       MOV     B,#0x5
   \   000082   A4           MUL     AB
   \   000083   C8           XCH     A,R0
   \   000084   AAF0         MOV     R2,B
   \   000086   75F000       MOV     B,#0x0
   \   000089   A4           MUL     AB
   \   00008A   2A           ADD     A,R2
   \   00008B   FA           MOV     R2,A
   \   00008C   75F005       MOV     B,#0x5
   \   00008F   E9           MOV     A,R1
   \   000090   A4           MUL     AB
   \   000091   2A           ADD     A,R2
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   2402         ADD     A,#0x2
   \   000096   FC           MOV     R4,A
   \   000097   E4           CLR     A
   \   000098   39           ADDC    A,R1
   \   000099   FD           MOV     R5,A
   \   00009A   7A4C         MOV     R2,#0x4c
   \   00009C   7B00         MOV     R3,#0x0
   \   00009E   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A6   E9           MOV     A,R1
   3789            }
   \   0000A7   0E           INC     R6
   \   0000A8   EE           MOV     A,R6
   \   0000A9   70AD         JNZ     ??ZDSecMgrSetDefaultNV_0
   \   0000AB   0F           INC     R7
   \   0000AC   80AA         SJMP    ??ZDSecMgrSetDefaultNV_0
   3790          
   3791            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   0000AE                ; Setup parameters for call to function osal_mem_alloc
   \   0000AE   7A18         MOV     R2,#0x18
   \   0000B0   7B00         MOV     R3,#0x0
   \   0000B2   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   0000B5   8A..         MOV     ?V2,R2
   \   0000B7   8B..         MOV     ?V3,R3
   \   0000B9   85....       MOV     ?V0,?V2
   \   0000BC   85....       MOV     ?V1,?V3
   3792          
   3793            if (pApsLinkKey != NULL)
   \   0000BF   E5..         MOV     A,?V0
   \   0000C1   45..         ORL     A,?V1
   \   0000C3   604D         JZ      ??ZDSecMgrSetDefaultNV_2
   3794            {
   3795              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000C5                ; Setup parameters for call to function osal_memset
   \   0000C5   7C18         MOV     R4,#0x18
   \   0000C7   7D00         MOV     R5,#0x0
   \   0000C9   7900         MOV     R1,#0x0
   \   0000CB   AA..         MOV     R2,?V0
   \   0000CD   AB..         MOV     R3,?V1
   \   0000CF   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3796          
   3797              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   0000D2   7E00         MOV     R6,#0x0
   \   0000D4   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSetDefaultNV_3:
   \   0000D6   C3           CLR     C
   \   0000D7   EE           MOV     A,R6
   \   0000D8   9403         SUBB    A,#0x3
   \   0000DA   EF           MOV     A,R7
   \   0000DB   9400         SUBB    A,#0x0
   \   0000DD   502C         JNC     ??ZDSecMgrSetDefaultNV_4
   3798              {
   3799                // Clear the record
   3800                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3801                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   0000DF                ; Setup parameters for call to function osal_nv_write
   \   0000DF   78..         MOV     R0,#?V0
   \   0000E1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E4   75..18       MOV     ?V2,#0x18
   \   0000E7   75..00       MOV     ?V3,#0x0
   \   0000EA   78..         MOV     R0,#?V2
   \   0000EC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EF   7C00         MOV     R4,#0x0
   \   0000F1   7D00         MOV     R5,#0x0
   \   0000F3   EE           MOV     A,R6
   \   0000F4   2401         ADD     A,#0x1
   \   0000F6   FA           MOV     R2,A
   \   0000F7   EF           MOV     A,R7
   \   0000F8   3402         ADDC    A,#0x2
   \   0000FA   FB           MOV     R3,A
   \   0000FB   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   0000FE   7404         MOV     A,#0x4
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
   \   000103   E9           MOV     A,R1
   3802              }
   \   000104   0E           INC     R6
   \   000105   EE           MOV     A,R6
   \   000106   70CE         JNZ     ??ZDSecMgrSetDefaultNV_3
   \   000108   0F           INC     R7
   \   000109   80CB         SJMP    ??ZDSecMgrSetDefaultNV_3
   3803              
   3804              osal_mem_free(pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_4:
   \   00010B                ; Setup parameters for call to function osal_mem_free
   \   00010B   AA..         MOV     R2,?V0
   \   00010D   AB..         MOV     R3,?V1
   \   00010F   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3805            }
   3806          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   000112   7407         MOV     A,#0x7
   \   000114   12....       LCALL   ?DEALLOC_XSTACK8
   \   000117   7F04         MOV     R7,#0x4
   \   000119   02....       LJMP    ?BANKED_LEAVE_XDATA
   3807          
   3808          /******************************************************************************
   3809           * @fn          ZDSecMgrAPSRemove
   3810           *
   3811           * @brief       Remove device from network.
   3812           *
   3813           * @param       nwkAddr - device's NWK address
   3814           * @param       extAddr - device's Extended address
   3815           * @param       parentAddr - parent's NWK address
   3816           *
   3817           * @return      ZStatus_t
   3818           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3819          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3820          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   8C..         MOV     ?V2,R4
   \   000010   8D..         MOV     ?V3,R5
   \   000012   7416         MOV     A,#0x16
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   3821            ZDSecMgrDevice_t device;
   3822          
   3823            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3824                 ( extAddr == NULL )              ||
   3825                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   00001C   74FE         MOV     A,#-0x2
   \   00001E   65..         XRL     A,?V0
   \   000020   7004         JNZ     ??ZDSecMgrAPSRemove_0
   \   000022   74FF         MOV     A,#-0x1
   \   000024   65..         XRL     A,?V1
   \                     ??ZDSecMgrAPSRemove_0:
   \   000026   6010         JZ      ??ZDSecMgrAPSRemove_1
   \   000028   E5..         MOV     A,?V2
   \   00002A   45..         ORL     A,?V3
   \   00002C   600A         JZ      ??ZDSecMgrAPSRemove_1
   \   00002E   74FE         MOV     A,#-0x2
   \   000030   6E           XRL     A,R6
   \   000031   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000033   74FF         MOV     A,#-0x1
   \   000035   6F           XRL     A,R7
   \                     ??ZDSecMgrAPSRemove_2:
   \   000036   7004         JNZ     ??ZDSecMgrAPSRemove_3
   3826            {
   3827              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000038   7901         MOV     R1,#0x1
   \   00003A   802C         SJMP    ??ZDSecMgrAPSRemove_4
   3828            }
   3829          
   3830            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   E5..         MOV     A,?V0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E5..         MOV     A,?V1
   \   000048   F0           MOVX    @DPTR,A
   3831            device.extAddr = extAddr;
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   E5..         MOV     A,?V2
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A3           INC     DPTR
   \   000052   E5..         MOV     A,?V3
   \   000054   F0           MOVX    @DPTR,A
   3832            device.parentAddr = parentAddr;
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   EE           MOV     A,R6
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   EF           MOV     A,R7
   \   00005E   F0           MOVX    @DPTR,A
   3833          
   3834            // remove device
   3835            ZDSecMgrDeviceRemove( &device );
   \   00005F                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00005F   AA..         MOV     R2,?XSP + 0
   \   000061   AB..         MOV     R3,?XSP + 1
   \   000063   12....       LCALL   ??ZDSecMgrDeviceRemove?relay; Banked call to: ZDSecMgrDeviceRemove
   3836          
   3837            return ( ZSuccess );
   \   000066   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000068   740A         MOV     A,#0xa
   \   00006A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006D   7F04         MOV     R7,#0x4
   \   00006F   02....       LJMP    ?BANKED_LEAVE_XDATA
   3838          }
   3839          
   3840          /******************************************************************************
   3841           * @fn          APSME_TCLinkKeyInit
   3842           *
   3843           * @brief       Initialize the NV table for preconfigured TC link key
   3844           *               
   3845           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3846           *              Trust Center Link Key is written to NV. A single tclk is used   
   3847           *              by all devices joining the network.
   3848           *              
   3849           * @param       setDefault - TRUE to set default values
   3850           *
   3851           * @return      none
   3852           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3853          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   3854          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V3,R1
   3855            uint8             i;
   3856            APSME_TCLinkKey_t tcLinkKey;
   3857            uint8             rtrn;
   3858            
   3859            // Initialize all NV items for preconfigured TCLK 
   3860            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00000C   7E00         MOV     R6,#0x0
   \                     ??APSME_TCLinkKeyInit_0:
   \   00000E   EE           MOV     A,R6
   \   00000F   6003         JZ      $+5
   \   000011   02....       LJMP    ??APSME_TCLinkKeyInit_1 & 0xFFFF
   3861            {
   3862              // Making sure data is cleared for every key all the time
   3863              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   000014                ; Setup parameters for call to function osal_memset
   \   000014   7C20         MOV     R4,#0x20
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7900         MOV     R1,#0x0
   \   00001A   AA..         MOV     R2,?XSP + 0
   \   00001C   AB..         MOV     R3,?XSP + 1
   \   00001E   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3864          
   3865              // Initialize first element of the table with the default TCLK
   3866              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   000021   EE           MOV     A,R6
   \   000022   7038         JNZ     ??APSME_TCLinkKeyInit_2
   \   000024   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7030         JNZ     ??APSME_TCLinkKeyInit_2
   3867              {
   3868                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00002C                ; Setup parameters for call to function osal_memset
   \   00002C   7C08         MOV     R4,#0x8
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   79FF         MOV     R1,#-0x1
   \   000032   AA..         MOV     R2,?XSP + 0
   \   000034   AB..         MOV     R3,?XSP + 1
   \   000036   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3869                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   000039                ; Setup parameters for call to function osal_memcpy
   \   000039   75....       MOV     ?V0,#defaultTCLinkKey & 0xff
   \   00003C   75....       MOV     ?V1,#(defaultTCLinkKey >> 8) & 0xff
   \   00003F   75..80       MOV     ?V2,#-0x80
   \   000042   78..         MOV     R0,#?V0
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000047   7C10         MOV     R4,#0x10
   \   000049   7D00         MOV     R5,#0x0
   \   00004B   740B         MOV     A,#0xb
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AA82         MOV     R2,DPL
   \   000052   AB83         MOV     R3,DPH
   \   000054   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000057   7403         MOV     A,#0x3
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   3870              }
   3871          
   3872              // If the item doesn't exist in NV memory, create and initialize
   3873              // it with the default value passed in, either defaultTCLK or 0
   3874              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3875                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_2:
   \   00005C                ; Setup parameters for call to function osal_nv_item_init
   \   00005C   A8..         MOV     R0,?XSP + 0
   \   00005E   A9..         MOV     R1,?XSP + 1
   \   000060   88..         MOV     ?V0,R0
   \   000062   89..         MOV     ?V1,R1
   \   000064   78..         MOV     R0,#?V0
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   7C20         MOV     R4,#0x20
   \   00006B   7D00         MOV     R5,#0x0
   \   00006D   EE           MOV     A,R6
   \   00006E   F8           MOV     R0,A
   \   00006F   7900         MOV     R1,#0x0
   \   000071   E8           MOV     A,R0
   \   000072   2401         ADD     A,#0x1
   \   000074   FA           MOV     R2,A
   \   000075   E9           MOV     A,R1
   \   000076   3401         ADDC    A,#0x1
   \   000078   FB           MOV     R3,A
   \   000079   12....       LCALL   ??osal_nv_item_init?relay; Banked call to: osal_nv_item_init
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000081   E9           MOV     A,R1
   \   000082   FF           MOV     R7,A
   3876               
   3877              if (rtrn == SUCCESS)
   \   000083   EF           MOV     A,R7
   \   000084   6003         JZ      $+5
   \   000086   02....       LJMP    ??APSME_TCLinkKeyInit_3 & 0xFFFF
   3878              {
   3879                // set the Frame counters to 0 to existing keys in NV
   3880                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0, 
   3881                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000089                ; Setup parameters for call to function osal_nv_read
   \   000089   A8..         MOV     R0,?XSP + 0
   \   00008B   A9..         MOV     R1,?XSP + 1
   \   00008D   88..         MOV     ?V0,R0
   \   00008F   89..         MOV     ?V1,R1
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   75..20       MOV     ?V0,#0x20
   \   000099   75..00       MOV     ?V1,#0x0
   \   00009C   78..         MOV     R0,#?V0
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   7C00         MOV     R4,#0x0
   \   0000A3   7D00         MOV     R5,#0x0
   \   0000A5   EE           MOV     A,R6
   \   0000A6   F8           MOV     R0,A
   \   0000A7   7900         MOV     R1,#0x0
   \   0000A9   E8           MOV     A,R0
   \   0000AA   2401         ADD     A,#0x1
   \   0000AC   FA           MOV     R2,A
   \   0000AD   E9           MOV     A,R1
   \   0000AE   3401         ADDC    A,#0x1
   \   0000B0   FB           MOV     R3,A
   \   0000B1   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   0000B4   7404         MOV     A,#0x4
   \   0000B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B9   E9           MOV     A,R1
   3882                
   3883          #if defined ( NV_RESTORE )
   3884                if (setDefault == TRUE)
   3885                {
   3886                  // clear the value stored in NV  
   3887                  tcLinkKey.txFrmCntr = 0;
   3888                }
   3889                else
   3890                {
   3891                  // increase the value stored in NV  
   3892                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   3893                }
   3894          #else      
   3895                // Clear the counters if NV_RESTORE is not enabled and this NV item
   3896                // already existed in the NV memory
   3897                tcLinkKey.txFrmCntr = 0;
   \   0000BA   7A00         MOV     R2,#0x0
   \   0000BC   7B00         MOV     R3,#0x0
   \   0000BE   7C00         MOV     R4,#0x0
   \   0000C0   7D00         MOV     R5,#0x0
   \   0000C2   7418         MOV     A,#0x18
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   EA           MOV     A,R2
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   EB           MOV     A,R3
   \   0000CB   F0           MOVX    @DPTR,A
   \   0000CC   A3           INC     DPTR
   \   0000CD   EC           MOV     A,R4
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   ED           MOV     A,R5
   \   0000D1   F0           MOVX    @DPTR,A
   3898                tcLinkKey.rxFrmCntr = 0;
   \   0000D2   7A00         MOV     R2,#0x0
   \   0000D4   7B00         MOV     R3,#0x0
   \   0000D6   7C00         MOV     R4,#0x0
   \   0000D8   7D00         MOV     R5,#0x0
   \   0000DA   741C         MOV     A,#0x1c
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   EA           MOV     A,R2
   \   0000E0   F0           MOVX    @DPTR,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   EB           MOV     A,R3
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   EC           MOV     A,R4
   \   0000E6   F0           MOVX    @DPTR,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   ED           MOV     A,R5
   \   0000E9   F0           MOVX    @DPTR,A
   3899          #endif  // NV_RESTORE
   3900          
   3901                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3902                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000EA                ; Setup parameters for call to function osal_nv_write
   \   0000EA   A8..         MOV     R0,?XSP + 0
   \   0000EC   A9..         MOV     R1,?XSP + 1
   \   0000EE   88..         MOV     ?V0,R0
   \   0000F0   89..         MOV     ?V1,R1
   \   0000F2   78..         MOV     R0,#?V0
   \   0000F4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F7   75..20       MOV     ?V0,#0x20
   \   0000FA   75..00       MOV     ?V1,#0x0
   \   0000FD   78..         MOV     R0,#?V0
   \   0000FF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000102   7C00         MOV     R4,#0x0
   \   000104   7D00         MOV     R5,#0x0
   \   000106   EE           MOV     A,R6
   \   000107   F8           MOV     R0,A
   \   000108   7900         MOV     R1,#0x0
   \   00010A   E8           MOV     A,R0
   \   00010B   2401         ADD     A,#0x1
   \   00010D   FA           MOV     R2,A
   \   00010E   E9           MOV     A,R1
   \   00010F   3401         ADDC    A,#0x1
   \   000111   FB           MOV     R3,A
   \   000112   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000115   7404         MOV     A,#0x4
   \   000117   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011A   E9           MOV     A,R1
   3903                
   3904                // set initial values for counters in RAM
   3905                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   00011B   7418         MOV     A,#0x18
   \   00011D   12....       LCALL   ?XSTACK_DISP0_8
   \   000120   12....       LCALL   ?XLOAD_R0123
   \   000123   EE           MOV     A,R6
   \   000124   FC           MOV     R4,A
   \   000125   7D00         MOV     R5,#0x0
   \   000127   EC           MOV     A,R4
   \   000128   75F009       MOV     B,#0x9
   \   00012B   A4           MUL     AB
   \   00012C   CC           XCH     A,R4
   \   00012D   85F0..       MOV     ?V0,B
   \   000130   75F000       MOV     B,#0x0
   \   000133   A4           MUL     AB
   \   000134   25..         ADD     A,?V0
   \   000136   F5..         MOV     ?V0,A
   \   000138   75F009       MOV     B,#0x9
   \   00013B   ED           MOV     A,R5
   \   00013C   A4           MUL     AB
   \   00013D   25..         ADD     A,?V0
   \   00013F   FD           MOV     R5,A
   \   000140   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   000142   2C           ADD     A,R4
   \   000143   F582         MOV     DPL,A
   \   000145   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000147   3D           ADDC    A,R5
   \   000148   F583         MOV     DPH,A
   \   00014A   12....       LCALL   ?XSTORE_R0123
   3906                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;    
   \   00014D   741C         MOV     A,#0x1c
   \   00014F   12....       LCALL   ?XSTACK_DISP0_8
   \   000152   12....       LCALL   ?XLOAD_R0123
   \   000155   EE           MOV     A,R6
   \   000156   FC           MOV     R4,A
   \   000157   7D00         MOV     R5,#0x0
   \   000159   EC           MOV     A,R4
   \   00015A   75F009       MOV     B,#0x9
   \   00015D   A4           MUL     AB
   \   00015E   CC           XCH     A,R4
   \   00015F   85F0..       MOV     ?V0,B
   \   000162   75F000       MOV     B,#0x0
   \   000165   A4           MUL     AB
   \   000166   25..         ADD     A,?V0
   \   000168   F5..         MOV     ?V0,A
   \   00016A   75F009       MOV     B,#0x9
   \   00016D   ED           MOV     A,R5
   \   00016E   A4           MUL     AB
   \   00016F   25..         ADD     A,?V0
   \   000171   FD           MOV     R5,A
   \   000172   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   000174   2C           ADD     A,R4
   \   000175   F582         MOV     DPL,A
   \   000177   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   000179   3D           ADDC    A,R5
   \   00017A   F583         MOV     DPH,A
   \   00017C   12....       LCALL   ?XSTORE_R0123
   3907              }
   3908            }
   \                     ??APSME_TCLinkKeyInit_3:
   \   00017F   0E           INC     R6
   \   000180   02....       LJMP    ??APSME_TCLinkKeyInit_0 & 0xFFFF
   3909              
   3910            // clear copy of key in RAM
   3911            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   000183                ; Setup parameters for call to function osal_memset
   \   000183   7C20         MOV     R4,#0x20
   \   000185   7D00         MOV     R5,#0x0
   \   000187   7900         MOV     R1,#0x0
   \   000189   AA..         MOV     R2,?XSP + 0
   \   00018B   AB..         MOV     R3,?XSP + 1
   \   00018D   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3912          
   3913          }
   \   000190   7420         MOV     A,#0x20
   \   000192   12....       LCALL   ?DEALLOC_XSTACK8
   \   000195   7F04         MOV     R7,#0x4
   \   000197   02....       LJMP    ?BANKED_LEAVE_XDATA
   3914          
   3915          /******************************************************************************
   3916           * @fn          APSME_TCLinkKeySync
   3917           *
   3918           * @brief       Sync Trust Center LINK key data.
   3919           *
   3920           * @param       srcAddr - [in] srcAddr
   3921           * @param       si      - [in, out] SSP_Info_t
   3922           *
   3923           * @return      ZStatus_t
   3924           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3925          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3926          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 34
   \   000005   74DE         MOV     A,#-0x22
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   8C..         MOV     ?V4,R4
   \   000017   8D..         MOV     ?V5,R5
   3927            ZStatus_t status = ZSecNoKey;
   \   000019   7EA1         MOV     R6,#-0x5f
   3928            uint8 i;
   3929            APSME_TCLinkKey_t tcLinkKey;       
   3930            uint32 *tclkRxFrmCntr;
   3931            
   3932            // Look up the IEEE address of the trust center if it's available
   3933            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   00001B                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001B   E5..         MOV     A,?V4
   \   00001D   2406         ADD     A,#0x6
   \   00001F   FA           MOV     R2,A
   \   000020   E4           CLR     A
   \   000021   35..         ADDC    A,?V5
   \   000023   FB           MOV     R3,A
   \   000024   12....       LCALL   ??AddrMgrExtAddrValid?relay; Banked call to: AddrMgrExtAddrValid
   \   000027   E9           MOV     A,R1
   \   000028   7018         JNZ     ??APSME_TCLinkKeySync_0
   3934            {
   3935              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   00002A                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002A   E5..         MOV     A,?V4
   \   00002C   2406         ADD     A,#0x6
   \   00002E   FC           MOV     R4,A
   \   00002F   E4           CLR     A
   \   000030   35..         ADDC    A,?V5
   \   000032   FD           MOV     R5,A
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FA           MOV     R2,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ??APSME_LookupExtAddr?relay; Banked call to: APSME_LookupExtAddr
   \   000041   E9           MOV     A,R1
   3936            }
   3937            
   3938            // Look up the TC link key associated with the device
   3939            // or the default TC link key (extAddr is all FFs), whichever is found
   3940            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \                     ??APSME_TCLinkKeySync_0:
   \   000042   7F00         MOV     R7,#0x0
   \                     ??APSME_TCLinkKeySync_1:
   \   000044   EF           MOV     A,R7
   \   000045   6003         JZ      $+5
   \   000047   02....       LJMP    ??APSME_TCLinkKeySync_2 & 0xFFFF
   3941            {
   3942              // Read entry i of the TC link key table from NV
   3943              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3944                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00004A                ; Setup parameters for call to function osal_nv_read
   \   00004A   7402         MOV     A,#0x2
   \   00004C   12....       LCALL   ?XSTACK_DISP100_8
   \   00004F   88..         MOV     ?V0,R0
   \   000051   89..         MOV     ?V1,R1
   \   000053   78..         MOV     R0,#?V0
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   75..20       MOV     ?V0,#0x20
   \   00005B   75..00       MOV     ?V1,#0x0
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   7C00         MOV     R4,#0x0
   \   000065   7D00         MOV     R5,#0x0
   \   000067   EF           MOV     A,R7
   \   000068   F8           MOV     R0,A
   \   000069   7900         MOV     R1,#0x0
   \   00006B   E8           MOV     A,R0
   \   00006C   2401         ADD     A,#0x1
   \   00006E   FA           MOV     R2,A
   \   00006F   E9           MOV     A,R1
   \   000070   3401         ADDC    A,#0x1
   \   000072   FB           MOV     R3,A
   \   000073   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000076   7404         MOV     A,#0x4
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B   E9           MOV     A,R1
   3945              
   3946              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3947                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00007C                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP102_8
   \   000081   E5..         MOV     A,?V4
   \   000083   2406         ADD     A,#0x6
   \   000085   FA           MOV     R2,A
   \   000086   E4           CLR     A
   \   000087   35..         ADDC    A,?V5
   \   000089   FB           MOV     R3,A
   \   00008A   12....       LCALL   ??AddrMgrExtAddrEqual?relay; Banked call to: AddrMgrExtAddrEqual
   \   00008D   E9           MOV     A,R1
   \   00008E   700E         JNZ     ??APSME_TCLinkKeySync_3
   \   000090                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000090   7402         MOV     A,#0x2
   \   000092   12....       LCALL   ?XSTACK_DISP101_8
   \   000095   12....       LCALL   ??APSME_IsDefaultTCLK?relay; Banked call to: APSME_IsDefaultTCLK
   \   000098   E9           MOV     A,R1
   \   000099   7003         JNZ     $+5
   \   00009B   02....       LJMP    ??APSME_TCLinkKeySync_4 & 0xFFFF
   3948              {
   3949                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   \                     ??APSME_TCLinkKeySync_3:
   \   00009E   EF           MOV     A,R7
   \   00009F   F8           MOV     R0,A
   \   0000A0   7900         MOV     R1,#0x0
   \   0000A2   E8           MOV     A,R0
   \   0000A3   75F009       MOV     B,#0x9
   \   0000A6   A4           MUL     AB
   \   0000A7   C8           XCH     A,R0
   \   0000A8   AAF0         MOV     R2,B
   \   0000AA   75F000       MOV     B,#0x0
   \   0000AD   A4           MUL     AB
   \   0000AE   2A           ADD     A,R2
   \   0000AF   FA           MOV     R2,A
   \   0000B0   75F009       MOV     B,#0x9
   \   0000B3   E9           MOV     A,R1
   \   0000B4   A4           MUL     AB
   \   0000B5   2A           ADD     A,R2
   \   0000B6   F9           MOV     R1,A
   \   0000B7   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   0000B9   28           ADD     A,R0
   \   0000BA   F8           MOV     R0,A
   \   0000BB   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000BD   39           ADDC    A,R1
   \   0000BE   F9           MOV     R1,A
   \   0000BF   88..         MOV     ?V6,R0
   \   0000C1   89..         MOV     ?V7,R1
   3950          
   3951                // verify that the incoming frame counter is valid
   3952                if ( si->frmCntr >= *tclkRxFrmCntr )
   \   0000C3   85..82       MOV     DPL,?V6
   \   0000C6   85..83       MOV     DPH,?V7
   \   0000C9   78..         MOV     R0,#?V0
   \   0000CB   12....       LCALL   ?L_MOV_X
   \   0000CE   E5..         MOV     A,?V4
   \   0000D0   2412         ADD     A,#0x12
   \   0000D2   F582         MOV     DPL,A
   \   0000D4   E4           CLR     A
   \   0000D5   35..         ADDC    A,?V5
   \   0000D7   F583         MOV     DPH,A
   \   0000D9   78..         MOV     R0,#?V0
   \   0000DB   12....       LCALL   ?UL_GT_X
   \   0000DE   4051         JC      ??APSME_TCLinkKeySync_5
   3953                {
   3954                  // set the keyNvId to use
   3955                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   0000E0   EF           MOV     A,R7
   \   0000E1   F8           MOV     R0,A
   \   0000E2   7900         MOV     R1,#0x0
   \   0000E4   E8           MOV     A,R0
   \   0000E5   2401         ADD     A,#0x1
   \   0000E7   F8           MOV     R0,A
   \   0000E8   E9           MOV     A,R1
   \   0000E9   3401         ADDC    A,#0x1
   \   0000EB   F9           MOV     R1,A
   \   0000EC   E5..         MOV     A,?V4
   \   0000EE   240F         ADD     A,#0xf
   \   0000F0   F582         MOV     DPL,A
   \   0000F2   E4           CLR     A
   \   0000F3   35..         ADDC    A,?V5
   \   0000F5   F583         MOV     DPH,A
   \   0000F7   E8           MOV     A,R0
   \   0000F8   F0           MOVX    @DPTR,A
   \   0000F9   A3           INC     DPTR
   \   0000FA   E9           MOV     A,R1
   \   0000FB   F0           MOVX    @DPTR,A
   3956                  
   3957                  // update the rx frame counter
   3958                  *tclkRxFrmCntr = si->frmCntr + 1;
   \   0000FC   E5..         MOV     A,?V4
   \   0000FE   2412         ADD     A,#0x12
   \   000100   F582         MOV     DPL,A
   \   000102   E4           CLR     A
   \   000103   35..         ADDC    A,?V5
   \   000105   F583         MOV     DPH,A
   \   000107   78..         MOV     R0,#?V0
   \   000109   12....       LCALL   ?L_MOV_X
   \   00010C   90....       MOV     DPTR,#__Constant_1
   \   00010F   78..         MOV     R0,#?V0
   \   000111   12....       LCALL   ?L_ADD_X
   \   000114   AA..         MOV     R2,?V0
   \   000116   AB..         MOV     R3,?V1
   \   000118   AC..         MOV     R4,?V2
   \   00011A   AD..         MOV     R5,?V3
   \   00011C   85..82       MOV     DPL,?V6
   \   00011F   85..83       MOV     DPH,?V7
   \   000122   EA           MOV     A,R2
   \   000123   F0           MOVX    @DPTR,A
   \   000124   A3           INC     DPTR
   \   000125   EB           MOV     A,R3
   \   000126   F0           MOVX    @DPTR,A
   \   000127   A3           INC     DPTR
   \   000128   EC           MOV     A,R4
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   A3           INC     DPTR
   \   00012B   ED           MOV     A,R5
   \   00012C   F0           MOVX    @DPTR,A
   3959                  
   3960                  status = ZSuccess;
   \   00012D   7E00         MOV     R6,#0x0
   \   00012F   8002         SJMP    ??APSME_TCLinkKeySync_6
   3961                }
   3962                else
   3963                {
   3964                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_5:
   \   000131   7EA2         MOV     R6,#-0x5e
   3965                }
   3966                
   3967                return status;
   \                     ??APSME_TCLinkKeySync_6:
   \   000133   EE           MOV     A,R6
   \   000134   F9           MOV     R1,A
   \   000135   8014         SJMP    ??APSME_TCLinkKeySync_7
   3968              }
   3969            }
   \                     ??APSME_TCLinkKeySync_4:
   \   000137   0F           INC     R7
   \   000138   02....       LJMP    ??APSME_TCLinkKeySync_1 & 0xFFFF
   3970            
   3971            // clear copy of key in RAM 
   3972            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_2:
   \   00013B                ; Setup parameters for call to function osal_memset
   \   00013B   7C20         MOV     R4,#0x20
   \   00013D   7D00         MOV     R5,#0x0
   \   00013F   7900         MOV     R1,#0x0
   \   000141   7402         MOV     A,#0x2
   \   000143   12....       LCALL   ?XSTACK_DISP101_8
   \   000146   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   3973            
   3974            return status;
   \   000149   EE           MOV     A,R6
   \   00014A   F9           MOV     R1,A
   \                     ??APSME_TCLinkKeySync_7:
   \   00014B   7422         MOV     A,#0x22
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000150   7F08         MOV     R7,#0x8
   \   000152   02....       LJMP    ?BANKED_LEAVE_XDATA
   3975          }
   3976          
   3977          /******************************************************************************
   3978           * @fn          APSME_TCLinkKeyLoad
   3979           *
   3980           * @brief       Load Trust Center LINK key data.
   3981           *
   3982           * @param       dstAddr - [in] dstAddr
   3983           * @param       si      - [in, out] SSP_Info_t
   3984           *
   3985           * @return      ZStatus_t
   3986           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3987          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3988          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 47
   \   000005   74D1         MOV     A,#-0x2f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V6,R2
   \   00000C   8B..         MOV     ?V7,R3
   \   00000E   8C..         MOV     ?V4,R4
   \   000010   8D..         MOV     ?V5,R5
   3989            uint8              i;
   3990            APSME_TCLinkKey_t  tcLinkKey;
   3991            AddrMgrEntry_t     addrEntry;  
   3992            uint32 *tclkTxFrmCntr;
   3993            
   3994            // Look up the ami of the srcAddr if available
   3995            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000012   7402         MOV     A,#0x2
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
   3996            addrEntry.nwkAddr = dstAddr;
   \   00001A   7403         MOV     A,#0x3
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E5..         MOV     A,?V6
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   E5..         MOV     A,?V7
   \   000025   F0           MOVX    @DPTR,A
   3997          
   3998            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \   000026                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000026   E5..         MOV     A,?V4
   \   000028   2406         ADD     A,#0x6
   \   00002A   FC           MOV     R4,A
   \   00002B   E4           CLR     A
   \   00002C   35..         ADDC    A,?V5
   \   00002E   FD           MOV     R5,A
   \   00002F   AA..         MOV     R2,?V6
   \   000031   AB..         MOV     R3,?V7
   \   000033   12....       LCALL   ??APSME_LookupExtAddr?relay; Banked call to: APSME_LookupExtAddr
   \   000036   E9           MOV     A,R1
   3999          
   4000            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   000037                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000037   E5..         MOV     A,?V4
   \   000039   2406         ADD     A,#0x6
   \   00003B   FA           MOV     R2,A
   \   00003C   E4           CLR     A
   \   00003D   35..         ADDC    A,?V5
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ??AddrMgrExtAddrValid?relay; Banked call to: AddrMgrExtAddrValid
   \   000043   E9           MOV     A,R1
   \   000044   6401         XRL     A,#0x1
   \   000046   6003         JZ      $+5
   \   000048   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   4001            {
   4002              // Look up the TC link key associated with the device
   4003              // or the master TC link key (ami = 0xFFFF), whichever is found
   4004              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00004B   7E00         MOV     R6,#0x0
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00004D   EE           MOV     A,R6
   \   00004E   6003         JZ      $+5
   \   000050   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   4005              {
   4006                // Read entry i of the TC link key table from NV
   4007                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   4008                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000053                ; Setup parameters for call to function osal_nv_read
   \   000053   740F         MOV     A,#0xf
   \   000055   12....       LCALL   ?XSTACK_DISP100_8
   \   000058   88..         MOV     ?V0,R0
   \   00005A   89..         MOV     ?V1,R1
   \   00005C   78..         MOV     R0,#?V0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   75..20       MOV     ?V0,#0x20
   \   000064   75..00       MOV     ?V1,#0x0
   \   000067   78..         MOV     R0,#?V0
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   7C00         MOV     R4,#0x0
   \   00006E   7D00         MOV     R5,#0x0
   \   000070   EE           MOV     A,R6
   \   000071   F8           MOV     R0,A
   \   000072   7900         MOV     R1,#0x0
   \   000074   E8           MOV     A,R0
   \   000075   2401         ADD     A,#0x1
   \   000077   FA           MOV     R2,A
   \   000078   E9           MOV     A,R1
   \   000079   3401         ADDC    A,#0x1
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   00007F   7404         MOV     A,#0x4
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   E9           MOV     A,R1
   4009                
   4010                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   4011                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000085                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000085   740F         MOV     A,#0xf
   \   000087   12....       LCALL   ?XSTACK_DISP102_8
   \   00008A   E5..         MOV     A,?V4
   \   00008C   2406         ADD     A,#0x6
   \   00008E   FA           MOV     R2,A
   \   00008F   E4           CLR     A
   \   000090   35..         ADDC    A,?V5
   \   000092   FB           MOV     R3,A
   \   000093   12....       LCALL   ??AddrMgrExtAddrEqual?relay; Banked call to: AddrMgrExtAddrEqual
   \   000096   E9           MOV     A,R1
   \   000097   700E         JNZ     ??APSME_TCLinkKeyLoad_2
   \   000099                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000099   740F         MOV     A,#0xf
   \   00009B   12....       LCALL   ?XSTACK_DISP101_8
   \   00009E   12....       LCALL   ??APSME_IsDefaultTCLK?relay; Banked call to: APSME_IsDefaultTCLK
   \   0000A1   E9           MOV     A,R1
   \   0000A2   7003         JNZ     $+5
   \   0000A4   02....       LJMP    ??APSME_TCLinkKeyLoad_3 & 0xFFFF
   4012                {
   4013                  tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000A7   EE           MOV     A,R6
   \   0000A8   F8           MOV     R0,A
   \   0000A9   7900         MOV     R1,#0x0
   \   0000AB   E8           MOV     A,R0
   \   0000AC   75F009       MOV     B,#0x9
   \   0000AF   A4           MUL     AB
   \   0000B0   C8           XCH     A,R0
   \   0000B1   AAF0         MOV     R2,B
   \   0000B3   75F000       MOV     B,#0x0
   \   0000B6   A4           MUL     AB
   \   0000B7   2A           ADD     A,R2
   \   0000B8   FA           MOV     R2,A
   \   0000B9   75F009       MOV     B,#0x9
   \   0000BC   E9           MOV     A,R1
   \   0000BD   A4           MUL     AB
   \   0000BE   2A           ADD     A,R2
   \   0000BF   F9           MOV     R1,A
   \   0000C0   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   0000C2   28           ADD     A,R0
   \   0000C3   F8           MOV     R0,A
   \   0000C4   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000C6   39           ADDC    A,R1
   \   0000C7   F9           MOV     R1,A
   \   0000C8   85..82       MOV     DPL,?XSP + 0
   \   0000CB   85..83       MOV     DPH,?XSP + 1
   \   0000CE   E8           MOV     A,R0
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E9           MOV     A,R1
   \   0000D2   F0           MOVX    @DPTR,A
   4014                  
   4015                  // set the keyNvId to use
   4016                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   0000D3   EE           MOV     A,R6
   \   0000D4   F8           MOV     R0,A
   \   0000D5   7900         MOV     R1,#0x0
   \   0000D7   E8           MOV     A,R0
   \   0000D8   2401         ADD     A,#0x1
   \   0000DA   F8           MOV     R0,A
   \   0000DB   E9           MOV     A,R1
   \   0000DC   3401         ADDC    A,#0x1
   \   0000DE   F9           MOV     R1,A
   \   0000DF   E5..         MOV     A,?V4
   \   0000E1   240F         ADD     A,#0xf
   \   0000E3   F582         MOV     DPL,A
   \   0000E5   E4           CLR     A
   \   0000E6   35..         ADDC    A,?V5
   \   0000E8   F583         MOV     DPH,A
   \   0000EA   E8           MOV     A,R0
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   E9           MOV     A,R1
   \   0000EE   F0           MOVX    @DPTR,A
   4017                  
   4018                  // update link key related fields
   4019                  si->keyID   = SEC_KEYID_LINK;
   \   0000EF   E5..         MOV     A,?V4
   \   0000F1   240E         ADD     A,#0xe
   \   0000F3   F582         MOV     DPL,A
   \   0000F5   E4           CLR     A
   \   0000F6   35..         ADDC    A,?V5
   \   0000F8   F583         MOV     DPH,A
   \   0000FA   7400         MOV     A,#0x0
   \   0000FC   F0           MOVX    @DPTR,A
   4020                  si->frmCntr = *tclkTxFrmCntr;
   \   0000FD   85..82       MOV     DPL,?XSP + 0
   \   000100   85..83       MOV     DPH,?XSP + 1
   \   000103   E0           MOVX    A,@DPTR
   \   000104   F8           MOV     R0,A
   \   000105   A3           INC     DPTR
   \   000106   E0           MOVX    A,@DPTR
   \   000107   F583         MOV     DPH,A
   \   000109   8882         MOV     DPL,R0
   \   00010B   12....       LCALL   ?XLOAD_R0123
   \   00010E   E5..         MOV     A,?V4
   \   000110   2412         ADD     A,#0x12
   \   000112   F582         MOV     DPL,A
   \   000114   E4           CLR     A
   \   000115   35..         ADDC    A,?V5
   \   000117   F583         MOV     DPH,A
   \   000119   12....       LCALL   ?XSTORE_R0123
   4021                
   4022                  // update outgoing frame counter
   4023                  (*tclkTxFrmCntr)++;
   \   00011C   90....       MOV     DPTR,#__Constant_1
   \   00011F   78..         MOV     R0,#?V0
   \   000121   12....       LCALL   ?L_MOV_X
   \   000124   85..82       MOV     DPL,?XSP + 0
   \   000127   85..83       MOV     DPH,?XSP + 1
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   F8           MOV     R0,A
   \   00012C   A3           INC     DPTR
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   F583         MOV     DPH,A
   \   000130   8882         MOV     DPL,R0
   \   000132   78..         MOV     R0,#?V0
   \   000134   12....       LCALL   ?L_ADD_TO_X
   4024                  
   4025          #if defined ( NV_RESTORE )
   4026                  // write periodically to NV
   4027                  if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4028                  {
   4029                    // set the flag to write key to NV
   4030                    TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4031                    
   4032                    // Notify the ZDApp that the frame counter has changed.
   4033                    osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4034                  }        
   4035          #endif
   4036                  
   4037                  return ZSuccess;
   \   000137   7900         MOV     R1,#0x0
   \   000139   802A         SJMP    ??APSME_TCLinkKeyLoad_4
   4038                }
   4039              }
   \                     ??APSME_TCLinkKeyLoad_3:
   \   00013B   0E           INC     R6
   \   00013C   02....       LJMP    ??APSME_TCLinkKeyLoad_1 & 0xFFFF
   4040            }
   4041              
   4042            // If no TC link key found, remove the device from the address manager
   4043            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   00013F                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   00013F   7402         MOV     A,#0x2
   \   000141   12....       LCALL   ?XSTACK_DISP101_8
   \   000144   12....       LCALL   ??AddrMgrEntryLookupNwk?relay; Banked call to: AddrMgrEntryLookupNwk
   \   000147   E9           MOV     A,R1
   \   000148   6401         XRL     A,#0x1
   \   00014A   7009         JNZ     ??APSME_TCLinkKeyLoad_5
   4044            {
   4045              AddrMgrEntryRelease( &addrEntry );
   \   00014C                ; Setup parameters for call to function AddrMgrEntryRelease
   \   00014C   7402         MOV     A,#0x2
   \   00014E   12....       LCALL   ?XSTACK_DISP101_8
   \   000151   12....       LCALL   ??AddrMgrEntryRelease?relay; Banked call to: AddrMgrEntryRelease
   \   000154   E9           MOV     A,R1
   4046            }
   4047            
   4048              // clear copy of key in RAM 
   4049            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_5:
   \   000155                ; Setup parameters for call to function osal_memset
   \   000155   7C20         MOV     R4,#0x20
   \   000157   7D00         MOV     R5,#0x0
   \   000159   7900         MOV     R1,#0x0
   \   00015B   740F         MOV     A,#0xf
   \   00015D   12....       LCALL   ?XSTACK_DISP101_8
   \   000160   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   4050          
   4051            return ZSecNoKey;
   \   000163   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_4:
   \   000165   742F         MOV     A,#0x2f
   \   000167   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016A   7F08         MOV     R7,#0x8
   \   00016C   02....       LJMP    ?BANKED_LEAVE_XDATA
   4052          }
   4053          
   4054          /******************************************************************************
   4055           * @fn          APSME_IsDefaultTCLK
   4056           *
   4057           * @brief       Return true or false based on the extended address.  If the 
   4058           *              input ext address is all FFs, it means the trust center link
   4059           *              assoiciated with the address is the default trust center link key
   4060           *
   4061           * @param       extAddr - [in] extended address
   4062           *
   4063           * @return      uint8 TRUE/FALSE
   4064           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4065          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   4066          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   4067            uint8 i = 0;
   \   000005   7C00         MOV     R4,#0x0
   4068            
   4069            if( extAddr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   4B           ORL     A,R3
   \   000009   7004         JNZ     ??APSME_IsDefaultTCLK_0
   4070            {
   4071              return FALSE;
   \   00000B   7900         MOV     R1,#0x0
   \   00000D   8028         SJMP    ??APSME_IsDefaultTCLK_1
   4072            }
   4073            
   4074            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_0:
   \   00000F   EC           MOV     A,R4
   \   000010   FD           MOV     R5,A
   \   000011   7401         MOV     A,#0x1
   \   000013   2D           ADD     A,R5
   \   000014   FC           MOV     R4,A
   \   000015   ED           MOV     A,R5
   \   000016   C3           CLR     C
   \   000017   9408         SUBB    A,#0x8
   \   000019   501A         JNC     ??APSME_IsDefaultTCLK_2
   4075            {
   4076              if( *extAddr++ != 0xFF )
   \   00001B   EA           MOV     A,R2
   \   00001C   F8           MOV     R0,A
   \   00001D   EB           MOV     A,R3
   \   00001E   F9           MOV     R1,A
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   A3           INC     DPTR
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   64FF         XRL     A,#0xff
   \   00002F   60DE         JZ      ??APSME_IsDefaultTCLK_0
   4077              {
   4078                return FALSE;
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??APSME_IsDefaultTCLK_1
   4079              }
   4080            }
   4081            
   4082            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   000035   7901         MOV     R1,#0x1
   \                     ??APSME_IsDefaultTCLK_1:
   \   000037   7F01         MOV     R7,#0x1
   \   000039   02....       LJMP    ?BANKED_LEAVE_XDATA
   4083          }
   4084          
   4085          /******************************************************************************
   4086           * @fn          ZDSecMgrNwkKeyInit
   4087           *
   4088           * @brief       Initialize the NV items for 
   4089           *                  ZCD_NV_NWKKEY, 
   4090           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and 
   4091           *                  ZCD_NV_NWK_ALTERN_KEY_INFO 
   4092           *               
   4093           * @param       setDefault
   4094           *
   4095           * @return      none
   4096           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4097          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   4098          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   4099            uint8 status;
   4100            nwkKeyDesc nwkKey;
   4101          
   4102            // Initialize NV items for NWK key, this structure contains the frame counter
   4103            // and is only used when NV_RESTORE is enabled
   4104            nwkActiveKeyItems keyItems;  
   4105              
   4106            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000C                ; Setup parameters for call to function osal_memset
   \   00000C   7C15         MOV     R4,#0x15
   \   00000E   7D00         MOV     R5,#0x0
   \   000010   7900         MOV     R1,#0x0
   \   000012   7411         MOV     A,#0x11
   \   000014   12....       LCALL   ?XSTACK_DISP101_8
   \   000017   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   4107            
   4108            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   \   00001A                ; Setup parameters for call to function osal_nv_item_init
   \   00001A   7411         MOV     A,#0x11
   \   00001C   12....       LCALL   ?XSTACK_DISP100_8
   \   00001F   88..         MOV     ?V0,R0
   \   000021   89..         MOV     ?V1,R1
   \   000023   78..         MOV     R0,#?V0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7C15         MOV     R4,#0x15
   \   00002A   7D00         MOV     R5,#0x0
   \   00002C   7A82         MOV     R2,#-0x7e
   \   00002E   7B00         MOV     R3,#0x0
   \   000030   12....       LCALL   ??osal_nv_item_init?relay; Banked call to: osal_nv_item_init
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   E9           MOV     A,R1
   \   000039   FE           MOV     R6,A
   4109          
   4110          #if defined ( NV_RESTORE )
   4111            // reset the values of NV items if NV_RESTORE is not enabled
   4112            if ((status == SUCCESS) && (setDefault == TRUE))
   4113            {
   4114              // clear NV data to default values
   4115              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4116            }
   4117          #else
   4118            (void)setDefault;   // to eliminate compiler warning
   4119            
   4120            // reset the values of NV items if NV_RESTORE is not enabled
   4121            if (status == SUCCESS)
   \   00003A   EE           MOV     A,R6
   \   00003B   702A         JNZ     ??ZDSecMgrNwkKeyInit_0
   4122            {
   4123              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   00003D                ; Setup parameters for call to function osal_nv_write
   \   00003D   7411         MOV     A,#0x11
   \   00003F   12....       LCALL   ?XSTACK_DISP100_8
   \   000042   88..         MOV     ?V0,R0
   \   000044   89..         MOV     ?V1,R1
   \   000046   78..         MOV     R0,#?V0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   75..15       MOV     ?V0,#0x15
   \   00004E   75..00       MOV     ?V1,#0x0
   \   000051   78..         MOV     R0,#?V0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   7C00         MOV     R4,#0x0
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   7A82         MOV     R2,#-0x7e
   \   00005C   7B00         MOV     R3,#0x0
   \   00005E   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000061   7404         MOV     A,#0x4
   \   000063   12....       LCALL   ?DEALLOC_XSTACK8
   \   000066   E9           MOV     A,R1
   4124            }
   4125          #endif // defined (NV_RESTORE)    
   4126          
   4127            // Initialize NV items for NWK Active and Alternate keys. These items are used 
   4128            // all the time, independently of NV_RESTORE being set or not
   4129            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000067                ; Setup parameters for call to function osal_memset
   \   000067   7C11         MOV     R4,#0x11
   \   000069   7D00         MOV     R5,#0x0
   \   00006B   7900         MOV     R1,#0x0
   \   00006D   AA..         MOV     R2,?XSP + 0
   \   00006F   AB..         MOV     R3,?XSP + 1
   \   000071   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   4130          
   4131            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   \   000074                ; Setup parameters for call to function osal_nv_item_init
   \   000074   A8..         MOV     R0,?XSP + 0
   \   000076   A9..         MOV     R1,?XSP + 1
   \   000078   88..         MOV     ?V0,R0
   \   00007A   89..         MOV     ?V1,R1
   \   00007C   78..         MOV     R0,#?V0
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   7C11         MOV     R4,#0x11
   \   000083   7D00         MOV     R5,#0x0
   \   000085   7A3A         MOV     R2,#0x3a
   \   000087   7B00         MOV     R3,#0x0
   \   000089   12....       LCALL   ??osal_nv_item_init?relay; Banked call to: osal_nv_item_init
   \   00008C   7402         MOV     A,#0x2
   \   00008E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000091   E9           MOV     A,R1
   \   000092   FE           MOV     R6,A
   4132            
   4133          #if defined ( NV_RESTORE )
   4134            // reset the values of NV items if NV_RESTORE is not enabled
   4135            if ((status == SUCCESS) && (setDefault == TRUE))
   4136            {
   4137              // clear NV data to default values
   4138              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4139            }
   4140          #else
   4141            // reset the values of NV items if NV_RESTORE is not enabled
   4142            if (status == SUCCESS)
   \   000093   EE           MOV     A,R6
   \   000094   7029         JNZ     ??ZDSecMgrNwkKeyInit_1
   4143            {
   4144              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   000096                ; Setup parameters for call to function osal_nv_write
   \   000096   A8..         MOV     R0,?XSP + 0
   \   000098   A9..         MOV     R1,?XSP + 1
   \   00009A   88..         MOV     ?V0,R0
   \   00009C   89..         MOV     ?V1,R1
   \   00009E   78..         MOV     R0,#?V0
   \   0000A0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A3   75..11       MOV     ?V0,#0x11
   \   0000A6   75..00       MOV     ?V1,#0x0
   \   0000A9   78..         MOV     R0,#?V0
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AE   7C00         MOV     R4,#0x0
   \   0000B0   7D00         MOV     R5,#0x0
   \   0000B2   7A3A         MOV     R2,#0x3a
   \   0000B4   7B00         MOV     R3,#0x0
   \   0000B6   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   0000B9   7404         MOV     A,#0x4
   \   0000BB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BE   E9           MOV     A,R1
   4145            }
   4146          #endif // defined (NV_RESTORE)    
   4147            
   4148            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   0000BF                ; Setup parameters for call to function osal_nv_item_init
   \   0000BF   A8..         MOV     R0,?XSP + 0
   \   0000C1   A9..         MOV     R1,?XSP + 1
   \   0000C3   88..         MOV     ?V0,R0
   \   0000C5   89..         MOV     ?V1,R1
   \   0000C7   78..         MOV     R0,#?V0
   \   0000C9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CC   7C11         MOV     R4,#0x11
   \   0000CE   7D00         MOV     R5,#0x0
   \   0000D0   7A3B         MOV     R2,#0x3b
   \   0000D2   7B00         MOV     R3,#0x0
   \   0000D4   12....       LCALL   ??osal_nv_item_init?relay; Banked call to: osal_nv_item_init
   \   0000D7   7402         MOV     A,#0x2
   \   0000D9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DC   E9           MOV     A,R1
   \   0000DD   FE           MOV     R6,A
   4149            
   4150          #if defined ( NV_RESTORE )
   4151            // reset the values of NV items if NV_RESTORE is not enabled
   4152            if ((status == SUCCESS) && (setDefault == TRUE))
   4153            {
   4154              // clear NV data to default values
   4155              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4156            }
   4157          #else
   4158            // reset the values of NV items if NV_RESTORE is not enabled
   4159            if (status == SUCCESS)
   \   0000DE   EE           MOV     A,R6
   \   0000DF   7029         JNZ     ??ZDSecMgrNwkKeyInit_2
   4160            {
   4161              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000E1                ; Setup parameters for call to function osal_nv_write
   \   0000E1   A8..         MOV     R0,?XSP + 0
   \   0000E3   A9..         MOV     R1,?XSP + 1
   \   0000E5   88..         MOV     ?V0,R0
   \   0000E7   89..         MOV     ?V1,R1
   \   0000E9   78..         MOV     R0,#?V0
   \   0000EB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EE   75..11       MOV     ?V0,#0x11
   \   0000F1   75..00       MOV     ?V1,#0x0
   \   0000F4   78..         MOV     R0,#?V0
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   7C00         MOV     R4,#0x0
   \   0000FB   7D00         MOV     R5,#0x0
   \   0000FD   7A3B         MOV     R2,#0x3b
   \   0000FF   7B00         MOV     R3,#0x0
   \   000101   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000104   7404         MOV     A,#0x4
   \   000106   12....       LCALL   ?DEALLOC_XSTACK8
   \   000109   E9           MOV     A,R1
   4162            }
   4163          #endif // defined (NV_RESTORE)
   4164          
   4165          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   00010A   7426         MOV     A,#0x26
   \   00010C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010F   7F02         MOV     R7,#0x2
   \   000111   02....       LJMP    ?BANKED_LEAVE_XDATA
   4166          
   4167          /*********************************************************************
   4168           * @fn          ZDSecMgrReadKeyFromNv
   4169           *
   4170           * @brief       Looks for a specific key in NV based on Index value
   4171           *
   4172           * @param   keyNvId - Index of key to look in NV
   4173           *                    valid values are:
   4174           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO    
   4175           *                    ZCD_NV_NWK_ALTERN_KEY_INFO 
   4176           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4177           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4178           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4179           *                    ZCD_NV_PRECFGKEY
   4180           *
   4181           * @param  *keyinfo - Data is read into this buffer.
   4182           *
   4183           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4184           *          Otherwise, NV_OPER_FAILED for failure.
   4185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4186          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   4187          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   4188            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4189                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   00000D   743A         MOV     A,#0x3a
   \   00000F   6E           XRL     A,R6
   \   000010   7003         JNZ     ??ZDSecMgrReadKeyFromNv_0
   \   000012   7400         MOV     A,#0x0
   \   000014   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   000015   600A         JZ      ??ZDSecMgrReadKeyFromNv_1
   \   000017   743B         MOV     A,#0x3b
   \   000019   6E           XRL     A,R6
   \   00001A   7003         JNZ     ??ZDSecMgrReadKeyFromNv_2
   \   00001C   7400         MOV     A,#0x0
   \   00001E   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00001F   7023         JNZ     ??ZDSecMgrReadKeyFromNv_3
   4190            {
   4191              // get NWK active or alternate key from NV
   4192              return (osal_nv_read(keyNvId, 
   4193                                   osal_offsetof(nwkKeyDesc, key), 
   4194                                   SEC_KEY_LEN, 
   4195                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000021                ; Setup parameters for call to function osal_nv_read
   \   000021   78..         MOV     R0,#?V0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   75..10       MOV     ?V2,#0x10
   \   000029   75..00       MOV     ?V3,#0x0
   \   00002C   78..         MOV     R0,#?V2
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7C01         MOV     R4,#0x1
   \   000033   7D00         MOV     R5,#0x0
   \   000035   EE           MOV     A,R6
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000041   02....       LJMP    ??ZDSecMgrReadKeyFromNv_4 & 0xFFFF
   4196            }
   4197            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4198                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   000044   C3           CLR     C
   \   000045   EE           MOV     A,R6
   \   000046   9401         SUBB    A,#0x1
   \   000048   EF           MOV     A,R7
   \   000049   9401         SUBB    A,#0x1
   \   00004B   402C         JC      ??ZDSecMgrReadKeyFromNv_5
   \   00004D   C3           CLR     C
   \   00004E   EE           MOV     A,R6
   \   00004F   9402         SUBB    A,#0x2
   \   000051   EF           MOV     A,R7
   \   000052   9401         SUBB    A,#0x1
   \   000054   5023         JNC     ??ZDSecMgrReadKeyFromNv_5
   4199            {
   4200              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4201              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4202              return (osal_nv_read(keyNvId, 
   4203                                   osal_offsetof(APSME_TCLinkKey_t, key), 
   4204                                   SEC_KEY_LEN, 
   4205                                   keyinfo));
   \   000056                ; Setup parameters for call to function osal_nv_read
   \   000056   78..         MOV     R0,#?V0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..10       MOV     ?V2,#0x10
   \   00005E   75..00       MOV     ?V3,#0x0
   \   000061   78..         MOV     R0,#?V2
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C08         MOV     R4,#0x8
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   EE           MOV     A,R6
   \   00006B   FA           MOV     R2,A
   \   00006C   EF           MOV     A,R7
   \   00006D   FB           MOV     R3,A
   \   00006E   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   02....       LJMP    ??ZDSecMgrReadKeyFromNv_4 & 0xFFFF
   4206            }
   4207            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4208                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   000079   C3           CLR     C
   \   00007A   EE           MOV     A,R6
   \   00007B   9401         SUBB    A,#0x1
   \   00007D   EF           MOV     A,R7
   \   00007E   9402         SUBB    A,#0x2
   \   000080   402B         JC      ??ZDSecMgrReadKeyFromNv_6
   \   000082   C3           CLR     C
   \   000083   EE           MOV     A,R6
   \   000084   9404         SUBB    A,#0x4
   \   000086   EF           MOV     A,R7
   \   000087   9402         SUBB    A,#0x2
   \   000089   5022         JNC     ??ZDSecMgrReadKeyFromNv_6
   4209            {
   4210              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4211              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4212              return (osal_nv_read(keyNvId, 
   4213                                   osal_offsetof(APSME_LinkKeyData_t, key), 
   4214                                   SEC_KEY_LEN, 
   4215                                   keyinfo));
   \   00008B                ; Setup parameters for call to function osal_nv_read
   \   00008B   78..         MOV     R0,#?V0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   75..10       MOV     ?V2,#0x10
   \   000093   75..00       MOV     ?V3,#0x0
   \   000096   78..         MOV     R0,#?V2
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009B   7C00         MOV     R4,#0x0
   \   00009D   7D00         MOV     R5,#0x0
   \   00009F   EE           MOV     A,R6
   \   0000A0   FA           MOV     R2,A
   \   0000A1   EF           MOV     A,R7
   \   0000A2   FB           MOV     R3,A
   \   0000A3   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AB   8062         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4216            }
   4217            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4218                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   0000AD   C3           CLR     C
   \   0000AE   EE           MOV     A,R6
   \   0000AF   9401         SUBB    A,#0x1
   \   0000B1   EF           MOV     A,R7
   \   0000B2   9403         SUBB    A,#0x3
   \   0000B4   402B         JC      ??ZDSecMgrReadKeyFromNv_7
   \   0000B6   C3           CLR     C
   \   0000B7   EE           MOV     A,R6
   \   0000B8   9404         SUBB    A,#0x4
   \   0000BA   EF           MOV     A,R7
   \   0000BB   9403         SUBB    A,#0x3
   \   0000BD   5022         JNC     ??ZDSecMgrReadKeyFromNv_7
   4219            {
   4220              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4221              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4222              return (osal_nv_read(keyNvId, 
   4223                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   4224                                   SEC_KEY_LEN, 
   4225                                   keyinfo));
   \   0000BF                ; Setup parameters for call to function osal_nv_read
   \   0000BF   78..         MOV     R0,#?V0
   \   0000C1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C4   75..10       MOV     ?V2,#0x10
   \   0000C7   75..00       MOV     ?V3,#0x0
   \   0000CA   78..         MOV     R0,#?V2
   \   0000CC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CF   7C02         MOV     R4,#0x2
   \   0000D1   7D00         MOV     R5,#0x0
   \   0000D3   EE           MOV     A,R6
   \   0000D4   FA           MOV     R2,A
   \   0000D5   EF           MOV     A,R7
   \   0000D6   FB           MOV     R3,A
   \   0000D7   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   0000DA   7404         MOV     A,#0x4
   \   0000DC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DF   802E         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4226            }
   4227            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   0000E1   7462         MOV     A,#0x62
   \   0000E3   6E           XRL     A,R6
   \   0000E4   7003         JNZ     ??ZDSecMgrReadKeyFromNv_8
   \   0000E6   7400         MOV     A,#0x0
   \   0000E8   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   0000E9   7022         JNZ     ??ZDSecMgrReadKeyFromNv_9
   4228            {
   4229              // Read entry keyNvId of the Preconfig key from NV. 
   4230              return (osal_nv_read(keyNvId, 
   4231                                   0, 
   4232                                   SEC_KEY_LEN, 
   4233                                   keyinfo));
   \   0000EB                ; Setup parameters for call to function osal_nv_read
   \   0000EB   78..         MOV     R0,#?V0
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   75..10       MOV     ?V2,#0x10
   \   0000F3   75..00       MOV     ?V3,#0x0
   \   0000F6   78..         MOV     R0,#?V2
   \   0000F8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FB   7C00         MOV     R4,#0x0
   \   0000FD   7D00         MOV     R5,#0x0
   \   0000FF   EE           MOV     A,R6
   \   000100   FA           MOV     R2,A
   \   000101   EF           MOV     A,R7
   \   000102   FB           MOV     R3,A
   \   000103   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000106   7404         MOV     A,#0x4
   \   000108   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010B   8002         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4234            }
   4235            
   4236            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   00010D   790A         MOV     R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   00010F   7F04         MOV     R7,#0x4
   \   000111   02....       LJMP    ?BANKED_LEAVE_XDATA
   4237          }
   4238          
   4239          /******************************************************************************
   4240           * @fn          ZDSecMgrApsLinkKeyInit
   4241           *
   4242           * @brief       Initialize the NV table for Application link keys
   4243           *           
   4244           * @param       none
   4245           *
   4246           * @return      none
   4247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4248          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   4249          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   4250            APSME_LinkKeyData_t pApsLinkKey;
   4251            uint8 i;
   4252            uint8 status;
   4253            
   4254            // Initialize all NV items for APS link key, if not exist already.
   4255            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV     R4,#0x18
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   AA..         MOV     R2,?XSP + 0
   \   000012   AB..         MOV     R3,?XSP + 1
   \   000014   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   4256            
   4257            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000017   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   000019   EF           MOV     A,R7
   \   00001A   C3           CLR     C
   \   00001B   9403         SUBB    A,#0x3
   \   00001D   505E         JNC     ??ZDSecMgrApsLinkKeyInit_1
   4258            {
   4259              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 
   4260                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   00001F                ; Setup parameters for call to function osal_nv_item_init
   \   00001F   A8..         MOV     R0,?XSP + 0
   \   000021   A9..         MOV     R1,?XSP + 1
   \   000023   88..         MOV     ?V0,R0
   \   000025   89..         MOV     ?V1,R1
   \   000027   78..         MOV     R0,#?V0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   7C18         MOV     R4,#0x18
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   EF           MOV     A,R7
   \   000031   F8           MOV     R0,A
   \   000032   7900         MOV     R1,#0x0
   \   000034   E8           MOV     A,R0
   \   000035   2401         ADD     A,#0x1
   \   000037   FA           MOV     R2,A
   \   000038   E9           MOV     A,R1
   \   000039   3402         ADDC    A,#0x2
   \   00003B   FB           MOV     R3,A
   \   00003C   12....       LCALL   ??osal_nv_item_init?relay; Banked call to: osal_nv_item_init
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?DEALLOC_XSTACK8
   \   000044   E9           MOV     A,R1
   \   000045   FE           MOV     R6,A
   4261              
   4262          #if defined ( NV_RESTORE )
   4263              (void)status;   // to eliminate compiler warning
   4264          #else
   4265              // reset the values of NV items if NV_RESTORE is not enabled
   4266              if (status == SUCCESS)
   \   000046   EE           MOV     A,R6
   \   000047   7031         JNZ     ??ZDSecMgrApsLinkKeyInit_2
   4267              {
   4268                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0, 
   4269                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   000049                ; Setup parameters for call to function osal_nv_write
   \   000049   A8..         MOV     R0,?XSP + 0
   \   00004B   A9..         MOV     R1,?XSP + 1
   \   00004D   88..         MOV     ?V0,R0
   \   00004F   89..         MOV     ?V1,R1
   \   000051   78..         MOV     R0,#?V0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   75..18       MOV     ?V0,#0x18
   \   000059   75..00       MOV     ?V1,#0x0
   \   00005C   78..         MOV     R0,#?V0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   7C00         MOV     R4,#0x0
   \   000063   7D00         MOV     R5,#0x0
   \   000065   EF           MOV     A,R7
   \   000066   F8           MOV     R0,A
   \   000067   7900         MOV     R1,#0x0
   \   000069   E8           MOV     A,R0
   \   00006A   2401         ADD     A,#0x1
   \   00006C   FA           MOV     R2,A
   \   00006D   E9           MOV     A,R1
   \   00006E   3402         ADDC    A,#0x2
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000074   7404         MOV     A,#0x4
   \   000076   12....       LCALL   ?DEALLOC_XSTACK8
   \   000079   E9           MOV     A,R1
   4270                
   4271              }
   4272          #endif // defined (NV_RESTORE)
   4273            }
   \                     ??ZDSecMgrApsLinkKeyInit_2:
   \   00007A   0F           INC     R7
   \   00007B   809C         SJMP    ??ZDSecMgrApsLinkKeyInit_0
   4274          }
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   00007D   7418         MOV     A,#0x18
   \   00007F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000082   7F02         MOV     R7,#0x2
   \   000084   02....       LJMP    ?BANKED_LEAVE_XDATA
   4275          
   4276          /******************************************************************************
   4277           * @fn          ZDSecMgrInitNVKeyTables
   4278           *
   4279           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4280           *           
   4281           * @param       setDefault - TRUE to set default values 
   4282           *
   4283           * @return      none
   4284           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4285          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   4286          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   4287            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   EE           MOV     A,R6
   \   000008   F9           MOV     R1,A
   \   000009   12....       LCALL   ??ZDSecMgrNwkKeyInit?relay; Banked call to: ZDSecMgrNwkKeyInit
   4288            ZDSecMgrMasterKeyInit();
   \   00000C                ; Setup parameters for call to function ZDSecMgrMasterKeyInit
   \   00000C   12....       LCALL   ??ZDSecMgrMasterKeyInit?relay; Banked call to: ZDSecMgrMasterKeyInit
   4289            ZDSecMgrApsLinkKeyInit();
   \   00000F                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000F   12....       LCALL   ??ZDSecMgrApsLinkKeyInit?relay; Banked call to: ZDSecMgrApsLinkKeyInit
   4290            APSME_TCLinkKeyInit(setDefault);
   \   000012                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   000012   EE           MOV     A,R6
   \   000013   F9           MOV     R1,A
   \   000014   12....       LCALL   ??APSME_TCLinkKeyInit?relay; Banked call to: APSME_TCLinkKeyInit
   4291          }
   \   000017   7F01         MOV     R7,#0x1
   \   000019   02....       LJMP    ?BANKED_LEAVE_XDATA
   4292          
   4293          /******************************************************************************
   4294           * @fn          ZDSecMgrSaveApsLinkKey
   4295           *
   4296           * @brief       Save APS Link Key to NV. It will loop through all the keys  
   4297           *              to see which one to save.
   4298           *           
   4299           * @param       none
   4300           *
   4301           * @return      none
   4302           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4303          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   4304          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4305            APSME_LinkKeyData_t *pKeyData = NULL;
   \   000005   75..00       MOV     ?V0,#0x0
   \   000008   75..00       MOV     ?V1,#0x0
   4306            int i;
   4307            
   4308            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A18         MOV     R2,#0x18
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   85....       MOV     ?V0,?V2
   \   000019   85....       MOV     ?V1,?V3
   4309            
   4310            if (pKeyData != NULL)
   \   00001C   E5..         MOV     A,?V0
   \   00001E   45..         ORL     A,?V1
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   4311            {          
   4312              // checks all pending flags to know which one to save
   4313              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000025   7E00         MOV     R6,#0x0
   \   000027   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   000029   C3           CLR     C
   \   00002A   EE           MOV     A,R6
   \   00002B   9403         SUBB    A,#0x3
   \   00002D   EF           MOV     A,R7
   \   00002E   9400         SUBB    A,#0x0
   \   000030   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000032   65D0         XRL     A,PSW
   \   000034   33           RLC     A
   \   000035   4003         JC      $+5
   \   000037   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_2 & 0xFFFF
   4314              {
   4315                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   00003A   EE           MOV     A,R6
   \   00003B   F8           MOV     R0,A
   \   00003C   EF           MOV     A,R7
   \   00003D   F9           MOV     R1,A
   \   00003E   E8           MOV     A,R0
   \   00003F   75F009       MOV     B,#0x9
   \   000042   A4           MUL     AB
   \   000043   C8           XCH     A,R0
   \   000044   AAF0         MOV     R2,B
   \   000046   75F000       MOV     B,#0x0
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   FA           MOV     R2,A
   \   00004C   75F009       MOV     B,#0x9
   \   00004F   E9           MOV     A,R1
   \   000050   A4           MUL     AB
   \   000051   2A           ADD     A,R2
   \   000052   F9           MOV     R1,A
   \   000053   74..         MOV     A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000055   28           ADD     A,R0
   \   000056   F582         MOV     DPL,A
   \   000058   74..         MOV     A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00005A   39           ADDC    A,R1
   \   00005B   F583         MOV     DPH,A
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6401         XRL     A,#0x1
   \   000060   6003         JZ      $+5
   \   000062   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_3 & 0xFFFF
   4316                {
   4317                  // retrieve key from NV
   4318                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4319                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000065                ; Setup parameters for call to function osal_nv_read
   \   000065   78..         MOV     R0,#?V0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   75..18       MOV     ?V2,#0x18
   \   00006D   75..00       MOV     ?V3,#0x0
   \   000070   78..         MOV     R0,#?V2
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   7C00         MOV     R4,#0x0
   \   000077   7D00         MOV     R5,#0x0
   \   000079   EE           MOV     A,R6
   \   00007A   2401         ADD     A,#0x1
   \   00007C   FA           MOV     R2,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3402         ADDC    A,#0x2
   \   000080   FB           MOV     R3,A
   \   000081   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000084   7404         MOV     A,#0x4
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
   \   000089   E9           MOV     A,R1
   \   00008A   6003         JZ      $+5
   \   00008C   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_3 & 0xFFFF
   4320                  {                
   4321                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00008F   EE           MOV     A,R6
   \   000090   F8           MOV     R0,A
   \   000091   EF           MOV     A,R7
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   75F009       MOV     B,#0x9
   \   000097   A4           MUL     AB
   \   000098   C8           XCH     A,R0
   \   000099   AAF0         MOV     R2,B
   \   00009B   75F000       MOV     B,#0x0
   \   00009E   A4           MUL     AB
   \   00009F   2A           ADD     A,R2
   \   0000A0   FA           MOV     R2,A
   \   0000A1   75F009       MOV     B,#0x9
   \   0000A4   E9           MOV     A,R1
   \   0000A5   A4           MUL     AB
   \   0000A6   2A           ADD     A,R2
   \   0000A7   F9           MOV     R1,A
   \   0000A8   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   0000AA   28           ADD     A,R0
   \   0000AB   F582         MOV     DPL,A
   \   0000AD   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   0000AF   39           ADDC    A,R1
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   12....       LCALL   ?XLOAD_R0123
   \   0000B5   E5..         MOV     A,?V0
   \   0000B7   2410         ADD     A,#0x10
   \   0000B9   F582         MOV     DPL,A
   \   0000BB   E4           CLR     A
   \   0000BC   35..         ADDC    A,?V1
   \   0000BE   F583         MOV     DPH,A
   \   0000C0   12....       LCALL   ?XSTORE_R0123
   4322                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   0000C3   EE           MOV     A,R6
   \   0000C4   F8           MOV     R0,A
   \   0000C5   EF           MOV     A,R7
   \   0000C6   F9           MOV     R1,A
   \   0000C7   E8           MOV     A,R0
   \   0000C8   75F009       MOV     B,#0x9
   \   0000CB   A4           MUL     AB
   \   0000CC   C8           XCH     A,R0
   \   0000CD   AAF0         MOV     R2,B
   \   0000CF   75F000       MOV     B,#0x0
   \   0000D2   A4           MUL     AB
   \   0000D3   2A           ADD     A,R2
   \   0000D4   FA           MOV     R2,A
   \   0000D5   75F009       MOV     B,#0x9
   \   0000D8   E9           MOV     A,R1
   \   0000D9   A4           MUL     AB
   \   0000DA   2A           ADD     A,R2
   \   0000DB   F9           MOV     R1,A
   \   0000DC   74..         MOV     A,#(ApsLinkKeyFrmCntr + 4) & 0xff
   \   0000DE   28           ADD     A,R0
   \   0000DF   F582         MOV     DPL,A
   \   0000E1   74..         MOV     A,#((ApsLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000E3   39           ADDC    A,R1
   \   0000E4   F583         MOV     DPH,A
   \   0000E6   12....       LCALL   ?XLOAD_R0123
   \   0000E9   E5..         MOV     A,?V0
   \   0000EB   2414         ADD     A,#0x14
   \   0000ED   F582         MOV     DPL,A
   \   0000EF   E4           CLR     A
   \   0000F0   35..         ADDC    A,?V1
   \   0000F2   F583         MOV     DPH,A
   \   0000F4   12....       LCALL   ?XSTORE_R0123
   4323                    
   4324                    // Write the APS link key back to the NV
   4325                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4326                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   0000F7                ; Setup parameters for call to function osal_nv_write
   \   0000F7   78..         MOV     R0,#?V0
   \   0000F9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FC   75..18       MOV     ?V2,#0x18
   \   0000FF   75..00       MOV     ?V3,#0x0
   \   000102   78..         MOV     R0,#?V2
   \   000104   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000107   7C00         MOV     R4,#0x0
   \   000109   7D00         MOV     R5,#0x0
   \   00010B   EE           MOV     A,R6
   \   00010C   2401         ADD     A,#0x1
   \   00010E   FA           MOV     R2,A
   \   00010F   EF           MOV     A,R7
   \   000110   3402         ADDC    A,#0x2
   \   000112   FB           MOV     R3,A
   \   000113   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000116   7404         MOV     A,#0x4
   \   000118   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011B   E9           MOV     A,R1
   4327                    
   4328                    // clear the pending write flag
   4329                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   00011C   EE           MOV     A,R6
   \   00011D   F8           MOV     R0,A
   \   00011E   EF           MOV     A,R7
   \   00011F   F9           MOV     R1,A
   \   000120   E8           MOV     A,R0
   \   000121   75F009       MOV     B,#0x9
   \   000124   A4           MUL     AB
   \   000125   C8           XCH     A,R0
   \   000126   AAF0         MOV     R2,B
   \   000128   75F000       MOV     B,#0x0
   \   00012B   A4           MUL     AB
   \   00012C   2A           ADD     A,R2
   \   00012D   FA           MOV     R2,A
   \   00012E   75F009       MOV     B,#0x9
   \   000131   E9           MOV     A,R1
   \   000132   A4           MUL     AB
   \   000133   2A           ADD     A,R2
   \   000134   F9           MOV     R1,A
   \   000135   74..         MOV     A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000137   28           ADD     A,R0
   \   000138   F582         MOV     DPL,A
   \   00013A   74..         MOV     A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00013C   39           ADDC    A,R1
   \   00013D   F583         MOV     DPH,A
   \   00013F   7400         MOV     A,#0x0
   \   000141   F0           MOVX    @DPTR,A
   4330                  }
   4331                }
   4332              }
   \                     ??ZDSecMgrSaveApsLinkKey_3:
   \   000142   0E           INC     R6
   \   000143   EE           MOV     A,R6
   \   000144   7001         JNZ     ??ZDSecMgrSaveApsLinkKey_4
   \   000146   0F           INC     R7
   \                     ??ZDSecMgrSaveApsLinkKey_4:
   \   000147   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   4333              
   4334              // clear copy of key in RAM 
   4335              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   00014A                ; Setup parameters for call to function osal_memset
   \   00014A   7C18         MOV     R4,#0x18
   \   00014C   7D00         MOV     R5,#0x0
   \   00014E   7900         MOV     R1,#0x0
   \   000150   AA..         MOV     R2,?V0
   \   000152   AB..         MOV     R3,?V1
   \   000154   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   4336              
   4337              osal_mem_free(pKeyData);
   \   000157                ; Setup parameters for call to function osal_mem_free
   \   000157   AA..         MOV     R2,?V0
   \   000159   AB..         MOV     R3,?V1
   \   00015B   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4338            }  
   4339          }
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   00015E   7F04         MOV     R7,#0x4
   \   000160   02....       LJMP    ?BANKED_LEAVE_XDATA
   4340          
   4341          /******************************************************************************
   4342           * @fn          ZDSecMgrSaveTCLinkKey
   4343           *
   4344           * @brief       Save TC Link Key to NV. It will loop through all the keys 
   4345           *              to see which one to save.
   4346           *           
   4347           * @param       none
   4348           *
   4349           * @return      none
   4350           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4351          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   4352          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4353            APSME_TCLinkKey_t *pKeyData = NULL;
   \   000005   75..00       MOV     ?V0,#0x0
   \   000008   75..00       MOV     ?V1,#0x0
   4354            int i;
   4355            
   4356            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A20         MOV     R2,#0x20
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   85....       MOV     ?V0,?V2
   \   000019   85....       MOV     ?V1,?V3
   4357            
   4358            if (pKeyData != NULL)
   \   00001C   E5..         MOV     A,?V0
   \   00001E   45..         ORL     A,?V1
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   4359            {          
   4360              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000025   7E00         MOV     R6,#0x0
   \   000027   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   000029   C3           CLR     C
   \   00002A   EE           MOV     A,R6
   \   00002B   9401         SUBB    A,#0x1
   \   00002D   EF           MOV     A,R7
   \   00002E   9400         SUBB    A,#0x0
   \   000030   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000032   65D0         XRL     A,PSW
   \   000034   33           RLC     A
   \   000035   4003         JC      $+5
   \   000037   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_2 & 0xFFFF
   4361              {
   4362                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   00003A   EE           MOV     A,R6
   \   00003B   F8           MOV     R0,A
   \   00003C   EF           MOV     A,R7
   \   00003D   F9           MOV     R1,A
   \   00003E   E8           MOV     A,R0
   \   00003F   75F009       MOV     B,#0x9
   \   000042   A4           MUL     AB
   \   000043   C8           XCH     A,R0
   \   000044   AAF0         MOV     R2,B
   \   000046   75F000       MOV     B,#0x0
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   FA           MOV     R2,A
   \   00004C   75F009       MOV     B,#0x9
   \   00004F   E9           MOV     A,R1
   \   000050   A4           MUL     AB
   \   000051   2A           ADD     A,R2
   \   000052   F9           MOV     R1,A
   \   000053   74..         MOV     A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   000055   28           ADD     A,R0
   \   000056   F582         MOV     DPL,A
   \   000058   74..         MOV     A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00005A   39           ADDC    A,R1
   \   00005B   F583         MOV     DPH,A
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6401         XRL     A,#0x1
   \   000060   6003         JZ      $+5
   \   000062   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_3 & 0xFFFF
   4363                {
   4364                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4365                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   000065                ; Setup parameters for call to function osal_nv_read
   \   000065   78..         MOV     R0,#?V0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   75..20       MOV     ?V2,#0x20
   \   00006D   75..00       MOV     ?V3,#0x0
   \   000070   78..         MOV     R0,#?V2
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   7C00         MOV     R4,#0x0
   \   000077   7D00         MOV     R5,#0x0
   \   000079   EE           MOV     A,R6
   \   00007A   2401         ADD     A,#0x1
   \   00007C   FA           MOV     R2,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3401         ADDC    A,#0x1
   \   000080   FB           MOV     R3,A
   \   000081   12....       LCALL   ??osal_nv_read?relay ; Banked call to: osal_nv_read
   \   000084   7404         MOV     A,#0x4
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
   \   000089   E9           MOV     A,R1
   \   00008A   6003         JZ      $+5
   \   00008C   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_3 & 0xFFFF
   4366                  {                
   4367                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   00008F   EE           MOV     A,R6
   \   000090   F8           MOV     R0,A
   \   000091   EF           MOV     A,R7
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   75F009       MOV     B,#0x9
   \   000097   A4           MUL     AB
   \   000098   C8           XCH     A,R0
   \   000099   AAF0         MOV     R2,B
   \   00009B   75F000       MOV     B,#0x0
   \   00009E   A4           MUL     AB
   \   00009F   2A           ADD     A,R2
   \   0000A0   FA           MOV     R2,A
   \   0000A1   75F009       MOV     B,#0x9
   \   0000A4   E9           MOV     A,R1
   \   0000A5   A4           MUL     AB
   \   0000A6   2A           ADD     A,R2
   \   0000A7   F9           MOV     R1,A
   \   0000A8   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   0000AA   28           ADD     A,R0
   \   0000AB   F582         MOV     DPL,A
   \   0000AD   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000AF   39           ADDC    A,R1
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   12....       LCALL   ?XLOAD_R0123
   \   0000B5   E5..         MOV     A,?V0
   \   0000B7   2418         ADD     A,#0x18
   \   0000B9   F582         MOV     DPL,A
   \   0000BB   E4           CLR     A
   \   0000BC   35..         ADDC    A,?V1
   \   0000BE   F583         MOV     DPH,A
   \   0000C0   12....       LCALL   ?XSTORE_R0123
   4368                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   0000C3   EE           MOV     A,R6
   \   0000C4   F8           MOV     R0,A
   \   0000C5   EF           MOV     A,R7
   \   0000C6   F9           MOV     R1,A
   \   0000C7   E8           MOV     A,R0
   \   0000C8   75F009       MOV     B,#0x9
   \   0000CB   A4           MUL     AB
   \   0000CC   C8           XCH     A,R0
   \   0000CD   AAF0         MOV     R2,B
   \   0000CF   75F000       MOV     B,#0x0
   \   0000D2   A4           MUL     AB
   \   0000D3   2A           ADD     A,R2
   \   0000D4   FA           MOV     R2,A
   \   0000D5   75F009       MOV     B,#0x9
   \   0000D8   E9           MOV     A,R1
   \   0000D9   A4           MUL     AB
   \   0000DA   2A           ADD     A,R2
   \   0000DB   F9           MOV     R1,A
   \   0000DC   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   0000DE   28           ADD     A,R0
   \   0000DF   F582         MOV     DPL,A
   \   0000E1   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000E3   39           ADDC    A,R1
   \   0000E4   F583         MOV     DPH,A
   \   0000E6   12....       LCALL   ?XLOAD_R0123
   \   0000E9   E5..         MOV     A,?V0
   \   0000EB   241C         ADD     A,#0x1c
   \   0000ED   F582         MOV     DPL,A
   \   0000EF   E4           CLR     A
   \   0000F0   35..         ADDC    A,?V1
   \   0000F2   F583         MOV     DPH,A
   \   0000F4   12....       LCALL   ?XSTORE_R0123
   4369                    
   4370                    // Write the TC link key back to the NV
   4371                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4372                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   0000F7                ; Setup parameters for call to function osal_nv_write
   \   0000F7   78..         MOV     R0,#?V0
   \   0000F9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FC   75..20       MOV     ?V2,#0x20
   \   0000FF   75..00       MOV     ?V3,#0x0
   \   000102   78..         MOV     R0,#?V2
   \   000104   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000107   7C00         MOV     R4,#0x0
   \   000109   7D00         MOV     R5,#0x0
   \   00010B   EE           MOV     A,R6
   \   00010C   2401         ADD     A,#0x1
   \   00010E   FA           MOV     R2,A
   \   00010F   EF           MOV     A,R7
   \   000110   3401         ADDC    A,#0x1
   \   000112   FB           MOV     R3,A
   \   000113   12....       LCALL   ??osal_nv_write?relay; Banked call to: osal_nv_write
   \   000116   7404         MOV     A,#0x4
   \   000118   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011B   E9           MOV     A,R1
   4373                    
   4374                    // clear the pending write flag
   4375                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   00011C   EE           MOV     A,R6
   \   00011D   F8           MOV     R0,A
   \   00011E   EF           MOV     A,R7
   \   00011F   F9           MOV     R1,A
   \   000120   E8           MOV     A,R0
   \   000121   75F009       MOV     B,#0x9
   \   000124   A4           MUL     AB
   \   000125   C8           XCH     A,R0
   \   000126   AAF0         MOV     R2,B
   \   000128   75F000       MOV     B,#0x0
   \   00012B   A4           MUL     AB
   \   00012C   2A           ADD     A,R2
   \   00012D   FA           MOV     R2,A
   \   00012E   75F009       MOV     B,#0x9
   \   000131   E9           MOV     A,R1
   \   000132   A4           MUL     AB
   \   000133   2A           ADD     A,R2
   \   000134   F9           MOV     R1,A
   \   000135   74..         MOV     A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   000137   28           ADD     A,R0
   \   000138   F582         MOV     DPL,A
   \   00013A   74..         MOV     A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00013C   39           ADDC    A,R1
   \   00013D   F583         MOV     DPH,A
   \   00013F   7400         MOV     A,#0x0
   \   000141   F0           MOVX    @DPTR,A
   4376                  }
   4377                }
   4378              }
   \                     ??ZDSecMgrSaveTCLinkKey_3:
   \   000142   0E           INC     R6
   \   000143   EE           MOV     A,R6
   \   000144   7001         JNZ     ??ZDSecMgrSaveTCLinkKey_4
   \   000146   0F           INC     R7
   \                     ??ZDSecMgrSaveTCLinkKey_4:
   \   000147   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_1 & 0xFFFF
   4379                // clear copy of key in RAM 
   4380              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   00014A                ; Setup parameters for call to function osal_memset
   \   00014A   7C20         MOV     R4,#0x20
   \   00014C   7D00         MOV     R5,#0x0
   \   00014E   7900         MOV     R1,#0x0
   \   000150   AA..         MOV     R2,?V0
   \   000152   AB..         MOV     R3,?V1
   \   000154   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   4381              
   4382              osal_mem_free(pKeyData);
   \   000157                ; Setup parameters for call to function osal_mem_free
   \   000157   AA..         MOV     R2,?V0
   \   000159   AB..         MOV     R3,?V1
   \   00015B   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4383            }
   4384          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   00015E   7F04         MOV     R7,#0x4
   \   000160   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExtGetIndex?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemoveByExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyTypeSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyTypeSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyNVIdGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsLinkKeyValid?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetDefaultNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeySync?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsDefaultTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNwkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrReadKeyFromNv?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrApsLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNVKeyTables?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveApsLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveTCLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey
   4385          
   4386          #if defined ( NV_RESTORE )
   4387          /******************************************************************************
   4388           * @fn          ZDSecMgrClearNVKeyValues
   4389           *
   4390           * @brief       If NV_RESTORE is enabled and the status of the network needs 
   4391           *              default values this fuction clears ZCD_NV_NWKKEY, 
   4392           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link 
   4393           *           
   4394           * @param       none
   4395           *
   4396           * @return      none
   4397           */
   4398          void ZDSecMgrClearNVKeyValues(void)
   4399          {
   4400            nwkActiveKeyItems keyItems;
   4401            nwkKeyDesc nwkKey;
   4402          
   4403            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4404          
   4405            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4406          
   4407            // Initialize NV items for NWK Active and Alternate keys. 
   4408            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4409          
   4410            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4411          
   4412            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4413          }
   4414          #endif // defined ( NV_RESTORE )
   4415          
   4416          /******************************************************************************
   4417          ******************************************************************************/
   4418          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     72   APSME_IsDefaultTCLK
      0     38   APSME_IsLinkKeyValid
        0     34   -> APSME_LinkKeyNVIdGet
        0     34   -> osal_mem_alloc
        0     37   -> osal_memcmp
        0     34   -> osal_memset
        0     38   -> osal_nv_read
      0      9   APSME_KeyFwdToChild
        0      9   -> AssocGetWithExt
        0      9   -> ZDSecMgrAssocDeviceAuth
      0     47   APSME_LinkKeyNVIdGet
        0     13   -> ZDSecMgrEntryLookupExt
      0     45   APSME_LinkKeySet
        0     25   -> ZDSecMgrEntryLookupExtGetIndex
        0     23   -> osal_mem_alloc
        0     23   -> osal_mem_free
        0     26   -> osal_memcpy
        0     23   -> osal_memset
        0     27   -> osal_nv_read
        0     27   -> osal_nv_write
      0     13   APSME_MasterKeyGet
        0     13   -> ZDSecMgrExtAddrLookup
        0     13   -> ZDSecMgrMasterKeyLookup
      0      9   APSME_SKA_TimerExpired
        0      9   -> ZDSecMgrDeviceCtrlUpdate
      0     57   APSME_TCLinkKeyInit
        0     47   -> osal_memcpy
        0     44   -> osal_memset
        0     46   -> osal_nv_item_init
        0     48   -> osal_nv_read
        0     48   -> osal_nv_write
      0     67   APSME_TCLinkKeyLoad
        0     63   -> APSME_IsDefaultTCLK
        0     63   -> APSME_LookupExtAddr
        0     63   -> AddrMgrEntryLookupNwk
        0     63   -> AddrMgrEntryRelease
        0     63   -> AddrMgrExtAddrEqual
        0     63   -> AddrMgrExtAddrValid
        0     63   -> osal_memset
        0     67   -> osal_nv_read
      0     54   APSME_TCLinkKeySync
        0     50   -> APSME_IsDefaultTCLK
        0     50   -> APSME_LookupExtAddr
        0     50   -> AddrMgrExtAddrEqual
        0     50   -> AddrMgrExtAddrValid
        0     50   -> osal_memset
        0     54   -> osal_nv_read
      0     24   ZDSecMgrAPSRemove
        0     22   -> ZDSecMgrDeviceRemove
      0     22   ZDSecMgrAddLinkKey
        0     18   -> APSME_LinkKeySet
        0     20   -> ZDSecMgrAddrStore
        0     18   -> ZDSecMgrEntryLookupAMI
        0     18   -> ZDSecMgrEntryNew
      0     37   ZDSecMgrAddrMgrUpdate
        0     23   -> AddrMgrEntryGet
        0     23   -> AddrMgrEntryUpdate
      0     61   ZDSecMgrAddrStore
        0     27   -> AddrMgrEntryUpdate
        0     27   -> AddrMgrExtAddrSet
      1     71   ZDSecMgrAppKeyGet
        0     14   -> SSP_GetTrueRand
      0     66   ZDSecMgrAppKeyReq
        0     49   -> APSME_LookupExtAddr
        0     49   -> APSME_LookupNwkAddr
        0     49   -> APSME_TransportKeyReq
        0     57   -> ZDSecMgrAppKeyGet
        0     49   -> osal_memset
      2      0   ZDSecMgrAppKeyTypeSet
      0     47   ZDSecMgrApsLinkKeyInit
        0     34   -> osal_memset
        0     36   -> osal_nv_item_init
        0     38   -> osal_nv_write
      2     35   ZDSecMgrAssocDeviceAuth
      0     16   ZDSecMgrAuthInitiate
        0     16   -> APSME_AuthenticateReq
        0     16   -> APSME_LookupNwkAddr
      2     25   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      0      9   ZDSecMgrAuthenticateCfm
        0      9   -> osal_set_event
      0     29   ZDSecMgrAuthenticateInd
        0     29   -> APSME_AuthenticateReq
        0     29   -> AddrMgrEntryUpdate
        0     29   -> AddrMgrExtAddrSet
      0      0   ZDSecMgrAuthenticationCheck
      1     12   ZDSecMgrAuthenticationSet
        0     12   -> ZDSecMgrEntryLookupExt
      2      9   ZDSecMgrConfig
        2      0   -> APSME_SecurityNM
      0     32   ZDSecMgrCtrlAdd
        0     18   -> ZDSecMgrCtrlSet
      0     10   ZDSecMgrCtrlInit
        0     10   -> osal_mem_alloc
      0     22   ZDSecMgrCtrlLookup
      2     11   ZDSecMgrCtrlRelease
      0     29   ZDSecMgrCtrlReset
        0     13   -> ZDSecMgrCtrlAdd
        0     13   -> ZDSecMgrCtrlLookup
        0     15   -> ZDSecMgrCtrlSet
      1     27   ZDSecMgrCtrlSet
      0     20   ZDSecMgrCtrlTerm
        0     11   -> ZDSecMgrCtrlLookup
        0     11   -> ZDSecMgrCtrlRelease
      1     43   ZDSecMgrDeviceCtrlHandler
        0     10   -> ZDSecMgrCtrlRelease
        0     10   -> ZDSecMgrEstablishKey
        0     10   -> ZDSecMgrSendMasterKey
        0     10   -> ZDSecMgrSendNwkKey
        0     10   -> osal_start_timerEx
      0      9   ZDSecMgrDeviceCtrlSetup
        0      9   -> ZDSecMgrDeviceCtrlHandler
      0     22   ZDSecMgrDeviceCtrlUpdate
        0     13   -> ZDSecMgrCtrlLookup
        0     13   -> ZDSecMgrEntryLookupExt
      0     46   ZDSecMgrDeviceEntryAdd
        0     14   -> ZDSecMgrAddrMgrUpdate
        0     14   -> ZDSecMgrCtrlAdd
        0     14   -> ZDSecMgrCtrlReset
        0     14   -> ZDSecMgrDeviceEntryRemove
        0     14   -> ZDSecMgrEntryLookup
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      0     23   ZDSecMgrDeviceEntryRemove
        0      9   -> ZDSecMgrCtrlTerm
        0      9   -> ZDSecMgrEntryFree
      0     35   ZDSecMgrDeviceJoin
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrDeviceRemove
        0     14   -> ZDSecMgrDeviceValidate
        0     14   -> ZDSecMgrSendNwkKey
      0     18   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      0     26   ZDSecMgrDeviceJoinFwd
        0     17   -> APSME_UpdateDeviceReq
      0     44   ZDSecMgrDeviceNew
        0      9   -> ZDSecMgrDeviceJoinDirect
        0      9   -> ZDSecMgrDeviceJoinFwd
      0     43   ZDSecMgrDeviceRemove
        0     21   -> APSME_RemoveDeviceReq
        0     21   -> AssocGetWithExt
        0     21   -> NLME_GetShortAddr
        0     21   -> NLME_LeaveReq
      0     11   ZDSecMgrDeviceRemoveByExtAddr
        0     11   -> ZDSecMgrDeviceEntryRemove
        0     11   -> ZDSecMgrEntryLookupExt
      0     23   ZDSecMgrDeviceValidate
        0      9   -> ZDSecMgrDeviceValidateRM
      0     35   ZDSecMgrDeviceValidateCM
        0     34   -> ZDSecMgrAddrStore
        0     32   -> ZDSecMgrDeviceEntryAdd
        0     32   -> ZDSecMgrMasterKeyLoad
        0     35   -> osal_memcpy
        0     32   -> osal_memset
      2      9   ZDSecMgrDeviceValidateRM
      0     39   ZDSecMgrDeviceValidateSKKE
        0     13   -> ZDSecMgrDeviceEntryAdd
        0     13   -> ZDSecMgrExtAddrLookup
        0     13   -> ZDSecMgrMasterKeyLookup
      0     25   ZDSecMgrEntryFree
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free
        0     12   -> osal_memset
        0     16   -> osal_nv_write
      0     12   ZDSecMgrEntryInit
        0     12   -> osal_mem_alloc
      0     40   ZDSecMgrEntryLookup
        0     26   -> AddrMgrEntryLookupNwk
      0     28   ZDSecMgrEntryLookupAMI
      0     26   ZDSecMgrEntryLookupExt
        0     13   -> ZDSecMgrEntryLookupAMI
        0     13   -> ZDSecMgrExtAddrLookup
      0     43   ZDSecMgrEntryLookupExtGetIndex
        0     18   -> ZDSecMgrExtAddrLookup
      0     27   ZDSecMgrEntryNew
      0     29   ZDSecMgrEstablishKey
        0     19   -> APSME_EstablishKeyReq
        0     19   -> NLME_GetShortAddr
      0      9   ZDSecMgrEstablishKeyCfm
        0      9   -> ZDSecMgrDeviceCtrlUpdate
      1     26   ZDSecMgrEstablishKeyInd
        0     26   -> APSME_EstablishKeyRsp
        0     26   -> ZDSecMgrDeviceValidateSKKE
        0     26   -> ZDSecMgrTCDataLoad
        0     26   -> ZDSecMgrTCExtAddrCheck
      1     33   ZDSecMgrEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> ZDSecMgrDeviceCtrlHandler
        0     33   -> osal_start_timerEx
      0     42   ZDSecMgrExtAddrLookup
        0     24   -> AddrMgrEntryLookupExt
        0     24   -> AddrMgrExtAddrSet
      0     29   ZDSecMgrExtAddrStore
        0     27   -> AddrMgrEntryUpdate
        0     27   -> AddrMgrExtAddrSet
      0      9   ZDSecMgrInit
        0      9   -> ZDSecMgrConfig
      0      9   ZDSecMgrInitNVKeyTables
        0      9   -> APSME_TCLinkKeyInit
        0      9   -> ZDSecMgrApsLinkKeyInit
        0      9   -> ZDSecMgrMasterKeyInit
        0      9   -> ZDSecMgrNwkKeyInit
      0     41   ZDSecMgrMasterKeyInit
        0     28   -> osal_memset
        0     30   -> osal_nv_item_init
        0     32   -> osal_nv_write
      0     54   ZDSecMgrMasterKeyLoad
        0     18   -> ZDSecMgrExtAddrLookup
        0     18   -> ZDSecMgrMasterKeyLookup
        0     18   -> ZDSecMgrMasterKeyStore
        0     22   -> osal_nv_write
      0     79   ZDSecMgrMasterKeyLookup
        0     32   -> osal_memset
        0     36   -> osal_nv_read
      0     69   ZDSecMgrMasterKeyStore
        0     37   -> osal_memcpy
        0     34   -> osal_memset
        0     38   -> osal_nv_read
        0     38   -> osal_nv_write
      1     35   ZDSecMgrNewDeviceEvent
        0     35   -> AddrMgrEntryGet
        0     35   -> AssocMatchDeviceStatus
        0     35   -> AssocRemove
        0     35   -> NLME_GetShortAddr
        0     35   -> ZDSecMgrAssocDeviceAuth
        0     35   -> ZDSecMgrDeviceNew
      0     61   ZDSecMgrNwkKeyInit
        0     48   -> osal_memset
        0     50   -> osal_nv_item_init
        0     52   -> osal_nv_write
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     41   ZDSecMgrReadKeyFromNv
        0     16   -> osal_nv_read
      0     19   ZDSecMgrRemoveDeviceInd
        0     19   -> APSME_LookupNwkAddr
        0     19   -> NLME_GetShortAddr
        0     19   -> ZDSecMgrDeviceRemove
      0     21   ZDSecMgrRequestAppKey
        0     21   -> APSME_RequestKeyReq
        0     21   -> AddrMgrExtAddrLookup
      0      9   ZDSecMgrRequestKeyInd
        0      9   -> ZDSecMgrAppKeyReq
      0     16   ZDSecMgrSaveApsLinkKey
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free
        0     12   -> osal_memset
        0     16   -> osal_nv_read
        0     16   -> osal_nv_write
      0     16   ZDSecMgrSaveTCLinkKey
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free
        0     12   -> osal_memset
        0     16   -> osal_nv_read
        0     16   -> osal_nv_write
      0     57   ZDSecMgrSendMasterKey
        0     43   -> APSME_TransportKeyReq
        0     43   -> NLME_GetShortAddr
        0     43   -> ZDSecMgrMasterKeyLookup
        0     43   -> osal_memset
        0     47   -> osal_nv_read
      1     60   ZDSecMgrSendNwkKey
        0     42   -> APSME_TransportKeyReq
        0     42   -> NLME_GetShortAddr
        0     46   -> NLME_ReadNwkKeyInfo
        0     42   -> osal_memset
      0     23   ZDSecMgrSetDefaultNV
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     19   -> osal_memset
        0     23   -> osal_nv_write
      0     25   ZDSecMgrSetupPartner
        0     25   -> AddrMgrEntryUpdate
        0     25   -> AddrMgrExtAddrSet
        0     25   -> AddrMgrExtAddrValid
        0     25   -> ZDP_IEEEAddrReq
        0     25   -> ZDP_NwkAddrReq
      0      9   ZDSecMgrSwitchKeyInd
        0      9   -> SSP_SwitchNwkKey
        0      9   -> ZDApp_NVUpdate
      1     13   ZDSecMgrSwitchNwkKey
        0     13   -> APSME_SwitchKeyReq
        0     13   -> SSP_SwitchNwkKey
        0     13   -> ZDApp_NVUpdate
      0     60   ZDSecMgrTCDataLoad
        0     33   -> ZDSecMgrAddrStore
        0     31   -> ZDSecMgrMasterKeyLookup
        0     31   -> ZDSecMgrMasterKeyStore
        0     34   -> osal_memcpy
        0     31   -> osal_memset
      0     43   ZDSecMgrTCExtAddrCheck
        0     17   -> AddrMgrExtAddrEqual
        0     17   -> AddrMgrExtAddrLookup
      0     25   ZDSecMgrTransportKeyInd
        0     25   -> SSP_SwitchNwkKey
        0     25   -> SSP_UpdateNwkKey
        0     25   -> ZDSecMgrAuthNwkKey
        0     25   -> ZDSecMgrReadKeyFromNv
        0     25   -> ZDSecMgrTCDataLoad
        0     25   -> osal_memset
      0     19   ZDSecMgrUpdateDeviceInd
        0     19   -> ZDSecMgrDeviceJoin
      1     25   ZDSecMgrUpdateNwkKey
        0     25   -> APSME_TransportKeyReq
        0     25   -> SSP_UpdateNwkKey
        0     25   -> ZDApp_NVUpdate


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
       6  ??APSME_IsDefaultTCLK?relay
       6  ??APSME_IsLinkKeyValid?relay
       6  ??APSME_KeyFwdToChild?relay
       6  ??APSME_LinkKeyNVIdGet?relay
       6  ??APSME_LinkKeySet?relay
       6  ??APSME_MasterKeyGet?relay
       6  ??APSME_SKA_TimerExpired?relay
       6  ??APSME_TCLinkKeyInit?relay
       6  ??APSME_TCLinkKeyLoad?relay
       6  ??APSME_TCLinkKeySync?relay
       6  ??ZDSecMgrAPSRemove?relay
       6  ??ZDSecMgrAddLinkKey?relay
       6  ??ZDSecMgrAddrMgrUpdate?relay
       6  ??ZDSecMgrAddrStore?relay
       6  ??ZDSecMgrAppKeyGet?relay
       6  ??ZDSecMgrAppKeyReq?relay
       6  ??ZDSecMgrAppKeyTypeSet?relay
       6  ??ZDSecMgrApsLinkKeyInit?relay
       6  ??ZDSecMgrAssocDeviceAuth?relay
       6  ??ZDSecMgrAuthInitiate?relay
       6  ??ZDSecMgrAuthNwkKey?relay
       6  ??ZDSecMgrAuthenticateCfm?relay
       6  ??ZDSecMgrAuthenticateInd?relay
       6  ??ZDSecMgrAuthenticationCheck?relay
       6  ??ZDSecMgrAuthenticationSet?relay
       6  ??ZDSecMgrConfig?relay
       6  ??ZDSecMgrCtrlAdd?relay
       6  ??ZDSecMgrCtrlInit?relay
       6  ??ZDSecMgrCtrlLookup?relay
       6  ??ZDSecMgrCtrlRelease?relay
       6  ??ZDSecMgrCtrlReset?relay
       6  ??ZDSecMgrCtrlSet?relay
       6  ??ZDSecMgrCtrlTerm?relay
       6  ??ZDSecMgrDeviceCtrlHandler?relay
       6  ??ZDSecMgrDeviceCtrlSetup?relay
       6  ??ZDSecMgrDeviceCtrlUpdate?relay
       6  ??ZDSecMgrDeviceEntryAdd?relay
       6  ??ZDSecMgrDeviceEntryRemove?relay
       6  ??ZDSecMgrDeviceJoin?relay
       6  ??ZDSecMgrDeviceJoinDirect?relay
       6  ??ZDSecMgrDeviceJoinFwd?relay
       6  ??ZDSecMgrDeviceNew?relay
       6  ??ZDSecMgrDeviceRemove?relay
       6  ??ZDSecMgrDeviceRemoveByExtAddr?relay
       6  ??ZDSecMgrDeviceValidate?relay
       6  ??ZDSecMgrDeviceValidateCM?relay
       6  ??ZDSecMgrDeviceValidateRM?relay
       6  ??ZDSecMgrDeviceValidateSKKE?relay
       6  ??ZDSecMgrEntryFree?relay
       6  ??ZDSecMgrEntryInit?relay
       6  ??ZDSecMgrEntryLookup?relay
       6  ??ZDSecMgrEntryLookupAMI?relay
       6  ??ZDSecMgrEntryLookupExt?relay
       6  ??ZDSecMgrEntryLookupExtGetIndex?relay
       6  ??ZDSecMgrEntryNew?relay
       6  ??ZDSecMgrEstablishKey?relay
       6  ??ZDSecMgrEstablishKeyCfm?relay
       6  ??ZDSecMgrEstablishKeyInd?relay
       6  ??ZDSecMgrEvent?relay
       6  ??ZDSecMgrExtAddrLookup?relay
       6  ??ZDSecMgrExtAddrStore?relay
       6  ??ZDSecMgrInit?relay
       6  ??ZDSecMgrInitNVKeyTables?relay
       6  ??ZDSecMgrMasterKeyInit?relay
       6  ??ZDSecMgrMasterKeyLoad?relay
       6  ??ZDSecMgrMasterKeyLookup?relay
       6  ??ZDSecMgrMasterKeyStore?relay
       6  ??ZDSecMgrNewDeviceEvent?relay
       6  ??ZDSecMgrNwkKeyInit?relay
       6  ??ZDSecMgrPermitJoining?relay
       6  ??ZDSecMgrPermitJoiningTimeout?relay
       6  ??ZDSecMgrReadKeyFromNv?relay
       6  ??ZDSecMgrRemoveDeviceInd?relay
       6  ??ZDSecMgrRequestAppKey?relay
       6  ??ZDSecMgrRequestKeyInd?relay
       6  ??ZDSecMgrSaveApsLinkKey?relay
       6  ??ZDSecMgrSaveTCLinkKey?relay
       6  ??ZDSecMgrSendMasterKey?relay
       6  ??ZDSecMgrSendNwkKey?relay
       6  ??ZDSecMgrSetDefaultNV?relay
       6  ??ZDSecMgrSetupPartner?relay
       6  ??ZDSecMgrSwitchKeyInd?relay
       6  ??ZDSecMgrSwitchNwkKey?relay
       6  ??ZDSecMgrTCDataLoad?relay
       6  ??ZDSecMgrTCExtAddrCheck?relay
       6  ??ZDSecMgrTransportKeyInd?relay
       6  ??ZDSecMgrUpdateDeviceInd?relay
       6  ??ZDSecMgrUpdateNwkKey?relay
      60  APSME_IsDefaultTCLK
     185  APSME_IsLinkKeyValid
      89  APSME_KeyFwdToChild
      91  APSME_LinkKeyNVIdGet
     512  APSME_LinkKeySet
      80  APSME_MasterKeyGet
      37  APSME_SKA_TimerExpired
     410  APSME_TCLinkKeyInit
     367  APSME_TCLinkKeyLoad
     341  APSME_TCLinkKeySync
      27  ApsLinkKeyFrmCntr
       9  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
     114  ZDSecMgrAPSRemove
     169  ZDSecMgrAddLinkKey
      89  ZDSecMgrAddrMgrUpdate
     135  ZDSecMgrAddrStore
      71  ZDSecMgrAppKeyGet
     322  ZDSecMgrAppKeyReq
       1  ZDSecMgrAppKeyType
      34  ZDSecMgrAppKeyTypeSet
     135  ZDSecMgrApsLinkKeyInit
      28  ZDSecMgrAssocDeviceAuth
      76  ZDSecMgrAuthInitiate
      32  ZDSecMgrAuthNwkKey
      58  ZDSecMgrAuthenticateCfm
     157  ZDSecMgrAuthenticateInd
       5  ZDSecMgrAuthenticationCheck
      71  ZDSecMgrAuthenticationSet
      14  ZDSecMgrConfig
     169  ZDSecMgrCtrlAdd
       2  ZDSecMgrCtrlData
     114  ZDSecMgrCtrlInit
     225  ZDSecMgrCtrlLookup
      23  ZDSecMgrCtrlRelease
     103  ZDSecMgrCtrlReset
     119  ZDSecMgrCtrlSet
      64  ZDSecMgrCtrlTerm
     219  ZDSecMgrDeviceCtrlHandler
     113  ZDSecMgrDeviceCtrlSetup
     219  ZDSecMgrDeviceCtrlUpdate
     306  ZDSecMgrDeviceEntryAdd
      34  ZDSecMgrDeviceEntryRemove
     101  ZDSecMgrDeviceJoin
      45  ZDSecMgrDeviceJoinDirect
     236  ZDSecMgrDeviceJoinFwd
      44  ZDSecMgrDeviceNew
     249  ZDSecMgrDeviceRemove
      58  ZDSecMgrDeviceRemoveByExtAddr
      75  ZDSecMgrDeviceValidate
     165  ZDSecMgrDeviceValidateCM
      21  ZDSecMgrDeviceValidateRM
      98  ZDSecMgrDeviceValidateSKKE
       2  ZDSecMgrEntries
     127  ZDSecMgrEntryFree
     166  ZDSecMgrEntryInit
     227  ZDSecMgrEntryLookup
     162  ZDSecMgrEntryLookupAMI
      79  ZDSecMgrEntryLookupExt
     223  ZDSecMgrEntryLookupExtGetIndex
     210  ZDSecMgrEntryNew
     171  ZDSecMgrEstablishKey
      32  ZDSecMgrEstablishKeyCfm
     268  ZDSecMgrEstablishKeyInd
     575  ZDSecMgrEvent
     113  ZDSecMgrExtAddrLookup
     135  ZDSecMgrExtAddrStore
      15  ZDSecMgrInit
      28  ZDSecMgrInitNVKeyTables
     152  ZDSecMgrMasterKeyInit
     132  ZDSecMgrMasterKeyLoad
     174  ZDSecMgrMasterKeyLookup
     268  ZDSecMgrMasterKeyStore
     229  ZDSecMgrNewDeviceEvent
     276  ZDSecMgrNwkKeyInit
      49  ZDSecMgrPermitJoining
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      31  ZDSecMgrPermitJoiningTimeout
     276  ZDSecMgrReadKeyFromNv
      95  ZDSecMgrRemoveDeviceInd
      88  ZDSecMgrRequestAppKey
      47  ZDSecMgrRequestKeyInd
     355  ZDSecMgrSaveApsLinkKey
     355  ZDSecMgrSaveTCLinkKey
     318  ZDSecMgrSendMasterKey
     343  ZDSecMgrSendNwkKey
     284  ZDSecMgrSetDefaultNV
     137  ZDSecMgrSetupPartner
      30  ZDSecMgrSwitchKeyInd
      69  ZDSecMgrSwitchNwkKey
       1  ZDSecMgrTCAuthenticated
     166  ZDSecMgrTCDataLoad
       1  ZDSecMgrTCDataLoaded
       8  ZDSecMgrTCExtAddr
      57  ZDSecMgrTCExtAddrCheck
      16  ZDSecMgrTCMasterKey
     261  ZDSecMgrTransportKeyInd
      95  ZDSecMgrUpdateDeviceInd
     137  ZDSecMgrUpdateNwkKey
       4  __Constant_1

 
 13 437 bytes in segment BANKED_CODE
    528 bytes in segment BANK_RELAYS
     16 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
      4 bytes in segment XDATA_ROM_C
     84 bytes in segment XDATA_Z
 
 13 982 bytes of CODE  memory
      0 bytes of CONST memory (+ 4 bytes shared)
     85 bytes of XDATA memory

Errors: none
Warnings: none
